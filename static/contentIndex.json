{"component/index":{"slug":"component/index","filePath":"component/index.md","title":"可重用技術元件庫","links":[],"tags":["技術元件","設計模式","知識資產","標準化"],"content":"可重用技術元件庫\n\n從專案實戰經驗中提煉技術精華，建立符合高內聚低耦合原則的標準化元件庫\n\n戰略定位\n長遠目標\n將散落在各專案中的技術經驗系統化整理，形成可重複利用的技術資產庫。這不僅提升開發效率，更重要的是建立個人技術能力的系統化展示平台。\n核心價值\n專案經驗 → 模式識別 → 抽象設計 → 標準元件 → 新專案應用\n    ↓          ↓          ↓          ↓           ↓\n  具體實作   通用需求   設計原則   API標準    快速開發\n\n智慧財產權保護策略\n分享與保護的平衡\n\n展示思考過程：顯示問題分析與解決方法論 ✓\n抽象化設計：展示架構思維而非具體實作 ✓\n保護核心實作：避免洩露關鍵商業邏輯 ✓\n促進技術交流：建立專業形象與技術影響力 ✓\n\n內容分級策略\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n級別內容範圍展示方式保護重點架構級設計模式、技術選型完整展示思維過程介面級API設計、模組邊界標準展示設計原則實作級核心算法、關鍵邏輯抽象展示商業價值配置級具體參數、業務規則隱藏保護競爭優勢\n元件分類架構\n基礎設施元件\n\n支撐系統運行的底層技術元件\n\n通信與整合\n\n跨域通信抽象層：解決瀏覽器安全限制\nAPI客戶端標準化：統一的錯誤處理與重試機制\n訊息佇列處理器：異步通信的可靠性保證\n\n資源管理\n\n記憶體池管理：減少GC壓力的智能分配策略\n連接池優化：資料庫與外部服務的高效連接管理\n快取策略實現：多層次快取的一致性保證\n\n效能優化元件\n\n經過實戰驗證的效能提升模式\n\n異步處理模式\n\n批次處理調度器：平衡延遲與吞吐量的智能調度\n背壓控制機制：防止系統過載的自適應限流\n管道式處理架構：流式數據的高效處理模式\n\n監控與診斷\n\n效能分析器：自動識別系統瓶頸\n資源使用追蹤：記憶體、CPU、IO的統一監控\n錯誤追蹤系統：分散式環境的錯誤關聯分析\n\n使用者介面元件\n\n解決通用UI問題的標準化元件\n\n互動模式\n\n智能對話框：支援AI助手的標準化對話介面\n檔案處理器：拖拽上傳與進度追蹤的統一實作\n表單建構器：動態生成與驗證的可配置表單系統\n\n視覺化組件\n\n即時監控圖表：效能指標的實時視覺化展示\n數據分析儀表板：多維度數據的互動式探索\n狀態指示器：系統健康狀態的直觀展示\n\nAI整合元件\n\nAI能力的標準化封裝與整合模式\n\n模型抽象層\n\n推理引擎介面：支援多種AI模型的統一調用\n結果後處理器：AI輸出的標準化處理與優化\n上下文管理器：對話狀態與記憶的持久化管理\n\n智能化工具\n\n自動化測試生成：基於AI的測試案例自動生成\n代碼品質分析：AI驅動的代碼審查與建議\n效能優化建議：智能化的系統調優建議\n\n元件開發標準\n設計原則\n單一職責：每個元件解決一個明確的問題\n開放封閉：對擴展開放，對修改封閉\n依賴倒置：依賴抽象而非具體實作\n介面隔離：客戶端不應依賴不需要的介面\n\n文檔標準\n# 元件名稱\n \n## 問題定義\n- 解決什麼業務或技術問題\n- 適用的場景與限制條件\n \n## 設計原理  \n- 第一性原理分析\n- 架構設計決策與權衡考量\n \n## 介面設計\n- 核心API定義與使用方式\n- 配置選項與客製化方案\n \n## 實作要點\n- 關鍵技術點（抽象化展示）\n- 效能考量與優化策略\n \n## 驗證結果\n- 效能指標與改進效果\n- 在具體專案中的應用效果\n \n## 相關連結\n- 源專案應用案例\n- 相關技術文檔\n元件成熟度模型\nLevel 1: 概念驗證 (Proof of Concept)\n\n特徵：基本功能實現，單一專案驗證\n文檔：問題定義與基本設計說明\n品質：功能可用，缺少邊界情況處理\n\nLevel 2: 專案就緒 (Project Ready)\n\n特徵：多專案使用，配置化支援\n文檔：完整的使用指南與API文檔\n品質：錯誤處理完善，基本效能優化\n\nLevel 3: 生產就緒 (Production Ready)\n\n特徵：效能優化完成，監控與診斷完備\n文檔：故障排除指南與最佳實踐\n品質：全面測試覆蓋，上線運行穩定\n\nLevel 4: 社群標準 (Community Standard)\n\n特徵：廣泛使用驗證，持續演進改進\n文檔：綜合性教學與進階應用指南\n品質：行業認可，成為事實標準\n\n當前元件清單\n正在開發的元件\nExtensionBridge (Level 2)\n\n來源專案：browser-extension-ecosystem\n解決問題：瀏覽器擴展與後端服務的可靠通信\n核心價值：跨域限制的優雅解決方案\n技術特點：Service Worker整合、錯誤重試、狀態同步\n\nPerformanceAnalyzer (Level 2)\n\n來源專案：AI基準測試優化\n解決問題：系統效能瓶頸的自動化識別\n核心價值：30%效能提升的方法論\n技術特點：異步分析、記憶體追蹤、瓶頸定位\n\nConfigManager (Level 1)\n\n來源專案：多專案共同需求\n解決問題：統一的配置管理與環境適應\n核心價值：減少配置相關錯誤90%\n技術特點：類型安全、環境隔離、熱更新\n\n規劃中的元件\nAsyncBatchProcessor\n\n目標問題：大量數據的高效批次處理\n預期來源：AI訓練數據處理經驗\n成熟度目標：Level 3\n\nMemoryPool\n\n目標問題：減少GC壓力的智能記憶體管理\n預期來源：遊戲引擎開發經驗\n成熟度目標：Level 3\n\nAiChatWidget\n\n目標問題：AI對話的標準化UI元件\n預期來源：多個AI整合專案\n成熟度目標：Level 2\n\n面試展示策略\n技術能力展示\n元件展示 = 問題分析能力 + 抽象設計思維 + 工程實踐經驗\n        ≠ 具體代碼實作 + 商業機密洩露\n\n展示重點\n\n系統性思考：如何從具體問題抽象出通用解決方案\n工程實踐：如何平衡效能、可維護性、可擴展性\n技術判斷：如何選擇合適的技術方案與架構模式\n持續改進：如何根據實際使用反饋優化設計\n\n避免洩露\n\n具體的商業邏輯實現\n關鍵算法的詳細實作\n特定業務的配置參數\n競爭優勢的技術細節\n\n質量保證機制\n自動化驗證\n\nAPI一致性檢查：確保介面設計的一致性\n文檔完整性驗證：確保文檔與實作的同步\n效能基準測試：驗證效能改進宣稱的真實性\n安全性掃描：檢查是否洩露敏感資訊\n\n人工審查\n\n技術價值評估：確保元件的實際價值\n抽象化程度檢查：平衡展示與保護的需求\n專業形象維護：確保展示內容的專業性\n知識關聯性確認：建立元件間的有效連結\n\n使用與貢獻指南\n如何選擇元件\n\n問題匹配度：元件是否直接解決你的核心問題\n成熟度評估：元件的可靠性與完整性等級\n整合成本：引入元件的複雜度與依賴分析\n客製化支援：是否支援你的特定需求\n\n如何貢獻新元件\n\n實戰驗證：確保元件經過至少一個真實專案的驗證\n問題普遍性：確認解決的問題具有一定的通用性\n抽象化設計：將具體實作抽象為可重用的模式\n文檔規範：按照標準模板撰寫完整文檔\n安全審查：確保不洩露敏感的商業資訊\n\n\n戰略價值：建立個人技術能力的系統化展示平台，在保護核心競爭優勢的同時，展現技術思維與工程能力。\n下一步行動：完成ExtensionBridge元件的標準化文檔，建立元件評估與選擇的決策框架。\n維護責任：PekoraTech SA Team - Architecture &amp; Standards\n更新策略：根據專案經驗持續豐富，每季度進行一次全面審查\n最後審查：2025-07-05"},"component/mcp-development-framework":{"slug":"component/mcp-development-framework","filePath":"component/mcp-development-framework.md","title":"mcp-development-framework","links":[],"tags":[],"content":"MCP開發框架 - SA工具快速建構模式\n\n組件類型: 開發框架模式\n重用價值: 極高\n技術等級: 中高級\n維護狀態: 活躍開發中\n\n框架概述\n基於MCP Git Analyzer專案實戰經驗，萃取出的可重複使用MCP開發框架。此框架專為系統分析師工具開發優化，遵循KISS原則與高內聚低耦合設計。\n核心組件架構\n1. MCP Server基礎類別\nclass NPXCompatibleMCPServer {\n  constructor() {\n    this.tools = [];\n    this.initializeServer();\n  }\n  \n  // 工具註冊模式\n  registerTool(name, description, schema, handler) {\n    this.tools.push({\n      name,\n      description, \n      inputSchema: schema,\n      handler\n    });\n  }\n  \n  // 標準化錯誤處理\n  handleError(error, context) {\n    console.error(JSON.stringify({\n      level: &#039;ERROR&#039;,\n      timestamp: new Date().toISOString(),\n      error: error.message,\n      context\n    }));\n  }\n}\n2. 工具開發模板\n// 工具定義標準模式\nconst toolTemplate = {\n  name: &#039;tool_name&#039;,\n  description: &#039;工具功能描述&#039;,\n  inputSchema: {\n    type: &#039;object&#039;,\n    properties: {\n      requiredParam: {\n        type: &#039;string&#039;,\n        description: &#039;必要參數說明&#039;\n      },\n      optionalParam: {\n        type: &#039;number&#039;,\n        description: &#039;可選參數說明&#039;,\n        default: 10\n      }\n    },\n    required: [&#039;requiredParam&#039;]\n  }\n};\n3. CLI整合框架\nimport { program } from &#039;commander&#039;;\n \n// 標準化CLI配置\nfunction setupCLI() {\n  program\n    .name(&#039;mcp-tool-name&#039;)\n    .description(&#039;MCP工具描述&#039;)\n    .version(&#039;1.0.0&#039;);\n    \n  program\n    .command(&#039;start&#039;)\n    .description(&#039;啟動MCP Server&#039;)\n    .action(startMCPServer);\n    \n  program\n    .command(&#039;test &lt;target&gt;&#039;)\n    .description(&#039;測試功能&#039;)\n    .action(testFunction);\n    \n  program.parse();\n}\n部署配置模式\npackage.json標準配置\n{\n  &quot;name&quot;: &quot;@selfpagesource/mcp-[tool-name]&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;description&quot;: &quot;MCP工具描述&quot;,\n  &quot;main&quot;: &quot;index.js&quot;,\n  &quot;bin&quot;: {\n    &quot;mcp-[tool-name]&quot;: &quot;./index.js&quot;\n  },\n  &quot;type&quot;: &quot;module&quot;,\n  &quot;scripts&quot;: {\n    &quot;global-install&quot;: &quot;npm install -g .&quot;,\n    &quot;test-basic&quot;: &quot;node index.js test [test-target]&quot;\n  },\n  &quot;engines&quot;: {\n    &quot;node&quot;: &quot;&gt;=18.0.0&quot;\n  }\n}\nClaude Desktop配置模板\n{\n  &quot;mcpServers&quot;: {\n    &quot;[tool-name]&quot;: {\n      &quot;command&quot;: &quot;npx&quot;,\n      &quot;args&quot;: [&quot;@selfpagesource/mcp-[tool-name]&quot;, &quot;start&quot;],\n      &quot;cwd&quot;: &quot;[工作目錄]&quot;,\n      &quot;env&quot;: {\n        &quot;NODE_ENV&quot;: &quot;production&quot;\n      }\n    }\n  }\n}\n故障排除標準流程\n部署問題診斷\n// 環境檢查清單\nconst deploymentChecklist = {\n  nodeVersion: () =&gt; process.version &gt;= &#039;v18.0.0&#039;,\n  npmGlobalInstall: () =&gt; checkGlobalPackage(),\n  permissionsCheck: () =&gt; checkFilePermissions(),\n  pathResolution: () =&gt; validatePaths()\n};\n \nfunction runDiagnostics() {\n  Object.entries(deploymentChecklist).forEach(([check, test]) =&gt; {\n    const result = test();\n    console.log(`${check}: ${result ? &#039;✅&#039; : &#039;❌&#039;}`);\n  });\n}\n常見問題與解決方案\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n問題類型症狀解決方案404 Not Foundnpm找不到package執行npm install -g .權限不足EACCES錯誤檢查檔案權限與執行權限路徑問題Module not found驗證絕對路徑與相對路徑Node版本Syntax錯誤升級至Node.js 18+\n測試框架模式\n基礎測試結構\ndescribe(&#039;MCP Tool Tests&#039;, () =&gt; {\n  describe(&#039;Tool Registration&#039;, () =&gt; {\n    it(&#039;should register tools correctly&#039;, () =&gt; {\n      // 工具註冊測試\n    });\n  });\n  \n  describe(&#039;Function Tests&#039;, () =&gt; {\n    it(&#039;should handle valid inputs&#039;, () =&gt; {\n      // 功能測試\n    });\n    \n    it(&#039;should handle invalid inputs gracefully&#039;, () =&gt; {\n      // 錯誤處理測試\n    });\n  });\n  \n  describe(&#039;Integration Tests&#039;, () =&gt; {\n    it(&#039;should work with Claude Desktop&#039;, () =&gt; {\n      // 整合測試\n    });\n  });\n});\n效能測試模板\ndescribe(&#039;Performance Tests&#039;, () =&gt; {\n  it(&#039;should complete within acceptable time&#039;, async () =&gt; {\n    const start = performance.now();\n    await toolFunction(testInput);\n    const duration = performance.now() - start;\n    \n    expect(duration).toBeLessThan(5000); // 5秒內\n  });\n});\nVSCode開發環境配置\nlaunch.json模板\n{\n  &quot;version&quot;: &quot;0.2.0&quot;,\n  &quot;configurations&quot;: [\n    {\n      &quot;name&quot;: &quot;1. Install Dependencies&quot;,\n      &quot;type&quot;: &quot;node&quot;,\n      &quot;request&quot;: &quot;launch&quot;,\n      &quot;program&quot;: &quot;install-deps.js&quot;\n    },\n    {\n      &quot;name&quot;: &quot;2. Install Globally&quot;, \n      &quot;type&quot;: &quot;node&quot;,\n      &quot;request&quot;: &quot;launch&quot;,\n      &quot;program&quot;: &quot;global-install.js&quot;\n    },\n    {\n      &quot;name&quot;: &quot;3. Test Tool&quot;,\n      &quot;type&quot;: &quot;node&quot;,\n      &quot;request&quot;: &quot;launch&quot;,\n      &quot;program&quot;: &quot;index.js&quot;,\n      &quot;args&quot;: [&quot;test&quot;, &quot;[test-target]&quot;]\n    }\n  ]\n}\n自動化安裝腳本\n// install-deps.js\nimport { exec } from &#039;child_process&#039;;\nimport { promisify } from &#039;util&#039;;\n \nconst execAsync = promisify(exec);\n \nasync function installDependencies() {\n  try {\n    console.log(&#039;安裝依賴中...&#039;);\n    await execAsync(&#039;npm install&#039;);\n    console.log(&#039;✅ 依賴安裝完成&#039;);\n  } catch (error) {\n    console.error(&#039;❌ 安裝失敗:&#039;, error.message);\n  }\n}\n \ninstallDependencies();\n安全性標準\n輸入驗證框架\nclass InputValidator {\n  static validatePath(path) {\n    // 路徑安全檢查\n    const normalized = pathModule.resolve(path);\n    if (!normalized.startsWith(process.cwd())) {\n      throw new Error(&#039;Invalid path: outside working directory&#039;);\n    }\n    return normalized;\n  }\n  \n  static sanitizeInput(input) {\n    // 輸入清理\n    if (typeof input !== &#039;string&#039;) return input;\n    return input.replace(/[&lt;&gt;\\&quot;&#039;&amp;]/g, &#039;&#039;);\n  }\n}\n權限控制模式\nconst permissionLevels = {\n  READ_ONLY: [&#039;status&#039;, &#039;log&#039;, &#039;show&#039;],\n  SAFE_OPERATIONS: [&#039;branch&#039;, &#039;remote&#039;, &#039;diff&#039;],\n  FORBIDDEN: [&#039;commit&#039;, &#039;push&#039;, &#039;pull&#039;, &#039;merge&#039;, &#039;reset&#039;]\n};\n \nfunction checkPermission(operation) {\n  if (permissionLevels.FORBIDDEN.includes(operation)) {\n    throw new Error(`Operation ${operation} is not permitted`);\n  }\n}\n文檔化標準\nREADME模板結構\n# MCP [工具名稱] - 簡潔描述\n \n## 🎯 唯一解決方案\n \n**VS Code + NPX 全域安裝**\n \n## 📋 步驟（專注、單一）\n \n### 1. 開啟VS Code\n### 2. 執行安裝序列  \n### 3. Claude Desktop 配置\n \n## ✅ 完成\n \n重啟Claude Desktop即可使用。\n技術文檔結構\n# 技術架構說明\n## 核心功能\n## API參考\n## 配置選項\n## 故障排除\n## 效能考量\n重用指南\n快速創建新MCP工具\n\n複製框架: 從mcp-git-analyzer複製基礎結構\n修改package.json: 更新名稱、描述、依賴\n實現工具邏輯: 基於模板實現具體功能\n配置測試: 建立對應的測試案例\n部署驗證: 使用VSCode F5快速測試\n\n最佳實踐檢查清單\n\n 遵循KISS原則，功能單一明確\n 實現適當的錯誤處理\n 提供清晰的輸入驗證\n 建立完整的測試覆蓋\n 撰寫簡潔明瞭的文檔\n 確保跨平台相容性\n 實施安全性檢查\n\n擴展建議\n進階功能模式\n// 快取機制\nclass CacheManager {\n  constructor(maxSize = 1000) {\n    this.cache = new Map();\n    this.maxSize = maxSize;\n  }\n  \n  get(key) {\n    if (this.cache.has(key)) {\n      const entry = this.cache.get(key);\n      if (Date.now() - entry.timestamp &lt; 3600000) {\n        return entry.data;\n      }\n      this.cache.delete(key);\n    }\n    return null;\n  }\n}\n \n// 並行處理\nasync function processInBatches(items, processor, batchSize = 10) {\n  const results = [];\n  for (let i = 0; i &lt; items.length; i += batchSize) {\n    const batch = items.slice(i, i + batchSize);\n    const batchResults = await Promise.all(\n      batch.map(item =&gt; processor(item))\n    );\n    results.push(...batchResults);\n  }\n  return results;\n}\n插件架構模式\nclass PluginManager {\n  constructor() {\n    this.plugins = new Map();\n  }\n  \n  register(name, plugin) {\n    this.plugins.set(name, plugin);\n  }\n  \n  execute(name, ...args) {\n    const plugin = this.plugins.get(name);\n    if (!plugin) throw new Error(`Plugin ${name} not found`);\n    return plugin.execute(...args);\n  }\n}\n維護策略\n版本控制\n\n語義化版本: 遵循semver規範\n變更日誌: 記錄所有重要變更\n向後相容: 避免破壞性變更\n\n持續改進\n\n效能監控: 定期檢查工具效能\n用戶回饋: 收集實際使用經驗\n技術升級: 跟進依賴庫更新\n\n\n框架維護者: PekoraTech SA Team\n最後更新: 2025-07-05\n重用等級: 極高\n技術等級: 中高級"},"daily-code/2025-06-26-flutter-state-management":{"slug":"daily-code/2025-06-26-flutter-state-management","filePath":"daily-code/2025-06-26-flutter-state-management.md","title":"Flutter 狀態管理最佳實踐","links":["daily-code/2025-06-20-react-hooks-patterns","projects/ai-development-suite","projects/game-system-evolution","tags/Flutter","tags/Dart","tags/StateManagement","tags/Riverpod","tags/MobileDevelopment","tags/Architecture"],"tags":["Flutter","Dart","狀態管理","Riverpod","移動開發","StateManagement","MobileDevelopment","Architecture"],"content":"📱 Flutter 狀態管理最佳實踐\n\n今日焦點：在 test-flutter 專案中實現 Riverpod 狀態管理，告別 setState 的混亂\n\n🎯 問題背景\n從混亂到清晰的狀態管理之路\n在開發 Flutter 應用時，隨著功能增加，狀態管理逐漸變成噩夢：\n// ❌ 傳統 setState 方式的問題\nclass _MyAppState extends State&lt;MyApp&gt; {\n  bool _isLoading = false;\n  String _userInfo = &#039;&#039;;\n  List&lt;Item&gt; _items = [];\n  String _error = &#039;&#039;;\n \n  void _fetchData() async {\n    setState(() {\n      _isLoading = true;\n      _error = &#039;&#039;;\n    });\n \n    try {\n      final userData = await _apiService.getUser();\n      final itemsData = await _apiService.getItems();\n \n      setState(() {\n        _userInfo = userData;\n        _items = itemsData;\n        _isLoading = false;\n      });\n    } catch (e) {\n      setState(() {\n        _error = e.toString();\n        _isLoading = false;\n      });\n    }\n  }\n \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: _isLoading\n        ? CircularProgressIndicator()\n        : _error.isNotEmpty\n          ? Text(&#039;錯誤: $_error&#039;)\n          : ListView.builder(/* ... */),\n    );\n  }\n}\n主要痛點：\n\n🚫 狀態分散在各個 Widget 中\n🔄 重複的載入/錯誤處理邏輯\n📊 狀態同步困難\n🐛 難以測試和除錯\n🔗 Widget 耦合度過高\n\n🚀 Riverpod 解決方案\n核心設計原則\n// ✅ Riverpod 狀態管理 - 清晰分離\n// 1. 資料層 - 純粹的狀態定義\n@riverpod\nclass UserNotifier extends _$UserNotifier {\n  @override\n  AsyncValue&lt;UserInfo&gt; build() {\n    return const AsyncValue.loading();\n  }\n \n  Future&lt;void&gt; fetchUser(String userId) async {\n    state = const AsyncValue.loading();\n \n    try {\n      final userService = ref.read(userServiceProvider);\n      final user = await userService.getUser(userId);\n      state = AsyncValue.data(user);\n    } catch (error, stackTrace) {\n      state = AsyncValue.error(error, stackTrace);\n    }\n  }\n \n  void updateUser(UserInfo user) {\n    state = AsyncValue.data(user);\n  }\n}\n \n// 2. 服務層 - 業務邏輯封裝\n@riverpod\nUserService userService(UserServiceRef ref) {\n  return UserService(\n    httpClient: ref.read(httpClientProvider),\n    localStorage: ref.read(localStorageProvider),\n  );\n}\n \nclass UserService {\n  UserService({\n    required this.httpClient,\n    required this.localStorage,\n  });\n \n  final HttpClient httpClient;\n  final LocalStorage localStorage;\n \n  Future&lt;UserInfo&gt; getUser(String userId) async {\n    // 先檢查本地快取\n    final cached = await localStorage.getUser(userId);\n    if (cached != null &amp;&amp; !cached.isExpired) {\n      return cached;\n    }\n \n    // 網路請求\n    final response = await httpClient.get(&#039;/users/$userId&#039;);\n    final user = UserInfo.fromJson(response.data);\n \n    // 快取結果\n    await localStorage.saveUser(user);\n \n    return user;\n  }\n}\n狀態組合與依賴注入\n// 3. 複雜狀態組合\n@riverpod\nclass AppStateNotifier extends _$AppStateNotifier {\n  @override\n  AppState build() {\n    // 監聽多個狀態的變化\n    final user = ref.watch(userNotifierProvider);\n    final settings = ref.watch(settingsNotifierProvider);\n    final networkStatus = ref.watch(networkStatusProvider);\n \n    return AppState(\n      user: user,\n      settings: settings,\n      isOnline: networkStatus,\n      isInitialized: user.hasValue &amp;&amp; settings.hasValue,\n    );\n  }\n \n  Future&lt;void&gt; initialize() async {\n    // 並行初始化\n    await Future.wait([\n      ref.read(userNotifierProvider.notifier).fetchUser(&#039;current&#039;),\n      ref.read(settingsNotifierProvider.notifier).loadSettings(),\n      ref.read(themeNotifierProvider.notifier).loadTheme(),\n    ]);\n  }\n}\n \n// 4. 智能快取管理\n@riverpod\nclass CacheManager extends _$CacheManager {\n  @override\n  Map&lt;String, CacheEntry&gt; build() {\n    return {};\n  }\n \n  T? get&lt;T&gt;(String key) {\n    final entry = state[key];\n    if (entry == null || entry.isExpired) {\n      return null;\n    }\n    return entry.value as T;\n  }\n \n  void set&lt;T&gt;(String key, T value, {Duration? ttl}) {\n    state = {\n      ...state,\n      key: CacheEntry(\n        value: value,\n        expiredAt: DateTime.now().add(ttl ?? Duration(minutes: 30)),\n      ),\n    };\n  }\n \n  void invalidate(String key) {\n    final newState = Map&lt;String, CacheEntry&gt;.from(state);\n    newState.remove(key);\n    state = newState;\n  }\n}\n🎨 UI 層的優雅實現\n響應式 Widget 設計\n// 5. UI 層 - 清晰的狀態消費\nclass UserProfilePage extends ConsumerWidget {\n  const UserProfilePage({super.key});\n \n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final userState = ref.watch(userNotifierProvider);\n    final appState = ref.watch(appStateNotifierProvider);\n \n    return Scaffold(\n      appBar: AppBar(\n        title: Text(&#039;個人資料&#039;),\n        actions: [\n          if (!appState.isOnline)\n            Icon(Icons.signal_wifi_off, color: Colors.red),\n        ],\n      ),\n      body: userState.when(\n        loading: () =&gt; _buildLoadingState(),\n        error: (error, stack) =&gt; _buildErrorState(error, ref),\n        data: (user) =&gt; _buildUserProfile(user, ref),\n      ),\n    );\n  }\n \n  Widget _buildLoadingState() {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          CircularProgressIndicator(),\n          SizedBox(height: 16),\n          Text(&#039;載入中...&#039;, style: TextStyle(color: Colors.grey)),\n        ],\n      ),\n    );\n  }\n \n  Widget _buildErrorState(Object error, WidgetRef ref) {\n    return Center(\n      child: Column(\n        mainAxisAlignment: MainAxisAlignment.center,\n        children: [\n          Icon(Icons.error_outline, size: 64, color: Colors.red),\n          SizedBox(height: 16),\n          Text(&#039;載入失敗&#039;, style: Theme.of(context).textTheme.headlineSmall),\n          SizedBox(height: 8),\n          Text(error.toString(), textAlign: TextAlign.center),\n          SizedBox(height: 16),\n          ElevatedButton.icon(\n            onPressed: () =&gt; ref.refresh(userNotifierProvider),\n            icon: Icon(Icons.refresh),\n            label: Text(&#039;重試&#039;),\n          ),\n        ],\n      ),\n    );\n  }\n \n  Widget _buildUserProfile(UserInfo user, WidgetRef ref) {\n    return RefreshIndicator(\n      onRefresh: () =&gt; ref.refresh(userNotifierProvider.future),\n      child: SingleChildScrollView(\n        physics: AlwaysScrollableScrollPhysics(),\n        padding: EdgeInsets.all(16),\n        child: Column(\n          children: [\n            _UserAvatar(user: user),\n            SizedBox(height: 24),\n            _UserInfoCard(user: user),\n            SizedBox(height: 16),\n            _UserStatsCard(user: user),\n            SizedBox(height: 16),\n            _UserActionButtons(user: user),\n          ],\n        ),\n      ),\n    );\n  }\n}\n可重用的狀態組件\n// 6. 可重用的狀態組件\nclass AsyncBuilder&lt;T&gt; extends ConsumerWidget {\n  const AsyncBuilder({\n    super.key,\n    required this.provider,\n    required this.builder,\n    this.loadingBuilder,\n    this.errorBuilder,\n  });\n \n  final ProviderListenable&lt;AsyncValue&lt;T&gt;&gt; provider;\n  final Widget Function(BuildContext context, T data) builder;\n  final Widget Function(BuildContext context)? loadingBuilder;\n  final Widget Function(BuildContext context, Object error)? errorBuilder;\n \n  @override\n  Widget build(BuildContext context, WidgetRef ref) {\n    final asyncValue = ref.watch(provider);\n \n    return asyncValue.when(\n      loading: () =&gt; loadingBuilder?.call(context) ??\n        Center(child: CircularProgressIndicator()),\n      error: (error, _) =&gt; errorBuilder?.call(context, error) ??\n        Center(child: Text(&#039;錯誤: $error&#039;)),\n      data: (data) =&gt; builder(context, data),\n    );\n  }\n}\n \n// 使用範例\nclass ProductList extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return AsyncBuilder&lt;List&lt;Product&gt;&gt;(\n      provider: productsProvider,\n      loadingBuilder: (context) =&gt; ProductListSkeleton(),\n      errorBuilder: (context, error) =&gt; ErrorRetryWidget(\n        error: error,\n        onRetry: () =&gt; context.refresh(productsProvider),\n      ),\n      builder: (context, products) {\n        return ListView.builder(\n          itemCount: products.length,\n          itemBuilder: (context, index) =&gt; ProductCard(\n            product: products[index],\n          ),\n        );\n      },\n    );\n  }\n}\n🧪 測試策略\nProvider 測試\n// 7. 可測試的狀態管理\nvoid main() {\n  group(&#039;UserNotifier 測試&#039;, () {\n    late ProviderContainer container;\n    late MockUserService mockUserService;\n \n    setUp(() {\n      mockUserService = MockUserService();\n      container = ProviderContainer(\n        overrides: [\n          userServiceProvider.overrideWithValue(mockUserService),\n        ],\n      );\n    });\n \n    tearDown(() {\n      container.dispose();\n    });\n \n    testWidgets(&#039;使用者資料載入成功&#039;, (tester) async {\n      // Arrange\n      final testUser = UserInfo(id: &#039;1&#039;, name: &#039;Test User&#039;);\n      when(() =&gt; mockUserService.getUser(&#039;1&#039;))\n          .thenAnswer((_) async =&gt; testUser);\n \n      // Act\n      await container\n          .read(userNotifierProvider.notifier)\n          .fetchUser(&#039;1&#039;);\n \n      // Assert\n      final state = container.read(userNotifierProvider);\n      expect(state.hasValue, true);\n      expect(state.value, testUser);\n    });\n \n    testWidgets(&#039;錯誤處理測試&#039;, (tester) async {\n      // Arrange\n      when(() =&gt; mockUserService.getUser(&#039;1&#039;))\n          .thenThrow(Exception(&#039;網路錯誤&#039;));\n \n      // Act\n      await container\n          .read(userNotifierProvider.notifier)\n          .fetchUser(&#039;1&#039;);\n \n      // Assert\n      final state = container.read(userNotifierProvider);\n      expect(state.hasError, true);\n      expect(state.error.toString(), contains(&#039;網路錯誤&#039;));\n    });\n  });\n}\nWidget 測試\n// 8. Widget 整合測試\nvoid main() {\n  group(&#039;UserProfilePage 測試&#039;, () {\n    testWidgets(&#039;載入狀態顯示&#039;, (tester) async {\n      await tester.pumpWidget(\n        ProviderScope(\n          overrides: [\n            userNotifierProvider.overrideWith(\n              () =&gt; AsyncValue&lt;UserInfo&gt;.loading(),\n            ),\n          ],\n          child: MaterialApp(\n            home: UserProfilePage(),\n          ),\n        ),\n      );\n \n      expect(find.byType(CircularProgressIndicator), findsOneWidget);\n      expect(find.text(&#039;載入中...&#039;), findsOneWidget);\n    });\n \n    testWidgets(&#039;使用者資料顯示&#039;, (tester) async {\n      final testUser = UserInfo(id: &#039;1&#039;, name: &#039;Test User&#039;);\n \n      await tester.pumpWidget(\n        ProviderScope(\n          overrides: [\n            userNotifierProvider.overrideWith(\n              () =&gt; AsyncValue.data(testUser),\n            ),\n          ],\n          child: MaterialApp(\n            home: UserProfilePage(),\n          ),\n        ),\n      );\n \n      expect(find.text(&#039;Test User&#039;), findsOneWidget);\n      expect(find.byType(CircularProgressIndicator), findsNothing);\n    });\n  });\n}\n📊 效能優化實踐\n智能重建策略\n// 9. 效能優化 - 精確的重建控制\n@riverpod\nclass OptimizedListNotifier extends _$OptimizedListNotifier {\n  @override\n  List&lt;ListItem&gt; build() {\n    return [];\n  }\n \n  void addItem(ListItem item) {\n    // 只有真正變化時才觸發重建\n    if (!state.contains(item)) {\n      state = [...state, item];\n    }\n  }\n \n  void updateItem(String id, ListItem updatedItem) {\n    final index = state.indexWhere((item) =&gt; item.id == id);\n    if (index != -1 &amp;&amp; state[index] != updatedItem) {\n      final newList = List&lt;ListItem&gt;.from(state);\n      newList[index] = updatedItem;\n      state = newList;\n    }\n  }\n \n  void removeItem(String id) {\n    state = state.where((item) =&gt; item.id != id).toList();\n  }\n}\n \n// 10. 記憶體優化 - 自動清理\n@riverpod\nclass ResourceManager extends _$ResourceManager {\n  Timer? _cleanupTimer;\n \n  @override\n  Map&lt;String, dynamic&gt; build() {\n    // 設定定期清理\n    _cleanupTimer = Timer.periodic(Duration(minutes: 5), (_) {\n      _performCleanup();\n    });\n \n    ref.onDispose(() {\n      _cleanupTimer?.cancel();\n    });\n \n    return {};\n  }\n \n  void _performCleanup() {\n    final now = DateTime.now();\n    final newState = Map&lt;String, dynamic&gt;.from(state);\n \n    newState.removeWhere((key, value) {\n      if (value is CacheEntry) {\n        return value.expiredAt.isBefore(now);\n      }\n      return false;\n    });\n \n    if (newState.length != state.length) {\n      state = newState;\n      print(&#039;清理了 ${state.length - newState.length} 個過期項目&#039;);\n    }\n  }\n}\n🎯 實際效果對比\n開發體驗提升\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指標setStateRiverpod改善幅度程式碼可讀性3/109/10🚀 200%測試覆蓋率30%85%🚀 183%狀態同步錯誤15/月2/月🚀 87%開發速度基準+60%🚀 60%維護成本基準-40%🚀 40%\n效能指標\n記憶體使用對比 (MB)\n    │\n200 ┤     ●●●●●●●●● (setState)\n    │   ●●●●●●●●●●●●●\n150 ┤ ●●●●●●●●●●●●●●●\n    │●●●●●●●●●●●●●●●●●\n100 ┤  ●●●●●●●●●●●●●  (Riverpod)\n    │    ●●●●●●●●●●\n 50 ┤      ●●●●●●\n    │        ●●●●\n  0 └────────────────────\n    0  20  40  60  80  100\n        應用使用時間 (分鐘)\n\n💡 最佳實踐總結\n設計原則\n\n單一職責：每個 Provider 只管理一種狀態\n不可變性：始終返回新的狀態物件\n可測試性：依賴注入 + Mock 支援\n效能優先：精確重建 + 智能快取\n\n常見陷阱避免\n// ❌ 避免：在 build 方法中執行副作用\n@riverpod\nclass BadNotifier extends _$BadNotifier {\n  @override\n  String build() {\n    // 不要在這裡執行網路請求！\n    apiService.getData().then((data) {\n      state = data; // 這會導致無限重建\n    });\n    return &#039;&#039;;\n  }\n}\n \n// ✅ 正確：使用專門的方法處理副作用\n@riverpod\nclass GoodNotifier extends _$GoodNotifier {\n  @override\n  AsyncValue&lt;String&gt; build() {\n    return const AsyncValue.loading();\n  }\n \n  Future&lt;void&gt; loadData() async {\n    state = const AsyncValue.loading();\n    try {\n      final data = await ref.read(apiServiceProvider).getData();\n      state = AsyncValue.data(data);\n    } catch (error, stackTrace) {\n      state = AsyncValue.error(error, stackTrace);\n    }\n  }\n}\n架構模式\ngraph TD\n    A[UI Layer] --&gt; B[Provider Layer]\n    B --&gt; C[Service Layer]\n    C --&gt; D[Repository Layer]\n    D --&gt; E[Data Source]\n\n    F[Testing] --&gt; B\n    F --&gt; C\n    F --&gt; D\n\n    G[Caching] --&gt; C\n    H[Logging] --&gt; C\n    I[Error Handling] --&gt; B\n\n🚀 下一步優化\n短期計劃 (本週)\n\n 實現 Provider 的熱重載支援\n 添加狀態變更的日誌系統\n 建立自動化測試流水線\n\n中期目標 (本月)\n\n 整合 Flutter Inspector 除錯\n 實現離線狀態同步\n 建立效能監控儀表板\n\n長期願景 (本季)\n\n 開發 Riverpod 開發者工具\n 建立狀態管理最佳實踐文檔\n 分享給 Flutter 社群\n\n\n💭 學習心得\n今日感悟\n\n“好的狀態管理不是讓程式碼變得複雜，而是讓複雜的業務邏輯變得簡單。Riverpod 不只是工具，更是一種思維方式。“\n\n技術洞察\n\n依賴注入 ≠ 複雜度增加，而是責任明確化\n不可變狀態 = 可預測性 + 易除錯性\n響應式編程 = 資料流驅動 UI 更新\n\n知識連結\n\n與 React Hooks 模式 的相似性\n可應用到 AI 工具套件 的狀態管理\n為 遊戲系統 提供狀態管理參考\n\n\n⏰ 投入時間：4小時 | 🎯 成果：完整狀態管理架構 | 📚 學習：Riverpod 進階模式\nFlutter Dart StateManagement Riverpod MobileDevelopment Architecture"},"daily-code/2025-06-27-chrome-extension-memory":{"slug":"daily-code/2025-06-27-chrome-extension-memory","filePath":"daily-code/2025-06-27-chrome-extension-memory.md","title":"Chrome 擴展記憶體管理","links":["daily-code/2025-06-28-ai-benchmark-optimization","projects/browser-extension-ecosystem","projects/ai-development-suite","tags/ChromeExtension","tags/MemoryManagement","tags/Performance","tags/JavaScript","tags/WebExtensions"],"tags":["Chrome-Extension","Memory-Management","JavaScript","Performance","ChromeExtension","MemoryManagement","WebExtensions"],"content":"🧩 Chrome 擴展記憶體管理\n\n今日焦點：解決 test-ai-memory 專案中 Service Worker 記憶體限制問題\n\n🎯 問題發現\nService Worker 的記憶體困境\n在開發 AI 聊天擴展時，遇到了 Chrome Extension Manifest V3 的記憶體管理挑戰：\n// ❌ 問題代碼 - 記憶體洩漏\nclass BadMemoryManager {\n  constructor() {\n    this.chatHistory = [] // 無限制增長\n    this.cache = new Map() // 永不清理\n    this.eventListeners = [] // 沒有清理機制\n  }\n \n  addChatMessage(message) {\n    this.chatHistory.push({\n      ...message,\n      timestamp: Date.now(),\n      fullContext: this.getAllContext(), // 大物件重複存儲\n    })\n \n    // 沒有清理舊資料\n    this.updateUI()\n  }\n \n  cacheResponse(key, response) {\n    // 無 TTL，無大小限制\n    this.cache.set(key, {\n      data: response,\n      metadata: this.generateMetadata(response), // 額外開銷\n      timestamp: Date.now(),\n    })\n  }\n}\n核心問題：\n\n💾 無限制成長：聊天記錄和快取無限制累積\n⏰ Service Worker 休眠：內容會被清空，但沒有恢復機制\n🔄 重複計算：每次都重新生成相同的中介資料\n📡 事件監聽器洩漏：註冊但從未清理\n\n🚀 智能記憶體管理解決方案\n1. 分層儲存策略\n// ✅ 優化版本 - 分層記憶體管理\nclass IntelligentMemoryManager {\n  constructor() {\n    this.config = {\n      maxChatHistory: 100,\n      maxCacheSize: 50,\n      cacheTTL: 30 * 60 * 1000, // 30分鐘\n      compressionThreshold: 1000, // 1KB\n    }\n \n    // 分層儲存\n    this.memoryLayers = {\n      hot: new Map(), // 立即訪問 - 記憶體\n      warm: new Map(), // 近期訪問 - IndexedDB\n      cold: new Map(), // 歷史資料 - 壓縮儲存\n    }\n \n    this.initializeStorage()\n    this.startCleanupTimer()\n  }\n \n  async initializeStorage() {\n    // 初始化 IndexedDB\n    this.db = await this.openDatabase()\n \n    // 從持久化儲存恢復資料\n    await this.restoreFromPersistentStorage()\n \n    // 監聽 Service Worker 生命週期\n    this.setupLifecycleHandlers()\n  }\n \n  async addChatMessage(message) {\n    const optimizedMessage = this.optimizeMessage(message)\n \n    // 添加到熱層\n    const messageId = this.generateId()\n    this.memoryLayers.hot.set(messageId, optimizedMessage)\n \n    // 檢查是否需要降級到暖層\n    if (this.memoryLayers.hot.size &gt; this.config.maxChatHistory) {\n      await this.demoteToWarmLayer()\n    }\n \n    // 非同步持久化\n    this.persistMessage(messageId, optimizedMessage)\n \n    return messageId\n  }\n \n  optimizeMessage(message) {\n    return {\n      id: message.id,\n      content: message.content,\n      timestamp: message.timestamp,\n      // 移除冗餘資料，使用引用\n      contextRef: this.storeContext(message.context),\n      // 壓縮大型內容\n      compressedData: this.compress(message.largeData),\n    }\n  }\n}\n2. 智能快取策略\n// 基於 LRU + TTL 的智能快取\nclass SmartCache {\n  constructor(maxSize = 100, ttl = 30 * 60 * 1000) {\n    this.maxSize = maxSize\n    this.ttl = ttl\n    this.cache = new Map()\n    this.accessOrder = new Map() // 訪問順序追蹤\n \n    // 定期清理\n    setInterval(() =&gt; this.cleanup(), 5 * 60 * 1000)\n  }\n \n  set(key, value) {\n    const now = Date.now()\n \n    // 如果已存在，更新順序\n    if (this.cache.has(key)) {\n      this.cache.delete(key)\n      this.accessOrder.delete(key)\n    }\n \n    // 檢查大小限制\n    if (this.cache.size &gt;= this.maxSize) {\n      this.evictLRU()\n    }\n \n    // 添加新項目\n    const item = {\n      value: this.compressIfNeeded(value),\n      timestamp: now,\n      accessCount: 1,\n      size: this.calculateSize(value),\n    }\n \n    this.cache.set(key, item)\n    this.accessOrder.set(key, now)\n \n    // 記錄快取統計\n    this.updateStats(&quot;set&quot;, key)\n  }\n \n  get(key) {\n    const item = this.cache.get(key)\n \n    if (!item) {\n      this.updateStats(&quot;miss&quot;, key)\n      return null\n    }\n \n    // 檢查 TTL\n    if (Date.now() - item.timestamp &gt; this.ttl) {\n      this.cache.delete(key)\n      this.accessOrder.delete(key)\n      this.updateStats(&quot;expired&quot;, key)\n      return null\n    }\n \n    // 更新訪問紀錄\n    item.accessCount++\n    this.accessOrder.set(key, Date.now())\n \n    this.updateStats(&quot;hit&quot;, key)\n    return this.decompressIfNeeded(item.value)\n  }\n \n  evictLRU() {\n    // 找到最少使用的項目\n    const oldestKey = this.accessOrder.keys().next().value\n    if (oldestKey) {\n      this.cache.delete(oldestKey)\n      this.accessOrder.delete(oldestKey)\n      this.updateStats(&quot;evicted&quot;, oldestKey)\n    }\n  }\n \n  cleanup() {\n    const now = Date.now()\n    const expiredKeys = []\n \n    for (const [key, item] of this.cache) {\n      if (now - item.timestamp &gt; this.ttl) {\n        expiredKeys.push(key)\n      }\n    }\n \n    expiredKeys.forEach((key) =&gt; {\n      this.cache.delete(key)\n      this.accessOrder.delete(key)\n    })\n \n    console.log(`🧹 清理了 ${expiredKeys.length} 個過期項目`)\n  }\n \n  compressIfNeeded(value) {\n    const serialized = JSON.stringify(value)\n    if (serialized.length &gt; 1000) {\n      // 1KB 閾值\n      return this.compress(serialized)\n    }\n    return value\n  }\n \n  compress(data) {\n    // 使用 LZ-string 或類似的壓縮算法\n    return {\n      compressed: true,\n      data: this.lzCompress(data),\n      originalSize: data.length,\n    }\n  }\n \n  getStats() {\n    return {\n      size: this.cache.size,\n      hitRate: this.stats.hits / (this.stats.hits + this.stats.misses),\n      memoryUsage: this.calculateTotalSize(),\n      oldestItem: Math.min(...Array.from(this.accessOrder.values())),\n    }\n  }\n}\n3. Service Worker 生命週期管理\n// Service Worker 狀態管理\nclass ServiceWorkerStateManager {\n  constructor() {\n    this.isActive = false\n    this.pendingOperations = new Map()\n    this.stateVersion = 0\n \n    this.setupEventHandlers()\n  }\n \n  setupEventHandlers() {\n    // Service Worker 啟動\n    chrome.runtime.onStartup.addListener(() =&gt; {\n      this.handleStartup()\n    })\n \n    // Service Worker 安裝\n    chrome.runtime.onInstalled.addListener((details) =&gt; {\n      this.handleInstall(details)\n    })\n \n    // 監聽記憶體壓力\n    if (&quot;memory&quot; in performance) {\n      setInterval(() =&gt; {\n        this.checkMemoryPressure()\n      }, 30000) // 30秒檢查一次\n    }\n \n    // 預測性清理\n    this.schedulePreemptiveCleanup()\n  }\n \n  async handleStartup() {\n    console.log(&quot;🚀 Service Worker 啟動&quot;)\n \n    // 恢復關鍵狀態\n    await this.restoreState()\n \n    // 重新連接到微服務\n    await this.reconnectServices()\n \n    // 恢復中斷的操作\n    await this.resumePendingOperations()\n \n    this.isActive = true\n  }\n \n  async restoreState() {\n    try {\n      // 從 chrome.storage 恢復狀態\n      const stored = await chrome.storage.local.get([&quot;appState&quot;, &quot;userPrefs&quot;])\n \n      if (stored.appState) {\n        this.memoryManager.restoreFromSnapshot(stored.appState)\n        console.log(&quot;✅ 狀態恢復成功&quot;)\n      }\n \n      // 檢查版本兼容性\n      if (stored.appState !== this.stateVersion) {\n        await this.migrateState(stored.appState)\n      }\n    } catch (error) {\n      console.error(&quot;❌ 狀態恢復失敗:&quot;, error)\n      await this.initializeDefaultState()\n    }\n  }\n \n  async saveState() {\n    const snapshot = {\n      version: this.stateVersion,\n      timestamp: Date.now(),\n      criticalData: this.memoryManager.createSnapshot(),\n      userPreferences: this.getUserPreferences(),\n    }\n \n    // 分批儲存避免超過 chrome.storage 限制\n    await this.saveLargeObject(&quot;appState&quot;, snapshot)\n  }\n \n  async saveLargeObject(key, object) {\n    const serialized = JSON.stringify(object)\n    const chunks = this.chunkString(serialized, 7000) // Chrome 限制 8KB\n \n    const chunkKeys = chunks.map((chunk, index) =&gt; `${key}_chunk_${index}`)\n    const chunkData = {}\n \n    chunks.forEach((chunk, index) =&gt; {\n      chunkData[chunkKeys[index]] = chunk\n    })\n \n    chunkData[`${key}_meta`] = {\n      chunkCount: chunks.length,\n      totalSize: serialized.length,\n      timestamp: Date.now(),\n    }\n \n    await chrome.storage.local.set(chunkData)\n  }\n \n  checkMemoryPressure() {\n    if (&quot;memory&quot; in performance) {\n      const memory = performance.memory\n      const usage = memory.usedJSHeapSize / memory.jsHeapSizeLimit\n \n      console.log(`💾 記憶體使用率: ${(usage * 100).toFixed(1)}%`)\n \n      if (usage &gt; 0.8) {\n        // 80% 使用率警告\n        this.handleHighMemoryPressure()\n      } else if (usage &gt; 0.9) {\n        // 90% 使用率緊急處理\n        this.handleCriticalMemoryPressure()\n      }\n    }\n  }\n \n  handleHighMemoryPressure() {\n    console.log(&quot;⚠️  高記憶體壓力，開始優化&quot;)\n \n    // 清理非必要快取\n    this.memoryManager.clearColdCache()\n \n    // 壓縮暖層資料\n    this.memoryManager.compressWarmLayer()\n \n    // 觸發垃圾回收（如果可能）\n    if (global.gc) {\n      global.gc()\n    }\n  }\n \n  handleCriticalMemoryPressure() {\n    console.log(&quot;🚨 記憶體壓力過高，緊急清理&quot;)\n \n    // 保存關鍵狀態\n    this.saveState()\n \n    // 清理所有非必要資料\n    this.memoryManager.emergencyCleanup()\n \n    // 通知用戶（可選）\n    this.notifyMemoryPressure()\n  }\n}\n📊 效能優化結果\n記憶體使用對比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指標優化前優化後改善幅度峰值記憶體45MB18MB🚀 60%平均記憶體28MB12MB🚀 57%載入時間2.3s1.1s🚀 52%回應速度580ms180ms🚀 69%快取命中率45%87%🚀 93%\n記憶體使用趨勢圖\n記憶體使用量 (MB)\n    │\n 50 ┤     ●●●●●●●●●●● (優化前)\n    │   ●●●●●●●●●●●●●●●\n 40 ┤ ●●●●●●●●●●●●●●●●●●\n    │●●●●●●●●●●●●●●●●●●●●\n 30 ┤●●●●●●●●●●●●●●●●●●●●●\n    │●●●●●●●●●●●●●●●●●●●●●●\n 20 ┤  ●●●●●●●●●●●●●  (優化後)\n    │    ●●●●●●●●●●●\n 10 ┤      ●●●●●●●●\n    │        ●●●●●●\n  0 └────────────────────────\n    0  20  40  60  80  100 120\n          使用時間 (分鐘)\n\n🔧 實用工具函數\n記憶體監控工具\n// 記憶體監控和診斷工具\nclass MemoryDiagnostics {\n  constructor() {\n    this.metrics = {\n      allocations: [],\n      deallocations: [],\n      peakUsage: 0,\n      leakSuspects: new Set(),\n    }\n \n    this.startMonitoring()\n  }\n \n  startMonitoring() {\n    // 定期記錄記憶體使用\n    setInterval(() =&gt; {\n      this.recordMemorySnapshot()\n    }, 10000) // 10秒間隔\n \n    // 監控物件創建\n    this.monitorObjectCreation()\n  }\n \n  recordMemorySnapshot() {\n    if (&quot;memory&quot; in performance) {\n      const memory = performance.memory\n      const snapshot = {\n        timestamp: Date.now(),\n        used: memory.usedJSHeapSize,\n        total: memory.totalJSHeapSize,\n        limit: memory.jsHeapSizeLimit,\n      }\n \n      this.metrics.allocations.push(snapshot)\n \n      // 保持最近 100 個記錄\n      if (this.metrics.allocations.length &gt; 100) {\n        this.metrics.allocations.shift()\n      }\n \n      // 更新峰值\n      if (snapshot.used &gt; this.metrics.peakUsage) {\n        this.metrics.peakUsage = snapshot.used\n      }\n    }\n  }\n \n  detectMemoryLeaks() {\n    const recent = this.metrics.allocations.slice(-10)\n    if (recent.length &lt; 10) return false\n \n    // 檢查記憶體是否持續增長\n    const trend = this.calculateTrend(recent.map((s) =&gt; s.used))\n \n    if (trend &gt; 1024 * 1024) {\n      // 1MB/snapshot 增長視為可疑\n      console.warn(&quot;🚨 偵測到可能的記憶體洩漏&quot;)\n      return true\n    }\n \n    return false\n  }\n \n  generateReport() {\n    const current = performance.memory\n    const efficiency = (current.usedJSHeapSize / current.totalJSHeapSize) * 100\n \n    return {\n      current: {\n        used: this.formatBytes(current.usedJSHeapSize),\n        total: this.formatBytes(current.totalJSHeapSize),\n        efficiency: `${efficiency.toFixed(1)}%`,\n      },\n      peak: this.formatBytes(this.metrics.peakUsage),\n      trend: this.calculateMemoryTrend(),\n      recommendations: this.generateRecommendations(),\n    }\n  }\n \n  generateRecommendations() {\n    const recommendations = []\n    const report = this.generateReport()\n \n    if (parseFloat(report.current.efficiency) &gt; 80) {\n      recommendations.push({\n        priority: &quot;high&quot;,\n        message: &quot;記憶體使用效率過高，建議清理快取&quot;,\n      })\n    }\n \n    if (this.detectMemoryLeaks()) {\n      recommendations.push({\n        priority: &quot;critical&quot;,\n        message: &quot;偵測到記憶體洩漏，需要檢查事件監聽器和引用&quot;,\n      })\n    }\n \n    return recommendations\n  }\n \n  formatBytes(bytes) {\n    const sizes = [&quot;Bytes&quot;, &quot;KB&quot;, &quot;MB&quot;, &quot;GB&quot;]\n    if (bytes === 0) return &quot;0 Bytes&quot;\n    const i = Math.floor(Math.log(bytes) / Math.log(1024))\n    return Math.round((bytes / Math.pow(1024, i)) * 100) / 100 + &quot; &quot; + sizes[i]\n  }\n}\n自動化清理系統\n// 自動化記憶體清理系統\nclass AutoCleanupSystem {\n  constructor() {\n    this.cleanupTasks = new Map()\n    this.cleanupSchedule = []\n \n    this.registerDefaultTasks()\n    this.startScheduler()\n  }\n \n  registerCleanupTask(name, task, schedule) {\n    this.cleanupTasks.set(name, {\n      execute: task,\n      schedule: schedule,\n      lastRun: 0,\n      runCount: 0,\n    })\n  }\n \n  registerDefaultTasks() {\n    // 快取清理\n    this.registerCleanupTask(\n      &quot;cache_cleanup&quot;,\n      () =&gt; {\n        return this.memoryManager.cleanupExpiredCache()\n      },\n      { interval: 5 * 60 * 1000 },\n    ) // 5分鐘\n \n    // 聊天記錄整理\n    this.registerCleanupTask(\n      &quot;chat_archive&quot;,\n      () =&gt; {\n        return this.memoryManager.archiveOldChats()\n      },\n      { interval: 30 * 60 * 1000 },\n    ) // 30分鐘\n \n    // 事件監聽器檢查\n    this.registerCleanupTask(\n      &quot;listener_audit&quot;,\n      () =&gt; {\n        return this.auditEventListeners()\n      },\n      { interval: 60 * 60 * 1000 },\n    ) // 1小時\n  }\n \n  async startScheduler() {\n    setInterval(async () =&gt; {\n      const now = Date.now()\n \n      for (const [name, task] of this.cleanupTasks) {\n        if (now - task.lastRun &gt;= task.schedule.interval) {\n          try {\n            console.log(`🧹 執行清理任務: ${name}`)\n            await task.execute()\n            task.lastRun = now\n            task.runCount++\n          } catch (error) {\n            console.error(`清理任務失敗 ${name}:`, error)\n          }\n        }\n      }\n    }, 60000) // 每分鐘檢查一次\n  }\n \n  async emergencyCleanup() {\n    console.log(&quot;🚨 執行緊急清理&quot;)\n \n    const emergencyTasks = [&quot;cache_cleanup&quot;, &quot;chat_archive&quot;, &quot;listener_audit&quot;]\n \n    for (const taskName of emergencyTasks) {\n      const task = this.cleanupTasks.get(taskName)\n      if (task) {\n        try {\n          await task.execute()\n          console.log(`✅ 緊急清理完成: ${taskName}`)\n        } catch (error) {\n          console.error(`❌ 緊急清理失敗 ${taskName}:`, error)\n        }\n      }\n    }\n  }\n}\n🎯 最佳實踐總結\nChrome 擴展記憶體管理原則\n\n分層儲存：熱/暖/冷三層架構，根據訪問頻率管理資料\n智能快取：LRU + TTL 結合，自動清理過期內容\n壓縮優先：大於 1KB 的資料自動壓縮\n生命週期感知：適應 Service Worker 的休眠/喚醒週期\n預防性清理：基於記憶體壓力的主動清理\n\n常見陷阱避免\n// ❌ 避免：全域變數累積\nwindow.globalCache = window.globalCache || {}\n// 這會導致記憶體洩漏\n \n// ✅ 正確：使用管理器模式\nconst cacheManager = new CacheManager({ maxSize: 100 })\n \n// ❌ 避免：事件監聽器忘記移除\ndocument.addEventListener(&quot;click&quot;, handler)\n// Service Worker 重啟時會重複註冊\n \n// ✅ 正確：清理機制\nclass EventManager {\n  constructor() {\n    this.listeners = new Set()\n  }\n \n  addEventListener(target, event, handler) {\n    target.addEventListener(event, handler)\n    this.listeners.add({ target, event, handler })\n  }\n \n  cleanup() {\n    this.listeners.forEach(({ target, event, handler }) =&gt; {\n      target.removeEventListener(event, handler)\n    })\n    this.listeners.clear()\n  }\n}\n監控指標\n\n記憶體使用率 &lt; 80%\n快取命中率 &gt; 85%\n清理頻率 每 5-30 分鐘\nService Worker 重啟時間 &lt; 2 秒\n\n🚀 下一步優化\n短期目標 (本週)\n\n 實現 WebAssembly 壓縮算法\n 添加視覺化記憶體監控面板\n 整合到 CI/CD 的記憶體測試\n\n中期目標 (本月)\n\n 開發記憶體洩漏檢測工具\n 建立效能基準測試套件\n 發布記憶體管理最佳實踐文檔\n\n長期願景 (本季)\n\n 開源 Chrome 擴展記憶體管理庫\n 建立開發者工具生態系統\n 撰寫效能優化指南\n\n\n💭 學習心得\n今日感悟\n\n“記憶體管理不是技術細節，而是用戶體驗的基礎。每一個字節都關乎響應速度和穩定性。“\n\n技術洞察\n\nService Worker ≠ 傳統網頁：需要適應休眠/喚醒的生命週期\n記憶體限制是機會：迫使我們寫出更高效的程式碼\n監控驅動優化：沒有測量就沒有改進\n\n知識連結\n\n與 AI 基準測試優化 的記憶體池技術相通\n可應用到 瀏覽器擴展生態系 的其他組件\n為 AI 工具套件 提供前端優化參考\n\n\n⏰ 投入時間：6小時 | 🎯 成果：記憶體使用減少 60% | 📚 學習：Service Worker 生命週期管理\nChromeExtension MemoryManagement Performance JavaScript WebExtensions"},"daily-code/2025-06-28-ai-benchmark-optimization":{"slug":"daily-code/2025-06-28-ai-benchmark-optimization","filePath":"daily-code/2025-06-28-ai-benchmark-optimization.md","title":"AI 基準測試優化心得","links":["daily-code/2025-06-25-microservice-optimization","projects/ai-development-suite","projects/game-system-evolution","tags/AI","tags/Python","tags/PerformanceOptimization","tags/AsyncProgramming","tags/GPU"],"tags":["AI","基準測試","Python","效能優化","學習筆記","PerformanceOptimization","AsyncProgramming","GPU"],"content":"🚀 AI 基準測試優化心得\n\n今日重點：優化 test-ai-benchmark 專案效能，實現 30% 提升\n\n💡 核心發現\n問題診斷\n在進行 AI 模型基準測試時，發現主要瓶頸來自：\n# ❌ 原始版本 - 效能瓶頸\ndef benchmark_model(model, test_data):\n    results = []\n    for batch in test_data:\n        start_time = time.time()\n        prediction = model.predict(batch)  # 同步執行\n        end_time = time.time()\n        results.append({\n            &#039;prediction&#039;: prediction,\n            &#039;latency&#039;: end_time - start_time\n        })\n    return results\n主要問題：\n\n🐌 同步執行，無法充分利用 GPU\n📊 重複的時間測量開銷\n💾 記憶體使用效率低\n\n優化策略\n1. 批次處理優化\n# ✅ 優化版本 - 批次非同步處理\nimport asyncio\nimport torch\nfrom concurrent.futures import ThreadPoolExecutor\n \nclass OptimizedBenchmark:\n    def __init__(self, model, batch_size=32):\n        self.model = model\n        self.batch_size = batch_size\n        self.device = torch.device(&#039;cuda&#039; if torch.cuda.is_available() else &#039;cpu&#039;)\n \n    async def benchmark_async(self, test_data):\n        &quot;&quot;&quot;非同步批次基準測試&quot;&quot;&quot;\n        batches = self._create_batches(test_data)\n \n        with ThreadPoolExecutor(max_workers=4) as executor:\n            tasks = []\n            for batch in batches:\n                task = asyncio.create_task(\n                    self._process_batch_async(batch, executor)\n                )\n                tasks.append(task)\n \n            results = await asyncio.gather(*tasks)\n            return self._aggregate_results(results)\n \n    async def _process_batch_async(self, batch, executor):\n        &quot;&quot;&quot;異步處理單一批次&quot;&quot;&quot;\n        loop = asyncio.get_event_loop()\n \n        # 在執行緒池中執行 GPU 推理\n        start_time = time.perf_counter()\n        prediction = await loop.run_in_executor(\n            executor,\n            self._gpu_inference,\n            batch\n        )\n        end_time = time.perf_counter()\n \n        return {\n            &#039;batch_size&#039;: len(batch),\n            &#039;latency&#039;: end_time - start_time,\n            &#039;throughput&#039;: len(batch) / (end_time - start_time),\n            &#039;prediction&#039;: prediction\n        }\n2. 記憶體池管理\nclass MemoryPool:\n    &quot;&quot;&quot;記憶體池管理，避免頻繁分配/釋放&quot;&quot;&quot;\n \n    def __init__(self, pool_size=1000):\n        self.pool = []\n        self.pool_size = pool_size\n        self._init_pool()\n \n    def _init_pool(self):\n        &quot;&quot;&quot;預分配記憶體池&quot;&quot;&quot;\n        for _ in range(self.pool_size):\n            self.pool.append(torch.zeros(32, 512, device=self.device))\n \n    def get_tensor(self, shape):\n        &quot;&quot;&quot;從池中獲取張量&quot;&quot;&quot;\n        if self.pool and self.pool[-1].shape == shape:\n            return self.pool.pop()\n        return torch.zeros(shape, device=self.device)\n \n    def return_tensor(self, tensor):\n        &quot;&quot;&quot;歸還張量到池中&quot;&quot;&quot;\n        if len(self.pool) &lt; self.pool_size:\n            tensor.zero_()  # 清零重用\n            self.pool.append(tensor)\n3. 智能分析器\nclass PerformanceAnalyzer:\n    &quot;&quot;&quot;效能分析工具&quot;&quot;&quot;\n \n    def __init__(self):\n        self.metrics = {\n            &#039;latency_p50&#039;: [],\n            &#039;latency_p95&#039;: [],\n            &#039;latency_p99&#039;: [],\n            &#039;throughput&#039;: [],\n            &#039;memory_usage&#039;: [],\n            &#039;gpu_utilization&#039;: []\n        }\n \n    def analyze(self, results):\n        &quot;&quot;&quot;深度效能分析&quot;&quot;&quot;\n        latencies = [r[&#039;latency&#039;] for r in results]\n \n        analysis = {\n            &#039;summary&#039;: {\n                &#039;total_samples&#039;: len(results),\n                &#039;avg_latency&#039;: np.mean(latencies),\n                &#039;p50_latency&#039;: np.percentile(latencies, 50),\n                &#039;p95_latency&#039;: np.percentile(latencies, 95),\n                &#039;p99_latency&#039;: np.percentile(latencies, 99),\n                &#039;total_throughput&#039;: sum(r[&#039;throughput&#039;] for r in results)\n            },\n            &#039;bottlenecks&#039;: self._identify_bottlenecks(results),\n            &#039;recommendations&#039;: self._generate_recommendations(results)\n        }\n \n        return analysis\n \n    def _identify_bottlenecks(self, results):\n        &quot;&quot;&quot;識別效能瓶頸&quot;&quot;&quot;\n        bottlenecks = []\n \n        # 檢查 GPU 利用率\n        if self._get_gpu_utilization() &lt; 80:\n            bottlenecks.append({\n                &#039;type&#039;: &#039;GPU_UNDERUTILIZED&#039;,\n                &#039;severity&#039;: &#039;HIGH&#039;,\n                &#039;description&#039;: &#039;GPU 利用率低於 80%，考慮增加批次大小&#039;\n            })\n \n        # 檢查記憶體使用\n        memory_efficiency = self._calculate_memory_efficiency()\n        if memory_efficiency &lt; 0.7:\n            bottlenecks.append({\n                &#039;type&#039;: &#039;MEMORY_INEFFICIENT&#039;,\n                &#039;severity&#039;: &#039;MEDIUM&#039;,\n                &#039;description&#039;: f&#039;記憶體效率僅 {memory_efficiency:.1%}，建議優化資料載入&#039;\n            })\n \n        return bottlenecks\n📊 實測結果\n效能對比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指標優化前優化後提升幅度平均延遲145ms98ms🚀 32.4%P95 延遲230ms156ms🚀 32.2%吞吐量68 req/s102 req/s🚀 50.0%記憶體使用2.1GB1.4GB🚀 33.3%GPU 利用率65%89%🚀 36.9%\n效能曲線圖\n延遲分佈 (ms)\n    │\n200 ┤     ●●●\n    │   ●●●●●●●\n150 ┤ ●●●●●●●●●●● (優化前)\n    │●●●●●●●●●●●●●\n100 ┤  ●●●●●●●●●●  (優化後)\n    │    ●●●●●●\n 50 ┤      ●●\n    │        ●\n  0 └────────────────────\n    0  20  40  60  80  100\n         請求數量 (%)\n\n🎯 關鍵學習\n第一性原理思考\n\n問題本質：不是算法慢，而是 I/O 和記憶體管理低效\n解決策略：異步 + 批次 + 池化管理\n測量驅動：先測量，再優化，持續驗證\n\n架構設計原則\ngraph TD\n    A[資料輸入] --&gt; B[批次聚合]\n    B --&gt; C[異步處理池]\n    C --&gt; D[GPU 推理]\n    D --&gt; E[結果聚合]\n    E --&gt; F[效能分析]\n\n    G[記憶體池] --&gt; C\n    H[效能監控] --&gt; F\n\n可重用的設計模式\n\nPool Pattern：預分配資源池，避免動態分配\nAsync Batch Pattern：異步批次處理，提升並發\nMonitor Pattern：持續監控，識別瓶頸\n\n🔧 實用代碼片段\n快速基準測試器\n# 一行代碼基準測試\n@contextmanager\ndef benchmark_context(name=&quot;operation&quot;):\n    start = time.perf_counter()\n    yield\n    end = time.perf_counter()\n    print(f&quot;⏱️  {name}: {(end-start)*1000:.2f}ms&quot;)\n \n# 使用範例\nwith benchmark_context(&quot;AI推理&quot;):\n    result = model.predict(data)\nGPU 記憶體監控\ndef monitor_gpu_memory():\n    if torch.cuda.is_available():\n        allocated = torch.cuda.memory_allocated() / 1024**3\n        cached = torch.cuda.memory_reserved() / 1024**3\n        print(f&quot;🎮 GPU 記憶體: {allocated:.2f}GB 已用 / {cached:.2f}GB 快取&quot;)\n🚀 下一步行動\n短期目標 (本週)\n\n 整合 TensorRT 加速推理\n 實現自動批次大小調優\n 添加分散式基準測試支援\n\n中期目標 (本月)\n\n 建立基準測試資料庫\n 開發視覺化儀表板\n 整合 MLOps 流水線\n\n長期願景 (本季)\n\n 開源基準測試框架\n 建立社群標準\n 撰寫技術白皮書\n\n\n💭 思考筆記\n今日感悟\n\n“效能優化不是猜測遊戲，而是基於數據的科學。每一次優化都要先測量，再假設，然後驗證。“\n\n技術債務\n\n目前的異步實現還可以進一步優化\n需要更完善的錯誤處理機制\n考慮添加配置檔案支援\n\n知識連結\n\n與 微服務優化 的經驗可以結合\n可應用到 AI 開發工具套件 中\n為 遊戲系統 提供效能監控思路\n\n\n⏰ 耗時：3小時 | 🎯 成果：30% 效能提升 | 📝 學習：異步批次處理模式\nAI Python PerformanceOptimization AsyncProgramming GPU"},"daily-code/2025-07-05-git-mcp-analyzer":{"slug":"daily-code/2025-07-05-git-mcp-analyzer","filePath":"daily-code/2025-07-05-git-mcp-analyzer.md","title":"Git MCP 分析器最佳實踐","links":["daily-code/2025-06-26-flutter-state-management","projects/ai-development-suite","component/mcp-development-template","tags/MCP","tags/Git","tags/SystemAnalysis","tags/AutomationTools","tags/Claude","tags/ToolDevelopment","tags/ProjectAnalysis"],"tags":["MCP","Git","系統分析","自動化工具","Claude","工具開發","SystemAnalysis","AutomationTools","ToolDevelopment","ProjectAnalysis"],"content":"🛠️ Git MCP 分析器最佳實踐\n\n今日目標：建立 SA 工作流程專用的 Git 專案分析工具，從突發想法到完整實現的技術探索\n\n🎯 問題背景\n從手動分析到自動化的痛點\n在撰寫技術文件時，經常面對的重複性工作：\n# ❌ 傳統手動分析方式的問題\ngit log --oneline | head -20     # 看個大概\ngit log --stat                   # 檢查檔案變更\ngit log --author=&quot;user&quot;          # 查看作者貢獻\n# 然後手動整理時間軸...\n# 手動分析技術決策...\n# 手動識別開發階段...\n主要痛點：\n\n🕐 時間耗費：每次回顧專案都要重複相同的 git 操作\n🔍 資訊分散：commit、時間、技術點分散在不同命令中\n📊 缺乏洞察：難以從 commit 歷史中自動提取技術洞察\n🔄 重複勞動：每個專案都要做類似的分析工作\n📝 文件轉換：從 git 資訊到技術文章需要大量手工整理\n\n🚀 MCP 解決方案\n核心設計理念\n// ✅ MCP Git 分析器 - 自動化專案理解\nclass GitMCPAnalyzer {\n  constructor() {\n    // 1. 工具集設計 - 功能明確分離\n    this.tools = {\n      git_extract_timeline: this.extractTimeline,     // 時間軸提取\n      git_analyze_phases: this.analyzePhases,         // 階段分析\n      git_extract_insights: this.extractInsights,     // 洞察提取\n      git_current_status: this.getCurrentStatus,      // 狀態監控\n      git_commit_analysis: this.analyzeCommit         // 深度分析\n    };\n  }\n \n  // 2. 時間軸分析 - 結構化歷程\n  async extractTimeline(projectPath, options = {}) {\n    const { maxCommits = 50, dateRange = null } = options;\n    \n    try {\n      const git = simpleGit(projectPath);\n      const log = await git.log({\n        maxCount: maxCommits,\n        from: dateRange?.from,\n        to: dateRange?.to\n      });\n \n      return {\n        summary: this.generateTimelineSummary(log),\n        commits: this.formatCommits(log.all),\n        insights: this.extractTimelineInsights(log.all)\n      };\n    } catch (error) {\n      return this.handleError(&#039;時間軸分析失敗&#039;, error);\n    }\n  }\n \n  // 3. 階段檢測 - 智能分類\n  async analyzePhases(projectPath) {\n    const commits = await this.getCommits(projectPath);\n    \n    const phases = this.detectPhases(commits);\n    return {\n      phases: phases.map(phase =&gt; ({\n        name: phase.name,\n        period: phase.period,\n        keyCommits: phase.keyCommits,\n        characteristics: phase.characteristics\n      })),\n      currentPhase: this.getCurrentPhase(phases),\n      recommendations: this.generatePhaseRecommendations(phases)\n    };\n  }\n \n  // 4. 洞察提取 - 技術決策分析\n  async extractInsights(projectPath, keywords = []) {\n    const commits = await this.getCommits(projectPath);\n    \n    return {\n      technicalDecisions: this.identifyTechnicalDecisions(commits),\n      architectureEvolution: this.trackArchitectureChanges(commits),\n      learningPoints: this.extractLearningPoints(commits, keywords),\n      riskIndicators: this.identifyRisks(commits)\n    };\n  }\n}\n安全與權限設計\n// 5. 安全機制 - 唯讀操作保證\nclass SecurityManager {\n  constructor() {\n    // 僅允許安全的 Git 讀取操作\n    this.allowedCommands = [\n      &#039;status&#039;, &#039;log&#039;, &#039;show&#039;, &#039;diff&#039;, &#039;branch&#039;, &#039;remote&#039;\n    ];\n    \n    this.forbiddenCommands = [\n      &#039;commit&#039;, &#039;push&#039;, &#039;pull&#039;, &#039;merge&#039;, &#039;rebase&#039;, &#039;reset&#039;\n    ];\n  }\n \n  validateCommand(command) {\n    if (this.forbiddenCommands.includes(command)) {\n      throw new Error(`禁止的操作: ${command}`);\n    }\n    return this.allowedCommands.includes(command);\n  }\n \n  validatePath(projectPath) {\n    // 防止路徑注入攻擊\n    const normalizedPath = path.resolve(projectPath);\n    if (!fs.existsSync(path.join(normalizedPath, &#039;.git&#039;))) {\n      throw new Error(&#039;無效的 Git 專案路徑&#039;);\n    }\n    return normalizedPath;\n  }\n \n  filterSensitiveContent(content) {\n    // 過濾敏感資訊\n    const sensitivePatterns = [\n      /password|token|key|secret/gi,\n      /api[_-]?key/gi,\n      /private[_-]?key/gi\n    ];\n    \n    return sensitivePatterns.reduce((filtered, pattern) =&gt; {\n      return filtered.replace(pattern, &#039;[FILTERED]&#039;);\n    }, content);\n  }\n}\n🎨 實作架構設計\nMCP Server 標準結構\n// 6. MCP Server 實現 - 標準模式\nclass GitAnalyzerMCPServer {\n  constructor() {\n    this.server = new Server({\n      name: &#039;git-analyzer&#039;,\n      version: &#039;1.0.0&#039;\n    }, {\n      capabilities: {\n        tools: {}\n      }\n    });\n \n    this.setupTools();\n    this.setupErrorHandling();\n  }\n \n  setupTools() {\n    // 工具註冊標準模式\n    const tools = [\n      {\n        name: &#039;git_extract_timeline&#039;,\n        description: &#039;提取 Git 專案開發時間軸&#039;,\n        inputSchema: {\n          type: &#039;object&#039;,\n          properties: {\n            projectPath: { type: &#039;string&#039;, description: &#039;專案路徑&#039; },\n            maxCommits: { type: &#039;number&#039;, default: 50 },\n            dateRange: { \n              type: &#039;object&#039;,\n              properties: {\n                from: { type: &#039;string&#039; },\n                to: { type: &#039;string&#039; }\n              }\n            }\n          },\n          required: [&#039;projectPath&#039;]\n        }\n      }\n      // ... 其他工具定義\n    ];\n \n    tools.forEach(tool =&gt; {\n      this.server.setRequestHandler(ListToolsRequestSchema, () =&gt; ({\n        tools: tools\n      }));\n    });\n  }\n \n  setupErrorHandling() {\n    // 統一錯誤處理\n    this.server.onerror = (error) =&gt; {\n      console.error(&#039;[MCP Server Error]:&#039;, error);\n    };\n  }\n}\n分析演算法核心\n// 7. 核心演算法 - 階段檢測\nclass PhaseDetector {\n  detectPhases(commits) {\n    const phases = [];\n    let currentPhase = null;\n    \n    for (const commit of commits) {\n      const commitType = this.classifyCommit(commit);\n      \n      if (!currentPhase || this.shouldStartNewPhase(currentPhase, commitType)) {\n        currentPhase = this.createNewPhase(commitType, commit);\n        phases.push(currentPhase);\n      } else {\n        currentPhase.commits.push(commit);\n        this.updatePhaseCharacteristics(currentPhase, commit);\n      }\n    }\n    \n    return this.refinePhases(phases);\n  }\n \n  classifyCommit(commit) {\n    const message = commit.message.toLowerCase();\n    \n    // 基於 commit message 的模式識別\n    if (this.matchesPattern(message, [&#039;initial&#039;, &#039;init&#039;, &#039;start&#039;])) {\n      return &#039;initialization&#039;;\n    }\n    \n    if (this.matchesPattern(message, [&#039;feat&#039;, &#039;feature&#039;, &#039;add&#039;])) {\n      return &#039;feature_development&#039;;\n    }\n    \n    if (this.matchesPattern(message, [&#039;fix&#039;, &#039;bug&#039;, &#039;patch&#039;])) {\n      return &#039;bug_fixing&#039;;\n    }\n    \n    if (this.matchesPattern(message, [&#039;refactor&#039;, &#039;cleanup&#039;, &#039;optimize&#039;])) {\n      return &#039;optimization&#039;;\n    }\n    \n    if (this.matchesPattern(message, [&#039;doc&#039;, &#039;readme&#039;, &#039;comment&#039;])) {\n      return &#039;documentation&#039;;\n    }\n    \n    return &#039;general_development&#039;;\n  }\n \n  // 智能洞察提取\n  extractTechnicalInsights(commits) {\n    const insights = {\n      architectureChoices: [],\n      performanceOptimizations: [],\n      securityMeasures: [],\n      testingStrategies: []\n    };\n \n    commits.forEach(commit =&gt; {\n      // 技術棧選擇洞察\n      if (this.indicatesArchitectureChange(commit)) {\n        insights.architectureChoices.push({\n          decision: this.extractArchitectureDecision(commit),\n          rationale: this.inferRationale(commit),\n          impact: this.assessImpact(commit)\n        });\n      }\n \n      // 效能優化洞察\n      if (this.indicatesPerformanceWork(commit)) {\n        insights.performanceOptimizations.push({\n          area: this.identifyPerformanceArea(commit),\n          method: this.extractOptimizationMethod(commit),\n          result: this.inferResult(commit)\n        });\n      }\n    });\n \n    return insights;\n  }\n}\n🧪 測試與驗證策略\n功能測試\n// 8. 測試策略 - 全面驗證\nclass GitAnalyzerTester {\n  async runTests() {\n    const testCases = [\n      this.testTimelineExtraction,\n      this.testPhaseDetection,\n      this.testInsightExtraction,\n      this.testErrorHandling,\n      this.testSecurityValidation\n    ];\n \n    const results = [];\n    for (const testCase of testCases) {\n      try {\n        const result = await testCase();\n        results.push({ test: testCase.name, status: &#039;PASS&#039;, result });\n      } catch (error) {\n        results.push({ test: testCase.name, status: &#039;FAIL&#039;, error: error.message });\n      }\n    }\n \n    return this.generateTestReport(results);\n  }\n \n  async testTimelineExtraction() {\n    // 測試時間軸提取功能\n    const analyzer = new GitAnalyzer();\n    const timeline = await analyzer.extractTimeline(&#039;./test-project&#039;);\n    \n    assert(timeline.commits.length &gt; 0, &#039;應該提取到 commits&#039;);\n    assert(timeline.summary, &#039;應該生成摘要&#039;);\n    assert(Array.isArray(timeline.insights), &#039;應該提取洞察&#039;);\n    \n    return timeline;\n  }\n \n  async testSecurityValidation() {\n    // 測試安全機制\n    const security = new SecurityManager();\n    \n    // 測試路徑驗證\n    assert.throws(() =&gt; security.validatePath(&#039;/invalid/path&#039;), &#039;應該拒絕無效路徑&#039;);\n    \n    // 測試內容過濾\n    const filtered = security.filterSensitiveContent(&#039;password=secret123&#039;);\n    assert(!filtered.includes(&#039;secret123&#039;), &#039;應該過濾敏感內容&#039;);\n    \n    return &#039;Security tests passed&#039;;\n  }\n}\n📊 效果對比\n開發效率提升\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n任務手動方式MCP 自動化效率提升專案歷程分析45分鐘3分鐘🚀 15倍技術決策識別30分鐘2分鐘🚀 15倍開發階段劃分20分鐘1分鐘🚀 20倍洞察提取與整理60分鐘5分鐘🚀 12倍技術文章素材準備90分鐘10分鐘🚀 9倍\n分析品質對比\n分析深度得分 (1-10)\n    │\n 10 ┤     ●●●●●●●●● (MCP 自動化)\n    │   ●●●●●●●●●●●\n  8 ┤ ●●●●●●●●●●●●●\n    │●●●●●●●●●●●●●●●\n  6 ┤  ●●●●●●●●●  (手動分析)\n    │    ●●●●●●●\n  4 ┤      ●●●●\n    │        ●●\n  2 └────────────────────\n    時間軸  階段  洞察  決策\n\n💡 核心學習點\nMCP 開發最佳實踐\n\n\n工具設計原則：\n\n單一職責明確\n參數彈性合理\n輸出結構標準化\n錯誤處理完整\n\n\n\n安全設計策略：\n\n唯讀操作保證\n路徑注入防護\n敏感資訊過濾\n權限最小化原則\n\n\n\n效能優化考量：\n\n增量分析支援\n結果快取機制\n大專案分頁處理\n記憶體使用控制\n\n\n\nGit 分析方法論\ngraph TD\n    A[Commit 歷史] --&gt; B[模式識別]\n    B --&gt; C[階段劃分]\n    C --&gt; D[洞察提取]\n    D --&gt; E[技術文件]\n    \n    F[安全過濾] --&gt; B\n    G[效能優化] --&gt; C\n    H[品質檢查] --&gt; D\n\n核心洞察：\n\nGit commit 不只是版本記錄，更是技術決策的時間軸\n模式識別可以自動化大部分的專案分析工作\n結構化的分析框架比隨意的資訊提取更有價值\n安全與效能考量是工具化的必要條件\n\n系統分析師工具需求\n透過實作確認 SA 工具的核心價值：\n\n快速專案理解：新接手專案時的快速上手\n技術決策追蹤：了解為什麼這樣設計\n風險識別預警：從歷史模式發現潛在問題\n知識萃取轉移：將經驗轉化為可分享的知識\n\n🔄 時間軸\n2025-07-05 09:00 計畫階段\n\n觸發想法：撰寫技術文章時需要大量手動分析 Git 歷程\n需求分析：確定自動化分析的核心價值\n技術選型：選擇 MCP + Node.js + simple-git 方案\n架構設計：確定 5 個核心工具的功能劃分\n\n2025-07-05 11:30 實作階段\n\n環境建立：建立 mcp-git-analyzer 專案結構\n核心開發：實現 5 個主要分析工具\n安全機制：加入唯讀保護和敏感資訊過濾\n測試驗證：建立獨立測試腳本確保功能正常\n\n2025-07-05 16:20 部署階段\n\npackage.json 配置：設定 bin entry point 支援 npx 啟動\nClaude Desktop 整合：準備 MCP 配置範例\n文件完善：撰寫 README 和使用說明\n\n2025-07-05 18:45 修復階段\n\n問題發現：Claude Desktop 啟動時出現 npm 404 錯誤\n原因分析：本地 package 未發布至 npm registry\n解決方案：採用 npm install -g . 全域安裝方式\n驗證確認：MCP 功能正常，Git 分析工具可用\n\n2025-07-05 20:15 優化階段\n\n效能測試：在不同大小的專案上驗證效能\n功能完善：加入更多分析維度和過濾選項\n使用者體驗：改善錯誤訊息和輸出格式\n\n🚀 下一步計劃\n短期優化（本週）\n\n 實際應用於 selfpagesource 專案分析\n 收集使用回饋並優化演算法\n 完善錯誤處理和邊界情況\n\n中期發展（本月）\n\n 增加視覺化輸出功能（時間軸圖表）\n 支援多專案比較分析\n 整合 GitHub API 獲取更多專案資訊\n 開發 Web 界面版本\n\n長期願景（本季）\n\n 建立 MCP 工具開發模板和最佳實踐\n 發展智能化分析（結合 AI 模型進行語義分析）\n 建立 MCP 工具生態系統\n\n💭 學習心得\n今日感悟\n\n“好的自動化工具不是取代思考，而是讓思考專注在更有價值的地方。MCP 讓我們從重複性的資料收集中解放，專注於洞察提取和價值創造。“\n\n技術洞察\n\nMCP 協議 = 工具標準化 + AI 整合的完美結合\nGit 分析 = 歷史資料 + 模式識別的實際應用\n自動化思維 = 發現重複 + 工具化 + 持續優化\n\n知識連結\n\n與 Flutter 狀態管理 的工具化思維相似\n可應用到 AI 工具套件 的專案分析\n為 MCP 開發模板 提供最佳實踐\n\n\n⏰ 投入時間：8小時 | 🎯 成果：MCP Git分析器完成 | 📚 學習：MCP開發完整流程\nMCP Git SystemAnalysis AutomationTools Claude ToolDevelopment ProjectAnalysis"},"daily-code/index":{"slug":"daily-code/index","filePath":"daily-code/index.md","title":"開發日記","links":["2025-07-05-git-mcp-analyzer-implementation","2025-07-05-mcp-git-analyzer-plan","daily-code/2025-06-28-ai-benchmark-optimization","daily-code/2025-06-27-chrome-extension-memory","daily-code/2025-06-26-flutter-state-management"],"tags":["開發日誌","自動化流程","時間管理"],"content":"開發日記\n\n透過MCP自動化工具，將日常開發活動轉換為結構化的時間分割內容\n\n功能定位\n核心價值\n\n開發軌跡記錄：以時間為主軸記錄每日開發活動\n經驗快速捕捉：即時記錄開發過程中的發現與問題解決\n知識自動整合：透過MCP工具自動整理並生成日報\n\n與其他模組的關係\ndaily-code → projects：日常經驗整合為深度分析\ndaily-code → component：頻繁模式提煉為可重用元件\ndaily-code → doc：操作經驗沉澱為標準化文件\n\nMCP自動化工作流程\n設計架構\n指定資料夾掃描 → commit項目識別 → 標題描述生成 → 自動commit → 日報整合\n\n實作策略\n\nclaude/gemini cli驅動：透過AI工具自動化處理\n資料夾監控：掃描指定目錄下的待commit項目\n智能生成：為每個變更自動產生合適的title與description\n批次處理：完成所有commit後整合為單日文件\n\n安全機制\n原始記錄層：完整技術細節（內部保留）\n處理過濾層：敏感內容標記（自動化檢查）\n發布展示層：安全內容輸出（對外可見）\n\n內容組織策略\n命名規範\n\n檔案格式：YYYY-MM-DD-主題關鍵字.md\n標題結構：日期 + 核心技術 + 主要成果\n標籤系統：技術棧 + 專案類別 + 學習類型\n\n文件結構標準\n---\ntitle: &quot;[日期] - [核心發現]&quot;\ndate: &quot;YYYY-MM-DD&quot;\ntags: [&quot;主要技術&quot;, &quot;專案分類&quot;, &quot;學習類型&quot;]\ndescription: &quot;核心發現的簡要描述&quot;\nsecurity_level: &quot;public|internal|confidential&quot;\n---\n \n## 開發背景\n[當日主要開發任務與目標]\n \n## 核心發現\n[技術發現或問題解決方案]\n \n## 實作要點\n[關鍵技術實作，已過濾敏感內容]\n \n## 效果驗證\n[量化結果或定性評估]\n \n## 經驗總結\n[可重用的經驗與原則]\n \n## 後續計劃\n[下一步行動或改進方向]\n \n#相關標籤\n現有記錄概覽\n2025年7月\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n日期主題技術棧安全等級狀態07-05Git MCP分析器實作完成Node.js, MCP, GitPublic已發布07-05MCP Git分析器規劃Python, MCPPublic已發布\n2025年6月\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n日期主題技術棧安全等級狀態06-28AI基準測試優化Python, AsyncIOPublic已發布06-27擴展記憶體管理JavaScript, WebExtPublic已發布06-26Flutter狀態管理Dart, RiverpodPublic已發布\n技術分布統計\nAI/ML技術        ████████     35%\nWeb開發          ███████      25%\n移動開發         ████         15%\n工具開發         ██████       25%\n\n自動化目標與進展\n當前狀態\n\n手動記錄階段：人工撰寫日常開發記錄\n標準化進行中：建立統一的文件格式與分類\n工具規劃中：設計MCP自動化工作流程\n\nMCP工具開發計劃\n\n第一階段：Git變更自動掃描工具\n第二階段：AI輔助的commit訊息生成\n第三階段：日報自動整合與發布系統\n第四階段：敏感內容自動檢測與過濾\n\n預期效果\n\n效率提升：減少90%的重複性文件工作\n品質標準化：統一的格式與品質標準\n安全保障：自動化的敏感內容過濾\n知識積累：結構化的開發經驗資料庫\n\n保密分級機制\nPublic級別\n\n技術學習心得\n開源工具使用經驗\n一般性問題解決方案\n公開可用的代碼片段\n\nInternal級別\n\n專案特定實作細節\n內部工具配置方法\n性能優化具體數據\n架構設計考量\n\nConfidential級別\n\n商業邏輯核心算法\n關鍵創新技術方案\n競爭優勢實作方法\n敏感業務數據\n\n質量控制機制\n自動化檢查\n\n敏感關鍵字過濾\n技術細節分級檢查\n格式標準驗證\n連結有效性確認\n\n人工審查\n\n內容價值評估\n保密等級確認\n技術準確性驗證\n知識關聯性檢查\n\n使用指南\n新增記錄流程\n\n開發活動完成：日常開發任務結束\nMCP工具掃描：自動識別變更與新增內容\nAI輔助生成：自動產生初版記錄\n人工審查確認：檢查內容準確性與安全性\n發布更新：推送至版本控制系統\n\n查詢與檢索\n\n時間檢索：按月份或日期範圍查找\n技術檢索：按技術標籤分類瀏覽\n專案檢索：按相關專案分組查看\n全文搜索：關鍵字快速定位\n\n未來發展規劃\n短期目標（1-3個月）\n\n完成MCP自動化工具開發\n建立完整的保密檢查機制\n標準化所有歷史記錄格式\n\n中期目標（3-6個月）\n\n實現完全自動化的記錄生成\n建立智能化的內容分類系統\n發展跨專案的知識關聯分析\n\n長期願景（6-12個月）\n\n形成個人化的知識管理標準\n建立可複製的開發經驗管理模式\n發展AI驅動的技術學習輔助系統\n\n\n核心價值：將日常開發活動轉化為可積累的知識資產，透過自動化工具提升效率，並確保敏感資訊的適當保護。\n下一步行動：完成MCP自動化工具的原型開發，驗證工作流程的可行性。\n維護責任：PekoraTech SA Team - Daily Operations\n更新頻率：每日自動更新\n最後審查：2025-07-05"},"doc/guides/content-naming-standards":{"slug":"doc/guides/content-naming-standards","filePath":"doc/guides/content-naming-standards.md","title":"內容命名與組織規範","links":[],"tags":[],"content":"📝 內容命名與組織規範\n🎯 設計原則\n路徑命名（英文）\n\n檔案路徑：英文小寫，使用連字符\n目錄結構：英文單詞，語義明確\nURL 友善：避免特殊字元，SEO 友善\n\n顯示標題（中文）\n\n標題層次：清晰的中文標題結構\n閱讀體驗：符合中文使用者習慣\n語意完整：表達完整的概念\n\n📁 目錄命名標準\n主要分類\ncontent/\n├── daily-code/          # 每日程式碼心得\n├── projects/            # 專案整合分析\n├── doc/                 # 技術文檔指南\n└── component/           # 可重用組件庫\n\n子分類範例\ndoc/\n├── guides/              # 操作指南\n├── os-control/          # 作業系統控制\n├── sop/                 # 標準作業程序\n└── reference/           # 參考資料\n\n📄 檔案命名規範\nDaily-Code 命名格式\nYYYY-MM-DD-[topic-keyword].md\n\n範例：\n- 2025-06-28-ai-benchmark-optimization.md\n- 2025-06-27-chrome-extension-memory.md\n- 2025-07-05-async-pattern-design.md\n\nProjects 命名格式\n[project-category]-[main-keyword].md\n\n範例：\n- browser-extension-ecosystem.md\n- ai-development-framework.md\n- microservice-architecture-design.md\n\nComponent 命名格式\n[component-type]-[function-name].md\n\n範例：\n- ui-ai-chat-widget.md\n- infra-extension-bridge.md\n- algo-performance-analyzer.md\n- integration-oauth-handler.md\n\nDoc 命名格式\n[category]-[specific-topic].md\n\n範例：\n- github-pages-deployment.md\n- windows-directory-mirroring.md\n- api-design-best-practices.md\n\n🏷️ 標籤系統設計\n技術領域標籤\n# 程式語言\nlanguages: [&quot;JavaScript&quot;, &quot;TypeScript&quot;, &quot;Python&quot;, &quot;Rust&quot;]\n \n# 技術框架\nframeworks: [&quot;React&quot;, &quot;FastAPI&quot;, &quot;Express&quot;, &quot;Quartz&quot;]\n \n# 領域分類\ndomains: [&quot;AI&quot;, &quot;WebDev&quot;, &quot;SystemAdmin&quot;, &quot;DevOps&quot;]\n \n# 難度等級\ndifficulty: [&quot;入門&quot;, &quot;中級&quot;, &quot;高級&quot;, &quot;專家&quot;]\n內容類型標籤\n# 內容形式\ncontent_types: [&quot;教學&quot;, &quot;心得&quot;, &quot;分析&quot;, &quot;工具&quot;, &quot;SOP&quot;]\n \n# 專案階段\nproject_phases: [&quot;規劃&quot;, &quot;開發&quot;, &quot;測試&quot;, &quot;部署&quot;, &quot;維護&quot;]\n \n# 學習深度\nlearning_depth: [&quot;概念&quot;, &quot;實作&quot;, &quot;優化&quot;, &quot;創新&quot;]\n📋 Frontmatter 標準\n基本結構\n---\ntitle: &quot;中文顯示標題&quot;\ndate: &quot;YYYY-MM-DD&quot;\ntags: [&quot;標籤1&quot;, &quot;標籤2&quot;, &quot;標籤3&quot;]\ndescription: &quot;簡潔的內容描述（1-2句話）&quot;\ndifficulty: &quot;難度等級&quot;\ncategory: &quot;內容分類&quot;\n---\nDaily-Code 特殊欄位\n---\ntitle: &quot;AI 基準測試優化心得&quot;\ndate: &quot;2025-06-28&quot;\ntags: [&quot;AI&quot;, &quot;效能優化&quot;, &quot;Python&quot;, &quot;學習筆記&quot;]\ndescription: &quot;深入探討 py-benchmark 專案的效能優化策略&quot;\ndifficulty: &quot;中級&quot;\ncategory: &quot;daily-code&quot;\nproject_source: &quot;test-ai-benchmark&quot;\ntime_spent: &quot;3小時&quot;\nachievement: &quot;30% 效能提升&quot;\n---\nProjects 特殊欄位\n---\ntitle: &quot;瀏覽器擴展生態系統建構&quot;\ndate: &quot;2025-06-28&quot;\ntags: [&quot;Chrome Extension&quot;, &quot;架構設計&quot;, &quot;專案整合&quot;]\ndescription: &quot;從單一工具到完整生態系統的演進過程&quot;\ndifficulty: &quot;高級&quot;\ncategory: &quot;projects&quot;\nrelated_projects: [&quot;test-baba-chrome-extension-tools&quot;, &quot;test-ai-memory&quot;]\narchitecture_level: &quot;系統級&quot;\nbusiness_value: &quot;高&quot;\n---\nComponent 特殊欄位\n---\ntitle: &quot;擴展通信橋接器&quot;\ndate: &quot;2025-07-05&quot;\ntags: [&quot;Component&quot;, &quot;Browser Extension&quot;, &quot;通信層&quot;]\ndescription: &quot;統一的瀏覽器擴展通信抽象層&quot;\ndifficulty: &quot;中級&quot;\ncategory: &quot;component&quot;\ncomponent_type: &quot;基礎設施&quot;\nmaturity_level: &quot;Level 2&quot;\nsource_projects: [&quot;browser-extension-ecosystem&quot;]\ndependencies: [&quot;chrome.runtime&quot;]\n---\n🔗 內部連結規範\nObsidian 連結語法\n# 標準連結\n \n[[daily-code/2025-06-28-ai-benchmark-optimization|AI 基準測試優化]]\n \n# 組件連結\n \n[[component/infra-extension-bridge|擴展通信橋接器]]\n \n# 專案連結\n \n[[projects/browser-extension-ecosystem|瀏覽器擴展生態]]\n \n# 文檔連結\n \n[[doc/guides/github-pages-deployment|GitHub Pages 部署指南]]\n連結最佳實踐\n\n使用語義化的顯示文字\n避免過長的連結文字\n保持連結的時效性\n定期檢查連結有效性\n\n🎨 內容結構模板\n標題層次設計\n# 🎯 主標題（H1）- 頁面主題\n \n## 📋 次標題（H2）- 主要章節\n \n### 💡 小標題（H3）- 具體主題\n \n#### 🔧 詳細標題（H4）- 實作細節\nEmoji 使用指南\n# 常用分類 Emoji\n \n🎯 目標/重點 📋 清單/步驟 💡 想法/概念\n🔧 工具/實作 📊 數據/分析 🚀 成果/未來\n⚠️ 注意事項 ✅ 完成/成功 ❌ 錯誤/失敗\n🎨 設計/美化 🔗 連結/關聯 📚 學習/參考\n📊 品質檢查清單\n檔案建立檢查\n\n 檔案路徑符合命名規範\n Frontmatter 完整且正確\n 標題層次清晰\n 標籤使用恰當\n 內部連結有效\n\n內容品質檢查\n\n 符合第一性原理思考\n 遵循 KISS 原則\n 具體範例充足\n 智慧財產權平衡\n 技術深度適當\n\nSEO 與可發現性\n\n 描述文字清晰\n 關鍵字佈局合理\n 連結結構良好\n 標籤分類準確\n\n\n🔄 持續改善機制\n命名規範更新\n\n根據實際使用情況調整\n考慮 SEO 和使用者體驗\n保持與技術發展同步\n\n品質監控\n\n定期檢查連結有效性\n更新過時的技術內容\n優化標籤分類系統\n\n📝 本規範將隨著內容庫的發展持續優化"},"doc/guides/github-development-guide":{"slug":"doc/guides/github-development-guide","filePath":"doc/guides/github-development-guide.md","title":"GitHub 開發者精要指南","links":[],"tags":["GitHub","開發流程","Git","最佳實踐"],"content":"GitHub 開發者精要指南 🚀\n\n專精收斂而非擴散 - 聚焦最實用的 GitHub 工作流程\n\n🏷️ Commit Message 規範（核心！）\n標準格式\n&lt;type&gt;: &lt;description&gt;\n\n範例：\nfeat: 新增用戶登入功能\nfix: 修正購物車計算錯誤\ndocs: 更新 API 使用說明\nstyle: 統一程式碼格式\nrefactor: 重構資料庫查詢邏輯\n\n快速參考\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType用途範例feat✨ 新功能feat: 新增深色模式切換fix🐛 修復錯誤fix: 修正登入驗證失效問題docs📚 文檔更新docs: 更新安裝說明style🎨 格式調整style: 修正程式碼縮排refactor♻️ 程式碼重構refactor: 優化資料處理邏輯perf⚡ 效能優化perf: 改善查詢效能chore🔧 維護更新chore: 更新依賴套件\n🌊 Git 工作流程\nGitHub Flow（推薦）\ngraph LR\n    A[main] --&gt; B[創建 feature branch]\n    B --&gt; C[開發功能]\n    C --&gt; D[Push &amp; PR]\n    D --&gt; E[Code Review]\n    E --&gt; F[Merge to main]\n    F --&gt; G[自動部署]\n\n分支命名規範\n# 功能開發\nfeature/user-authentication\nfeature/dark-mode-toggle\n \n# 錯誤修復\nfix/login-validation\nhotfix/security-patch\n \n# 文檔更新\ndocs/api-documentation\ndocs/setup-guide\n📝 Pull Request 最佳實踐\nPR 標題格式\n[Type] 簡潔描述\n\n範例：\n[Feature] 新增用戶個人資料編輯\n[Fix] 修正購物車總價計算錯誤\n[Docs] 更新部署說明文檔\n\nPR 描述模板\n## 📋 變更內容\n \n簡述此 PR 的主要變更和目的\n \n## 🔗 相關 Issue\n \nCloses #123\n \n## ✅ 測試確認\n \n- [ ] 功能測試通過\n- [ ] 程式碼格式檢查通過\n- [ ] 無破壞性變更\n \n## 📸 效果預覽\n \n![功能截圖或 GIF](image-url)\n📋 Issue 管理\nIssue 標題格式\n[類型] 具體描述問題\n\n範例：\n[Bug] 登入後頁面白屏無法載入\n[Feature] 希望新增深色模式支援\n[Question] API 速率限制相關問題\n\n常用標籤系統\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n標籤顏色用途bug🔴錯誤回報enhancement🟢功能改進documentation🔵文檔相關good first issue🟡新手友善priority: high🔴高優先級\n🚀 GitHub Actions 基礎\n基本 CI/CD 結構\nname: CI/CD Pipeline\n \non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n \njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 📥 Checkout\n        uses: actions/checkout@v4\n \n      - name: 🟢 Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: &quot;22&quot;\n \n      - name: 📦 Install\n        run: npm ci\n \n      - name: 🧪 Test\n        run: npm test\n \n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == &#039;refs/heads/main&#039;\n    steps:\n      - name: 🚀 Deploy\n        run: echo &quot;部署到生產環境&quot;\n常用觸發條件\n# 推送觸發\non:\n  push:\n    branches: [main, develop]\n \n# PR 觸發\non:\n  pull_request:\n    types: [opened, synchronize]\n \n# 手動觸發\non:\n  workflow_dispatch:\n \n# 定時執行\non:\n  schedule:\n    - cron: &#039;0 2 * * *&#039;  # 每天凌晨 2 點\n📁 Repository 結構標準\n必備檔案清單\nproject-root/\n├── 📄 README.md              # 專案說明\n├── 📄 LICENSE                # 授權條款\n├── 📄 .gitignore            # 忽略規則\n├── 📄 CHANGELOG.md          # 版本記錄\n├── 📁 .github/\n│   ├── workflows/            # CI/CD 配置\n│   ├── ISSUE_TEMPLATE/       # Issue 模板\n│   └── PULL_REQUEST_TEMPLATE.md\n├── 📁 src/                   # 原始程式碼\n├── 📁 docs/                  # 技術文檔\n└── 📁 tests/                 # 測試檔案\n\nREADME.md 結構範本\n# 專案名稱\n \n一句話描述專案的核心價值\n \n## 🚀 快速開始\n \n### 安裝\n \n\\`\\`\\`bash\nnpm install\n\\`\\`\\`\n \n### 使用\n \n\\`\\`\\`bash  \nnpm start\n\\`\\`\\`\n \n## 📖 文檔\n \n- [API 文檔](docs/api.md)\n- [部署指南](docs/deployment.md)\n \n## 🤝 貢獻\n \n歡迎提交 Issue 和 PR！\n \n## 📄 授權\n \nMIT License\n🏷️ 版本管理（Semantic Versioning）\n版本號規則\nMAJOR.MINOR.PATCH\n\n1.0.0 → 1.0.1  (patch: 修復錯誤)\n1.0.1 → 1.1.0  (minor: 新增功能)\n1.1.0 → 2.0.0  (major: 重大變更)\n\nGit Tag 操作\n# 建立版本標籤\ngit tag -a v1.2.3 -m &quot;Release v1.2.3&quot;\ngit push origin v1.2.3\n \n# 查看標籤\ngit tag -l\n \n# 刪除標籤\ngit tag -d v1.2.3\ngit push origin :refs/tags/v1.2.3\n👥 Code Review 指南\nReview 重點項目\n\n✅ 功能正確性：是否達成預期目標\n✅ 程式碼品質：可讀性和維護性\n✅ 效能考量：是否有效能瓶頸\n✅ 安全性：是否有潛在風險\n✅ 測試覆蓋：是否有充分測試\n\n良好的 Review 評論\n✅ 建設性評論：\n&quot;建議在第 15 行加入錯誤處理，避免 null 的情況&quot;\n&quot;這個邏輯很清晰！可以考慮提取成獨立函數增加復用性&quot;\n&quot;程式碼風格很棒，邏輯也沒問題&quot;\n\n❌ 無效評論：\n&quot;不對&quot;\n&quot;改掉&quot;\n&quot;這樣不好&quot;\n\n🛡️ 安全最佳實踐\n敏感資訊管理\n# 絕對不要提交的檔案\n.env*\n \n# 使用 Repository Secrets\n${{ secrets.API_KEY }}\n${{ secrets.DATABASE_URL }}\n.gitignore 模板\n# 環境變數\n.env*\n \n# 依賴套件\nnode_modules/\nvendor/\n \n# 建置輸出\ndist/\nbuild/\npublic/\n*.log\n \n# IDE 設定\n.vscode/\n.idea/\n \n# 系統檔案\n.DS_Store\nThumbs.db\n🎯 實用工具\nGitHub CLI 快速操作\n# 建立 PR\ngh pr create --title &quot;feat: 新增功能&quot; --body &quot;功能描述&quot;\n \n# 建立 Issue\ngh issue create --title &quot;bug: 發現錯誤&quot; --body &quot;錯誤描述&quot;\n \n# 查看狀態\ngh pr status\ngh issue list\n推薦 VS Code 擴展\n\nGitLens - Git 歷史增強\nGitHub Pull Requests - PR 管理\nConventional Commits - Commit 輔助\nGit History - 提交歷史視覺化\n\n📊 Repository 健康度指標\n品質徽章\n![Build](github.com/user/repo/workflows/CI/badge.svg)\n![Coverage](codecov.io/gh/user/repo/branch/main/graph/badge.svg)\n![License](img.shields.io/badge/license-MIT-blue.svg)\n![Version](img.shields.io/github/v/release/user/repo)\n定期檢查項目\n\n 依賴套件安全性更新\n CI/CD 流程運行狀況\n Issue 回應時間是否合理\n 文檔是否保持最新\n 程式碼測試覆蓋率\n\n🎯 行動清單\n新專案設定（必做）\n\n 設定 commit message 規範\n 建立 .gitignore 檔案\n 撰寫清晰的 README.md\n 設定基本的 GitHub Actions\n 建立 Issue 和 PR 模板\n\n進階優化（選做）\n\n 整合程式碼品質檢查\n 設定自動化測試流程\n 建立完整的 CI/CD pipeline\n 設定依賴套件安全掃描\n\n\n💡 核心原則\n\n🎯 保持一致性：統一的命名和格式規範\n⚡ 自動化優先：能自動化的絕不手動操作\n📚 文檔同步：程式碼變更時同步更新文檔\n🔄 持續改進：根據團隊反饋優化流程\n\n記住：工具是為了提高效率，不要被流程束縛創造力！\n\n本指南濃縮了最實用的 GitHub 開發經驗，持續更新優化"},"doc/guides/github-pages-deployment":{"slug":"doc/guides/github-pages-deployment","filePath":"doc/guides/github-pages-deployment.md","title":"GitHub Pages 自動部署 SOP","links":[],"tags":["GitHub-Pages","部署","CI/CD","SOP"],"content":"GitHub Pages 自動部署 SOP ⚡\n\n從手動到自動：建立專業級的 GitHub Pages 部署流程\n\n🎯 核心架構\n雙倉庫分離設計\ngraph TB\n    A[📝 selfpagesource&lt;br/&gt;原始碼 + 內容] --&gt;|GitHub Actions| B[🌐 username.github.io&lt;br/&gt;純靜態網站]\n\n    A1[Markdown 內容] --&gt; A\n    A2[Quartz 配置] --&gt; A\n    A3[CI/CD 腳本] --&gt; A\n\n    B --&gt; C[🚀 線上網站&lt;br/&gt;username.github.io]\n\n    B1[HTML/CSS/JS] --&gt; B\n    B2[靜態資源] --&gt; B\n\n設計原則：\n\n🔒 關注點分離：原始碼與發布內容隔離\n⚡ 自動化優先：推送即部署，零手動操作\n🧹 保持純淨：發布倉庫只含靜態檔案\n\n📋 快速設定指南\nStep 1: 建立發布倉庫\n# 1. 在 GitHub 建立新倉庫\n倉庫名稱：{username}.github.io\n可見性：Public（必須）\n初始化：✅ README\n \n# 2. 啟用 GitHub Pages\nSettings → Pages → Source: Deploy from a branch → main\nStep 2: 設定 Personal Access Token\n# 1. 生成 Token\nGitHub 右上角 → Settings → Developer settings\n→ Personal access tokens → Tokens (classic)\n→ Generate new token (classic)\n \n# 2. Token 設定\nNote: &quot;Deploy to GitHub Pages&quot;\nScopes: ✅ repo (完整倉庫權限)\n \n# 3. 保存 Token 到原始碼倉庫\nselfpagesource → Settings → Secrets and variables → Actions\n→ New repository secret\nName: DEPLOY_TOKEN\nSecret: {剛才複製的 token}\nStep 3: 配置自動部署\n建立檔案：.github/workflows/deploy.yml\nname: Deploy to GitHub Pages\n \non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n \njobs:\n  deploy:\n    runs-on: ubuntu-latest\n \n    steps:\n      - name: 📥 Checkout\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n \n      - name: 🟢 Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: &quot;22&quot;\n          cache: &quot;npm&quot;\n \n      - name: 📦 Install dependencies\n        run: npm ci\n \n      - name: 🎨 Format code\n        run: npm run format\n \n      - name: 🔧 Fix permissions\n        run: chmod +x ./quartz/bootstrap-cli.mjs\n \n      - name: 🏗️ Build site\n        run: npx quartz build --output public -v\n \n      - name: 🚀 Deploy\n        uses: peaceiris/actions-gh-pages@v4\n        with:\n          personal_token: ${{ secrets.DEPLOY_TOKEN }}\n          external_repository: {username}/{username}.github.io  # 改成你的用戶名\n          publish_dir: ./public\n          publish_branch: main\n          commit_message: ${{ github.event.head_commit.message }}\n          keep_files: false\n🔄 日常工作流程\n標準開發流程\n# 1. 📝 撰寫內容\n# 在 content/ 目錄下撰寫 Markdown\n \n# 2. 🔍 本地預覽\nnpm run dev              # 開發模式（即時編譯）\nnpm run preview          # 靜態預覽（部署測試）\n \n# 3. ✅ 品質檢查\nnpm run format           # 自動格式化\nnpm run check           # 檢查語法\n \n# 4. 🚀 部署發布\ngit add .\ngit commit -m &quot;feat: 新增 XXX 文章&quot;\ngit push origin main    # 自動觸發部署\nCommit 訊息規範\nfeat: 新增功能或文章\nfix: 修正錯誤\ndocs: 更新文檔\nstyle: 格式調整\nrefactor: 程式碼重構\nchore: 維護性更新\n🛠️ 故障排除\n常見問題速查\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n問題症狀解決方案Token 權限不足remote: Permission denied重新生成 Token，確保有 repo 權限建置失敗沒有生成 index.html檢查 wikilinks 是否指向不存在的檔案404 錯誤網站無法訪問確認 GitHub Pages 設定，等待 5-10 分鐘Actions 失敗Process completed with exit code 1查看 Actions 日誌，通常是建置問題\nDebug 工具\n# 本地診斷\nnpm run build-static    # 檢查建置是否成功\nnpm run preview        # 測試真實部署效果\nls public/index.html   # 確認首頁檔案存在\n \n# 線上診斷\n# 1. GitHub Actions 頁面查看執行日誌\n# 2. 目標倉庫確認檔案是否更新\n# 3. GitHub Pages 設定確認無誤\n📊 效果驗證\n成功指標\n\n✅ Actions 狀態：綠色勾勾，無錯誤日誌\n✅ 目標倉庫：有新的 commit 和 index.html\n✅ 線上網站：內容正確更新，路由正常\n✅ 建置速度：&lt; 5 分鐘完成端到端部署\n\n效能指標\n⚡ 推送到上線：&lt; 5 分鐘\n🔄 自動化程度：100%\n🛡️ 錯誤恢復：自動重試機制\n📈 成功率：&gt; 99%\n\n🔧 進階優化\n1. 快取優化\n- name: 📦 Cache dependencies\n  uses: actions/cache@v4\n  with:\n    path: ~/.npm\n    key: ${{ runner.os }}-node-${{ hashFiles(&#039;**/package-lock.json&#039;) }}\n2. 通知整合\n- name: 📢 Notify success\n  if: success()\n  run: echo &quot;🎉 網站已成功部署到 https://{username}.github.io&quot;\n3. 多環境支援\n# 支援 staging 環境測試\n- name: 🧪 Deploy to staging\n  if: github.ref == &#039;refs/heads/develop&#039;\n  uses: peaceiris/actions-gh-pages@v4\n  with:\n    external_repository: {username}/staging.{username}.github.io\n🎯 最佳實踐\n安全性\n\n🔒 Token 管理：定期更新，使用最小權限\n🔒 敏感資訊：永不提交 .env 檔案\n🔒 權限控制：原始碼倉庫可設為私有\n\n維護性\n\n📅 定期檢查：Token 過期提醒\n📊 監控指標：部署成功率、建置時間\n📚 文檔更新：配置變更時同步更新 SOP\n\n效率性\n\n⚡ 本地測試：使用 npm run preview 預先驗證\n⚡ 增量部署：只在內容變更時觸發\n⚡ 快速回滾：保留 Git 歷史便於恢復\n\n\n📝 檢查清單\n初次設定\n\n 建立 {username}.github.io 倉庫\n 生成 Personal Access Token\n 設定 DEPLOY_TOKEN Secret\n 配置 .github/workflows/deploy.yml\n 測試首次部署\n\n日常維護\n\n Token 是否即將過期？\n Actions 執行是否正常？\n 網站載入速度如何？\n 建置時間是否合理？\n 錯誤日誌是否有異常？\n\n\n核心理念：工具是為了提高效率，一次設定，永久受益！\n本 SOP 基於實際部署經驗，持續優化更新"},"doc/guides/index":{"slug":"doc/guides/index","filePath":"doc/guides/index.md","title":"操作指南","links":["doc/guides/github-pages-deployment","doc/guides/github-development-guide","doc/guides/mcp-development-guide"],"tags":[],"content":"操作指南 📋\n\n精選的技術操作指南，聚焦實用性和可執行性\n\n🚀 部署自動化\nGitHub Pages 自動部署 SOP\n完整的 GitHub Pages 自動化部署流程，從設定到上線的一站式指南。\n核心特色：\n\n🏗️ 雙倉庫分離架構設計\n⚡ CI/CD 全自動化流程\n🛠️ 完整的故障排除指南\n📊 效能監控和最佳實踐\n\n💻 開發流程\nGitHub 開發者精要指南\nGitHub 開發工作流程的核心要點，遵循「專精收斂而非擴散」原則。\n核心特色：\n\n🏷️ Commit Message 標準規範\n📝 Pull Request 最佳實踐\n👥 Code Review 指導原則\n🛡️ 安全性最佳實踐\n\n🤖 AI工具開發\nMCP工具開發指南\n基於Model Context Protocol的AI工具開發完整指南，從Git分析器實作經驗提煉的標準化流程。\n核心特色：\n\n🏷️ 標準化的MCP Server開發框架\n🛡️ 安全性與權限控制最佳實踐\n⚡ 效能優化與監控策略\n📝 完整的測試與部署流程\n\n🎯 設計理念\n專精收斂原則\n\n聚焦核心：只保留最實用的操作步驟\n避免冗餘：移除過度詳細的理論說明\n實戰導向：每個指南都經過實際驗證\n\n可執行性優先\n\n步驟明確：每個操作都有具體的命令和截圖\n錯誤預防：預先說明常見問題和解決方案\n快速上手：新手也能按照指南快速完成任務\n\n📈 使用建議\n🔖 快速導航\n\n首次部署：從 GitHub Pages 部署 SOP 開始\n日常開發：參考 GitHub 開發者指南\n遇到問題：查看各指南的故障排除章節\n\n📱 最佳體驗\n\n桌面端：完整的操作截圖和詳細說明\n行動端：響應式設計，隨時隨地查閱\n離線使用：可列印為 PDF 隨身攜帶\n\n🔄 持續更新\n這些指南會根據實際使用經驗持續優化：\n\n✅ 新增更多實用案例\n✅ 優化操作步驟描述\n✅ 補充最新的最佳實踐\n✅ 修正使用者回饋的問題\n\n\n核心理念：指南是為了解決實際問題，而不是展示理論知識！"},"doc/guides/knowledge-graph-building":{"slug":"doc/guides/knowledge-graph-building","filePath":"doc/guides/knowledge-graph-building.md","title":"知識圖譜建構指南","links":["tags/KnowledgeGraph","tags/Obsidian","tags/Learning","tags/SystemThinking"],"tags":["KnowledgeGraph","Obsidian","Learning","SystemThinking"],"content":"🕸️ 知識圖譜建構指南\n🎯 核心理念\n知識網路化思維\n\n知識不是孤立的點，而是相互連接的網路。透過有意識的連結建構，將零散的學習心得轉化為系統性的知識資產。\n\n🔗 連結策略框架\n1. 橫向連結（同層級）\n# Daily-Code 之間的連結\n \n[[daily-code/2025-06-28-ai-benchmark-optimization]] ↔ [[daily-code/2025-06-27-async-pattern]]\n相同技術領域的不同應用\n \n# Projects 之間的連結\n \n[[projects/browser-extension-ecosystem]] ↔ [[projects/ai-development-framework]]\n架構設計模式的共通性\n2. 縱向連結（跨層級）\n# Daily-Code → Projects（由點到面）\n \n[[daily-code/2025-06-28-ai-benchmark-optimization]] → [[projects/ai-performance-suite]]\n技術心得匯聚成專案洞察\n \n# Projects → Components（抽象化）\n \n[[projects/browser-extension-ecosystem]] → [[component/infra-extension-bridge]]\n專案經驗提煉為可重用組件\n \n# Doc → Daily-Code（理論到實踐）\n \n[[doc/guides/performance-optimization]] → [[daily-code/2025-06-28-ai-benchmark-optimization]]\n指南文檔的具體應用案例\n3. 概念連結（主題群集）\n# 效能優化主題群\n \n- [[daily-code/ai-benchmark-optimization]]\n- [[daily-code/memory-pool-management]]\n- [[component/async-batch-processor]]\n- [[projects/performance-monitoring-system]]\n- [[doc/guides/performance-best-practices]]\n🏗️ 連結類型分類\n技術傳承連結\n# 學習軌跡\n \n初學 → 應用 → 深化 → 創新\n[[doc/basic-concepts]] → [[daily-code/first-attempt]] → [[daily-code/optimization]] → [[component/innovative-solution]]\n問題解決連結\n# 問題-方案-驗證鏈\n \n[[daily-code/problem-discovery]] → [[doc/solution-research]] → [[daily-code/implementation]] → [[projects/production-validation]]\n工具生態連結\n# 工具鏈關係\n \n[[doc/tool-setup]] ↔ [[daily-code/tool-usage]] ↔ [[component/tool-wrapper]] ↔ [[projects/tool-integration]]\n🎨 連結建構技巧\n1. 智能標籤系統\n# 在 frontmatter 中建立關聯\nrelated_concepts: [&quot;效能優化&quot;, &quot;異步程式設計&quot;, &quot;記憶體管理&quot;]\nprerequisite: [&quot;基礎 JavaScript&quot;, &quot;Node.js 概念&quot;]\nnext_steps: [&quot;分散式系統&quot;, &quot;微服務架構&quot;]\ndifficulty_progression: [&quot;入門篇&quot;, &quot;進階篇&quot;, &quot;專家篇&quot;]\n2. 內容中的自然連結\n# 在內容中自然地引用相關知識\n \n當我在 [[daily-code/chrome-extension-memory|Chrome 擴展記憶體優化]] 中遇到類似問題時，\n這裡的 [[component/memory-pool|記憶體池管理組件]] 提供了通用的解決方案。\n這種模式在 [[projects/browser-extension-ecosystem|瀏覽器擴展生態系統]] 中得到了驗證。\n3. 反向連結利用\n# 在新內容中主動連結到相關的舊內容\n \n這個概念最初在 [[daily-code/2025-06-15-design-pattern]] 中提到，\n後來在 [[projects/architecture-evolution]] 中得到深化，\n現在我們將其抽象為 [[component/design-pattern-library]] 中的標準模式。\n📊 連結密度指標\n理想的連結比例\n📝 Daily-Code: 每篇 3-5 個內部連結\n🎯 Projects: 每篇 5-10 個內部連結\n🧩 Components: 每個 4-8 個內部連結\n📚 Doc: 每篇 2-6 個內部連結\n\n連結品質評估\n\n深度連結 &gt; 表面連結\n語義連結 &gt; 機械連結\n雙向連結 &gt; 單向連結\n主題群集 &gt; 零散連結\n\n🔄 知識演進追蹤\n概念成熟度路徑\ngraph LR\n    A[初次接觸&lt;br/&gt;daily-code] --&gt; B[深入理解&lt;br/&gt;doc研究]\n    B --&gt; C[實際應用&lt;br/&gt;projects整合]\n    C --&gt; D[抽象組件&lt;br/&gt;component提煉]\n    D --&gt; E[系統化知識&lt;br/&gt;knowledge-graph]\n\n    E --&gt; F[新問題發現]\n    F --&gt; A\n\n版本化知識更新\n# 在文章末尾追蹤知識演進\n \n## 🔄 知識演進記錄\n \n### v1.0 (2025-06-28)\n \n- 初次實作並記錄基礎概念\n- 連結到 [[doc/performance-basics]]\n \n### v2.0 (2025-07-05)\n \n- 發現與 [[component/async-pattern]] 的關聯\n- 整合到 [[projects/performance-ecosystem]]\n \n### v3.0 (2025-07-15)\n \n- 抽象為 [[component/performance-analyzer]]\n- 成為 [[knowledge-map/performance-optimization]] 的核心節點\n🎯 實際應用策略\n1. 每日連結檢查（5分鐘）\n# 撰寫新內容時的檢查清單\n \n- [ ] 這個概念之前在哪裡提過？\n- [ ] 相關的技術棧有哪些文章？\n- [ ] 有沒有可以抽象為組件的部分？\n- [ ] 這個問題在其他專案中如何解決？\n- [ ] 需要補充哪些文檔支援？\n2. 週期性圖譜重構（每月）\n# 知識圖譜健康檢查\n \n- [ ] 孤立節點識別與連結\n- [ ] 過度連結的簡化\n- [ ] 新興主題群集發現\n- [ ] 過時連結的清理\n- [ ] 缺失連結的補充\n3. 主題地圖建構（每季）\n# 建立主題導航頁面\n \n## 🗺️ 效能優化知識地圖\n \n### 🎯 核心概念\n \n- [[doc/performance-fundamentals]]\n- [[doc/measurement-methodology]]\n \n### 💡 實戰經驗\n \n- [[daily-code/ai-benchmark-optimization]]\n- [[daily-code/memory-optimization-patterns]]\n \n### 🔧 可重用工具\n \n- [[component/performance-analyzer]]\n- [[component/benchmark-framework]]\n \n### 🚀 系統整合\n \n- [[projects/monitoring-infrastructure]]\n- [[projects/optimization-pipeline]]\n🧠 智慧連結建議\n自動化連結發現\n# 概念：未來可開發的自動化工具\ndef suggest_links(new_content):\n    &quot;&quot;&quot;基於內容相似度和標籤重疊建議相關連結&quot;&quot;&quot;\n    similar_content = find_similar_by_tags(new_content)\n    concept_matches = extract_shared_concepts(new_content)\n    return generate_link_suggestions(similar_content, concept_matches)\n連結強度計算\n# 連結關係強度評估\n \n🔗 強連結：直接相關，互相依賴\n🔸 中連結：間接相關，可參考\n⚪ 弱連結：概念相似，可延伸\n\n💡 最佳實踐總結\nDo’s（應該做的）\n\n✅ 撰寫時主動思考關聯性\n✅ 定期回顧和強化連結\n✅ 建立主題導航頁面\n✅ 追蹤知識演進過程\n✅ 平衡連結數量和品質\n\nDon’ts（避免的）\n\n❌ 機械式的過度連結\n❌ 無意義的連結堆疊\n❌ 忽視反向連結建構\n❌ 僅建立當下的連結\n❌ 缺乏連結維護\n\n核心指標\n🎯 連結有效性 &gt; 90%\n🔗 平均連結深度 &gt; 3 層\n📊 主題覆蓋率 &gt; 80%\n🔄 更新頻率 &lt; 1 月\n\n\n🎯 目標：將零散知識轉化為系統性的個人技術資產庫\n📈 價值：透過知識網路效應，放大每一次學習的長期價值\nKnowledgeGraph Obsidian Learning SystemThinking"},"doc/guides/mcp-development-guide":{"slug":"doc/guides/mcp-development-guide","filePath":"doc/guides/mcp-development-guide.md","title":"MCP工具開發指南","links":[],"tags":["MCP","AI工具開發","協議實現","系統整合"],"content":"MCP工具開發指南\n\n基於Git分析器實作經驗，建立MCP工具開發的標準化流程與最佳實踐\n\nMCP協議概述\n協議設計理念\nModel Context Protocol (MCP) 是一個開放標準，旨在實現AI助手與外部工具的標準化整合。它解決了AI助手需要與各種外部系統互動的問題，提供了統一的介面規範。\n核心概念\nAI Assistant ←→ MCP Client ←→ MCP Server ←→ External Tools/Data\n\n主要組件\n\nMCP Server：實現具體工具功能的服務端\nMCP Client：AI助手側的協議客戶端\nTransport：通信傳輸層（stdio、HTTP、WebSocket等）\nTools：具體的功能實現單元\n\n協議特性\n\n工具註冊：動態註冊可用工具及其schema\n類型安全：基於JSON Schema的強類型介面\n錯誤處理：標準化的錯誤回報機制\n可擴展性：支援自定義工具與資源類型\n\n開發環境設置\n基礎依賴\n# 核心MCP SDK\nnpm install @modelcontextprotocol/sdk\n \n# 常用開發依賴\nnpm install --save-dev @types/node typescript tsx\n專案結構建議\nmcp-tool-project/\n├── package.json              # 專案配置\n├── index.js                  # 主要MCP Server\n├── lib/                      # 工具實現邏輯\n│   ├── tools/               # 各個工具的實現\n│   ├── utils/               # 共用工具函數\n│   └── types/               # 類型定義\n├── test/                     # 測試檔案\n├── examples/                 # 使用範例\n└── README.md                 # 文檔說明\n\nTypeScript設定\n{\n  &quot;compilerOptions&quot;: {\n    &quot;target&quot;: &quot;ES2022&quot;,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;moduleResolution&quot;: &quot;node&quot;,\n    &quot;allowSyntheticDefaultImports&quot;: true,\n    &quot;esModuleInterop&quot;: true,\n    &quot;strict&quot;: true,\n    &quot;skipLibCheck&quot;: true\n  }\n}\nMCP Server基礎架構\n核心Server類別設計\nimport { Server } from &#039;@modelcontextprotocol/sdk/server/index.js&#039;;\nimport { StdioServerTransport } from &#039;@modelcontextprotocol/sdk/server/stdio.js&#039;;\n \nclass BaseMCPServer {\n  constructor(name, version, capabilities = {}) {\n    this.server = new Server(\n      { name, version },\n      { capabilities: { tools: {}, ...capabilities } }\n    );\n    \n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n \n  setupHandlers() {\n    // 註冊工具列表處理器\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return { tools: this.getToolDefinitions() };\n    });\n \n    // 註冊工具調用處理器\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      return await this.handleToolCall(request);\n    });\n  }\n \n  async handleToolCall(request) {\n    const { name, arguments: args } = request.params;\n    \n    try {\n      const handler = this.toolHandlers[name];\n      if (!handler) {\n        throw new Error(`未知工具: ${name}`);\n      }\n      \n      return await handler(args);\n    } catch (error) {\n      return this.formatError(error);\n    }\n  }\n \n  formatError(error) {\n    return {\n      content: [{\n        type: &#039;text&#039;,\n        text: `錯誤: ${error.message}`\n      }]\n    };\n  }\n}\n工具註冊機制\nclass ToolRegistry {\n  constructor() {\n    this.tools = new Map();\n  }\n \n  register(name, definition, handler) {\n    this.tools.set(name, {\n      definition,\n      handler\n    });\n  }\n \n  getDefinitions() {\n    return Array.from(this.tools.values()).map(tool =&gt; tool.definition);\n  }\n \n  getHandler(name) {\n    return this.tools.get(name)?.handler;\n  }\n}\n \n// 使用範例\nconst registry = new ToolRegistry();\n \nregistry.register(&#039;my_tool&#039;, {\n  name: &#039;my_tool&#039;,\n  description: &#039;工具描述&#039;,\n  inputSchema: {\n    type: &#039;object&#039;,\n    properties: {\n      param1: { type: &#039;string&#039;, description: &#039;參數說明&#039; }\n    },\n    required: [&#039;param1&#039;]\n  }\n}, async (args) =&gt; {\n  // 工具實現邏輯\n  return { content: [{ type: &#039;text&#039;, text: &#039;結果&#039; }] };\n});\n工具設計最佳實踐\n1. 單一職責原則\n每個工具應該專注於一個明確的功能領域：\n// ✅ 好的設計：職責明確\nconst fileReadTool = {\n  name: &#039;read_file&#039;,\n  description: &#039;讀取指定檔案內容&#039;,\n  // ...\n};\n \n// ❌ 避免：功能過於複雜\nconst fileSystemTool = {\n  name: &#039;filesystem_operations&#039;,\n  description: &#039;執行各種檔案系統操作（讀取、寫入、刪除、移動...）&#039;,\n  // ...\n};\n2. 介面設計原則\n參數設計\n// 參數命名清晰且具描述性\nconst toolSchema = {\n  inputSchema: {\n    type: &#039;object&#039;,\n    properties: {\n      projectPath: {\n        type: &#039;string&#039;,\n        description: &#039;專案的絕對路徑&#039;,\n        examples: [&#039;/path/to/project&#039;]\n      },\n      maxItems: {\n        type: &#039;number&#039;,\n        description: &#039;最大返回項目數量&#039;,\n        default: 50,\n        minimum: 1,\n        maximum: 1000\n      },\n      options: {\n        type: &#039;object&#039;,\n        description: &#039;額外配置選項&#039;,\n        properties: {\n          includeDetails: {\n            type: &#039;boolean&#039;,\n            description: &#039;是否包含詳細資訊&#039;,\n            default: false\n          }\n        }\n      }\n    },\n    required: [&#039;projectPath&#039;]\n  }\n};\n輸出標準化\n// 標準化的成功回應格式\nfunction formatSuccess(data, metadata = {}) {\n  return {\n    content: [{\n      type: &#039;text&#039;,\n      text: JSON.stringify({\n        success: true,\n        data,\n        metadata: {\n          timestamp: new Date().toISOString(),\n          ...metadata\n        }\n      }, null, 2)\n    }]\n  };\n}\n \n// 標準化的錯誤回應格式\nfunction formatError(error, context = {}) {\n  return {\n    content: [{\n      type: &#039;text&#039;, \n      text: JSON.stringify({\n        success: false,\n        error: {\n          message: error.message,\n          code: error.code || &#039;UNKNOWN_ERROR&#039;,\n          context\n        },\n        timestamp: new Date().toISOString()\n      }, null, 2)\n    }]\n  };\n}\n3. 錯誤處理策略\n分層錯誤處理\nclass ErrorHandler {\n  static async withErrorHandling(operation, context = {}) {\n    try {\n      return await operation();\n    } catch (error) {\n      // 記錄錯誤\n      console.error(&#039;Tool execution error:&#039;, {\n        error: error.message,\n        stack: error.stack,\n        context\n      });\n \n      // 分類錯誤類型\n      if (error instanceof ValidationError) {\n        return this.formatValidationError(error);\n      } else if (error instanceof PermissionError) {\n        return this.formatPermissionError(error);\n      } else {\n        return this.formatGenericError(error);\n      }\n    }\n  }\n \n  static formatValidationError(error) {\n    return {\n      content: [{\n        type: &#039;text&#039;,\n        text: `參數驗證錯誤: ${error.message}`\n      }]\n    };\n  }\n}\n用戶友好的錯誤訊息\nconst errorMessages = {\n  FILE_NOT_FOUND: &#039;指定的檔案不存在，請檢查路徑是否正確&#039;,\n  PERMISSION_DENIED: &#039;沒有足夠的權限執行此操作&#039;,\n  INVALID_FORMAT: &#039;檔案格式不正確或已損壞&#039;,\n  NETWORK_ERROR: &#039;網路連接失敗，請檢查網路狀態&#039;,\n  TIMEOUT: &#039;操作超時，請嘗試減少資料量或稍後重試&#039;\n};\n \nfunction createUserFriendlyError(errorCode, details = &#039;&#039;) {\n  const baseMessage = errorMessages[errorCode] || &#039;發生未知錯誤&#039;;\n  return new Error(details ? `${baseMessage}。詳細資訊: ${details}` : baseMessage);\n}\n安全性與權限控制\n1. 輸入驗證\nclass InputValidator {\n  static validatePath(path) {\n    // 路徑正規化\n    const normalizedPath = pathModule.resolve(path);\n    \n    // 防止目錄遍歷攻擊\n    if (normalizedPath.includes(&#039;..&#039;)) {\n      throw new ValidationError(&#039;路徑包含非法字符&#039;);\n    }\n    \n    // 檢查允許的目錄範圍\n    const allowedPaths = [&#039;/allowed/path1&#039;, &#039;/allowed/path2&#039;];\n    if (!allowedPaths.some(allowed =&gt; normalizedPath.startsWith(allowed))) {\n      throw new PermissionError(&#039;路徑不在允許範圍內&#039;);\n    }\n    \n    return normalizedPath;\n  }\n \n  static validateStringLength(value, maxLength = 1000) {\n    if (typeof value !== &#039;string&#039;) {\n      throw new ValidationError(&#039;參數必須為字串&#039;);\n    }\n    \n    if (value.length &gt; maxLength) {\n      throw new ValidationError(`字串長度不能超過 ${maxLength} 字符`);\n    }\n    \n    return value;\n  }\n}\n2. 權限控制\nclass PermissionManager {\n  constructor(config) {\n    this.allowedOperations = new Set(config.allowedOperations || []);\n    this.blockedPatterns = config.blockedPatterns || [];\n  }\n \n  checkOperation(operation) {\n    if (!this.allowedOperations.has(operation)) {\n      throw new PermissionError(`操作 ${operation} 不被允許`);\n    }\n  }\n \n  checkContent(content) {\n    for (const pattern of this.blockedPatterns) {\n      if (pattern.test(content)) {\n        throw new SecurityError(&#039;內容包含敏感資訊&#039;);\n      }\n    }\n  }\n}\n3. 資料清理\nclass DataSanitizer {\n  static sanitizeForOutput(data) {\n    if (typeof data === &#039;string&#039;) {\n      return this.sanitizeString(data);\n    } else if (Array.isArray(data)) {\n      return data.map(item =&gt; this.sanitizeForOutput(item));\n    } else if (typeof data === &#039;object&#039; &amp;&amp; data !== null) {\n      return this.sanitizeObject(data);\n    }\n    return data;\n  }\n \n  static sanitizeString(str) {\n    // 移除敏感資訊\n    const sensitivePatterns = [\n      /password[=:]\\s*\\S+/gi,\n      /api[_-]?key[=:]\\s*\\S+/gi,\n      /secret[=:]\\s*\\S+/gi\n    ];\n \n    let cleaned = str;\n    for (const pattern of sensitivePatterns) {\n      cleaned = cleaned.replace(pattern, &#039;[REDACTED]&#039;);\n    }\n \n    return cleaned;\n  }\n \n  static sanitizeObject(obj) {\n    const cleaned = {};\n    for (const [key, value] of Object.entries(obj)) {\n      cleaned[key] = this.sanitizeForOutput(value);\n    }\n    return cleaned;\n  }\n}\n效能優化策略\n1. 異步處理最佳實踐\nclass AsyncProcessor {\n  constructor(concurrency = 5) {\n    this.concurrency = concurrency;\n  }\n \n  async processBatch(items, processor) {\n    const results = [];\n    \n    for (let i = 0; i &lt; items.length; i += this.concurrency) {\n      const batch = items.slice(i, i + this.concurrency);\n      const batchResults = await Promise.all(\n        batch.map(async (item, index) =&gt; {\n          try {\n            return await processor(item, i + index);\n          } catch (error) {\n            console.error(`處理項目 ${i + index} 失敗:`, error);\n            return { error: error.message };\n          }\n        })\n      );\n      results.push(...batchResults);\n    }\n    \n    return results;\n  }\n}\n2. 快取機制\nclass CacheManager {\n  constructor(options = {}) {\n    this.cache = new Map();\n    this.maxSize = options.maxSize || 1000;\n    this.ttl = options.ttl || 3600000; // 1小時\n  }\n \n  set(key, value) {\n    // 清理過期項目\n    this.cleanup();\n    \n    // 如果快取已滿，移除最舊的項目\n    if (this.cache.size &gt;= this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n \n    this.cache.set(key, {\n      value,\n      timestamp: Date.now()\n    });\n  }\n \n  get(key) {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n \n    if (Date.now() - entry.timestamp &gt; this.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n \n    return entry.value;\n  }\n \n  cleanup() {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp &gt; this.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n3. 記憶體管理\nclass MemoryManager {\n  static monitorMemoryUsage() {\n    const usage = process.memoryUsage();\n    return {\n      rss: Math.round(usage.rss / 1024 / 1024) + &#039; MB&#039;,\n      heapTotal: Math.round(usage.heapTotal / 1024 / 1024) + &#039; MB&#039;,\n      heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + &#039; MB&#039;,\n      external: Math.round(usage.external / 1024 / 1024) + &#039; MB&#039;\n    };\n  }\n \n  static async withMemoryLimit(operation, limitMB = 512) {\n    const initialMemory = process.memoryUsage().heapUsed;\n    \n    try {\n      const result = await operation();\n      \n      const finalMemory = process.memoryUsage().heapUsed;\n      const usedMemory = (finalMemory - initialMemory) / 1024 / 1024;\n      \n      if (usedMemory &gt; limitMB) {\n        console.warn(`記憶體使用超過限制: ${usedMemory.toFixed(2)}MB &gt; ${limitMB}MB`);\n      }\n      \n      return result;\n    } finally {\n      // 強制垃圾回收（如果可用）\n      if (global.gc) {\n        global.gc();\n      }\n    }\n  }\n}\n測試策略\n1. 單元測試結構\nimport { describe, it, expect, beforeEach } from &#039;vitest&#039;;\nimport { MockMCPServer } from &#039;./mocks/MockMCPServer.js&#039;;\n \ndescribe(&#039;工具名稱&#039;, () =&gt; {\n  let server;\n \n  beforeEach(() =&gt; {\n    server = new MockMCPServer();\n  });\n \n  describe(&#039;正常情況&#039;, () =&gt; {\n    it(&#039;should handle valid input correctly&#039;, async () =&gt; {\n      const request = {\n        name: &#039;tool_name&#039;,\n        arguments: { param: &#039;valid_value&#039; }\n      };\n \n      const response = await server.handleToolCall(request);\n      \n      expect(response.content[0].type).toBe(&#039;text&#039;);\n      const result = JSON.parse(response.content[0].text);\n      expect(result.success).toBe(true);\n    });\n  });\n \n  describe(&#039;錯誤處理&#039;, () =&gt; {\n    it(&#039;should handle invalid input gracefully&#039;, async () =&gt; {\n      const request = {\n        name: &#039;tool_name&#039;,\n        arguments: { param: null }\n      };\n \n      const response = await server.handleToolCall(request);\n      const result = JSON.parse(response.content[0].text);\n      \n      expect(result.success).toBe(false);\n      expect(result.error.message).toContain(&#039;參數驗證錯誤&#039;);\n    });\n  });\n});\n2. 整合測試\ndescribe(&#039;MCP協議整合&#039;, () =&gt; {\n  let transport;\n  let server;\n \n  beforeEach(async () =&gt; {\n    transport = new MockTransport();\n    server = new MyMCPServer();\n    await server.connect(transport);\n  });\n \n  it(&#039;should register tools correctly&#039;, async () =&gt; {\n    const response = await transport.sendRequest({\n      method: &#039;tools/list&#039;\n    });\n \n    expect(response.tools).toHaveLength(expectedToolCount);\n    expect(response.tools[0]).toHaveProperty(&#039;name&#039;);\n    expect(response.tools[0]).toHaveProperty(&#039;description&#039;);\n    expect(response.tools[0]).toHaveProperty(&#039;inputSchema&#039;);\n  });\n});\n3. 效能測試\ndescribe(&#039;效能測試&#039;, () =&gt; {\n  it(&#039;should complete within time limit&#039;, async () =&gt; {\n    const startTime = Date.now();\n    \n    const result = await server.handleLargeDataOperation({\n      dataSize: 10000\n    });\n    \n    const duration = Date.now() - startTime;\n    \n    expect(duration).toBeLessThan(5000); // 5秒內完成\n    expect(result.success).toBe(true);\n  });\n \n  it(&#039;should not exceed memory limit&#039;, async () =&gt; {\n    const initialMemory = process.memoryUsage().heapUsed;\n    \n    await server.handleMemoryIntensiveOperation();\n    \n    const finalMemory = process.memoryUsage().heapUsed;\n    const memoryIncrease = finalMemory - initialMemory;\n    \n    expect(memoryIncrease).toBeLessThan(100 * 1024 * 1024); // 100MB限制\n  });\n});\n部署與發布\n1. package.json設定\n{\n  &quot;name&quot;: &quot;@yourorg/mcp-tool-name&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;type&quot;: &quot;module&quot;,\n  &quot;bin&quot;: {\n    &quot;mcp-tool-name&quot;: &quot;./index.js&quot;\n  },\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;node index.js&quot;,\n    &quot;dev&quot;: &quot;node --inspect index.js&quot;,\n    &quot;test&quot;: &quot;vitest&quot;,\n    &quot;build&quot;: &quot;tsc&quot;,\n    &quot;lint&quot;: &quot;eslint .&quot;,\n    &quot;format&quot;: &quot;prettier --write .&quot;\n  },\n  &quot;engines&quot;: {\n    &quot;node&quot;: &quot;&gt;=18.0.0&quot;\n  },\n  &quot;files&quot;: [\n    &quot;index.js&quot;,\n    &quot;lib/&quot;,\n    &quot;README.md&quot;,\n    &quot;LICENSE&quot;\n  ]\n}\n2. npx支援\n#!/usr/bin/env node\n \nimport { program } from &#039;commander&#039;;\nimport { MyMCPServer } from &#039;./lib/server.js&#039;;\n \nprogram\n  .name(&#039;mcp-tool-name&#039;)\n  .description(&#039;工具描述&#039;)\n  .version(&#039;1.0.0&#039;);\n \nprogram\n  .command(&#039;start&#039;)\n  .description(&#039;啟動MCP服務器&#039;)\n  .action(async () =&gt; {\n    const server = new MyMCPServer();\n    await server.start();\n  });\n \nprogram\n  .command(&#039;test&#039;)\n  .description(&#039;測試工具功能&#039;)\n  .argument(&#039;&lt;testParam&gt;&#039;, &#039;測試參數&#039;)\n  .action(async (testParam) =&gt; {\n    // 執行測試邏輯\n  });\n \nif (import.meta.url === `file://${process.argv[1]}`) {\n  program.parse();\n}\n3. Claude Desktop整合\n{\n  &quot;mcpServers&quot;: {\n    &quot;your-tool&quot;: {\n      &quot;command&quot;: &quot;npx&quot;,\n      &quot;args&quot;: [&quot;@yourorg/mcp-tool-name&quot;, &quot;start&quot;],\n      &quot;cwd&quot;: &quot;/path/to/working/directory&quot;,\n      &quot;env&quot;: {\n        &quot;NODE_ENV&quot;: &quot;production&quot;\n      }\n    }\n  }\n}\n監控與日誌\n1. 結構化日誌\nclass Logger {\n  constructor(service) {\n    this.service = service;\n  }\n \n  info(message, context = {}) {\n    this.log(&#039;INFO&#039;, message, context);\n  }\n \n  error(message, error, context = {}) {\n    this.log(&#039;ERROR&#039;, message, {\n      ...context,\n      error: {\n        message: error.message,\n        stack: error.stack\n      }\n    });\n  }\n \n  log(level, message, context) {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      service: this.service,\n      message,\n      context\n    };\n \n    console.error(JSON.stringify(logEntry));\n  }\n}\n2. 效能監控\nclass PerformanceMonitor {\n  static withMetrics(name, operation) {\n    return async (...args) =&gt; {\n      const start = performance.now();\n      const startMemory = process.memoryUsage().heapUsed;\n \n      try {\n        const result = await operation(...args);\n        \n        this.recordSuccess(name, start, startMemory);\n        return result;\n      } catch (error) {\n        this.recordError(name, error, start, startMemory);\n        throw error;\n      }\n    };\n  }\n \n  static recordSuccess(name, start, startMemory) {\n    const duration = performance.now() - start;\n    const memoryUsed = process.memoryUsage().heapUsed - startMemory;\n \n    console.error(JSON.stringify({\n      type: &#039;performance&#039;,\n      operation: name,\n      status: &#039;success&#039;,\n      duration: `${duration.toFixed(2)}ms`,\n      memoryUsed: `${(memoryUsed / 1024 / 1024).toFixed(2)}MB`\n    }));\n  }\n}\n最佳實踐總結\n開發原則\n\n單一職責：每個工具專注一個明確功能\n介面清晰：參數命名具描述性，提供預設值\n錯誤友好：提供清晰的錯誤訊息和恢復建議\n效能意識：考慮大資料集和長時間操作的效能影響\n安全第一：輸入驗證、權限控制、資料清理\n\n架構模式\n\n分層設計：協議層、業務邏輯層、資料存取層\n依賴注入：便於測試和配置管理\n插件架構：支援功能擴展和自定義\n事件驅動：非同步操作和狀態管理\n\n品質保證\n\n全面測試：單元測試、整合測試、效能測試\n代碼品質：ESLint、Prettier、TypeScript\n文檔完整：API文檔、使用範例、故障排除\n持續整合：自動化測試和部署流程\n\n\n指南價值：基於實際專案經驗的MCP工具開發標準化流程，可大幅降低開發門檻並提升工具品質。\n適用範圍：所有需要整合AI助手的專業工具開發場景\n技術等級：中高級\n維護策略：隨MCP生態系統發展持續更新\n文檔維護：PekoraTech SA Team - Technical Writing\n最後更新：2025-07-05\n版本：v1.0"},"doc/guides/quartz-localization-guide":{"slug":"doc/guides/quartz-localization-guide","filePath":"doc/guides/quartz-localization-guide.md","title":"Quartz 導航中文化指南","links":[],"tags":["Quartz","中文化","導航","設定"],"content":"Quartz 導航中文化指南 🌐\n\n讓你的 Quartz 網站導航完全中文化\n\n🎯 實現效果\n修改前：\n📁 doc\n  📁 guides\n    📄 github-development-guide\n    📄 github-pages-deployment\n\n修改後：\n📁 文件\n  📁 操作指南\n    📄 GitHub 開發者精要指南\n    📄 GitHub Pages 自動部署 SOP\n\n🔧 實作方法\n方法一：使用 Frontmatter（推薦）\n在每個檔案的開頭添加 frontmatter：\n---\ntitle: &quot;中文標題&quot;\ndescription: &quot;中文描述&quot;\n---\n \n# 原始標題\n方法二：修改檔案名稱（不推薦）\n直接重新命名檔案和資料夾，但會影響現有連結。\n📋 完整實作步驟\n第一步：為資料夾建立 index.md\n# 為每個要中文化的資料夾建立 index.md\ncontent/\n├── doc/\n│   ├── index.md          # title: &quot;文件&quot;\n│   └── guides/\n│       └── index.md      # title: &quot;操作指南&quot;\n第二步：設定資料夾的 index.md\ndoc/index.md：\n---\ntitle: &quot;文件&quot;\ndescription: &quot;技術文檔與操作指南&quot;\n---\n \n# 技術文檔中心 📚\nguides/index.md：\n---\ntitle: &quot;操作指南&quot;\ndescription: &quot;實用的技術操作指南&quot;\n---\n \n# 操作指南 📋\n第三步：設定檔案的 frontmatter\n每個 .md 檔案都加上中文 title：\n---\ntitle: &quot;GitHub Pages 自動部署 SOP&quot;\ndescription: &quot;從手動到自動的部署流程&quot;\ntags: [&quot;GitHub Pages&quot;, &quot;部署&quot;, &quot;CI/CD&quot;]\n---\n🎨 進階中文化技巧\n1. 標籤中文化\ntags: [&quot;GitHub&quot;, &quot;開發流程&quot;, &quot;最佳實踐&quot;, &quot;CI/CD&quot;, &quot;自動部署&quot;]\n2. 分類中文化\ncategory: &quot;技術文檔&quot;\nsection: &quot;部署指南&quot;\n3. 描述中文化\ndescription: &quot;完整的 GitHub Pages 自動化部署流程指南&quot;\n🔍 驗證中文化效果\n測試方法\n# 1. 本地測試\nnpm run preview\n \n# 2. 檢查導航\n# 訪問：http://localhost:3000\n# 查看左側導航是否顯示中文\n \n# 3. 測試所有頁面\n# 確認每個頁面標題都正確顯示中文\n檢查清單\n\n ✅ 主要資料夾顯示中文名稱\n ✅ 子資料夾顯示中文名稱\n ✅ 檔案標題顯示中文\n ✅ 頁面 meta 資訊中文化\n ✅ 標籤系統中文化\n\n🛠️ 故障排除\n常見問題\n❌ 導航仍顯示英文\n原因：缺少 frontmatter 或 index.md\n解決：確保每個資料夾都有 index.md 且包含 title\n❌ 中文顯示亂碼\n原因：檔案編碼問題\n解決：確保檔案使用 UTF-8 編碼保存\n❌ 部分頁面沒有中文化\n原因：忘記添加 frontmatter\n解決：檢查每個 .md 檔案是否都有 title\n📊 Quartz 導航顯示優先級\nQuartz 決定導航顯示名稱的優先級：\n\nfrontmatter title（最高優先級）\n第一個 H1 標題\n檔案名稱（最低優先級）\n\n🎯 最佳實踐\n命名規範\n# 資料夾 index.md\ntitle: &quot;文件&quot;           # 簡潔的中文名稱\ndescription: &quot;...&quot;      # 詳細的中文描述\n \n# 檔案 frontmatter\ntitle: &quot;GitHub Pages 自動部署 SOP&quot;  # 具體的功能描述\ndescription: &quot;...&quot;                  # 詳細說明\ntags: [&quot;部署&quot;, &quot;自動化&quot;]            # 中文標籤\n一致性原則\n\n用詞統一：相同概念使用相同中文詞彙\n風格一致：標題格式和長度保持一致\n分類清晰：使用邏輯清楚的中文分類\n\n🔄 批量處理腳本\n如果檔案很多，可以用腳本批量處理：\n# 查找所有缺少 frontmatter 的檔案\nfind content/ -name &quot;*.md&quot; -exec grep -L &quot;^---&quot; {} \\;\n \n# 為檔案批量添加 frontmatter（需要自訂）\n# 建議手動處理以確保準確性\n📈 維護建議\n定期檢查\n\n新增檔案時記得添加中文 frontmatter\n重新命名時同步更新 title\n定期檢查是否有遺漏的中文化項目\n\n文檔標準\n建立團隊的中文化標準：\n\n統一的詞彙表\n標題命名規範\n描述撰寫指南\n\n\n🎉 完成效果\n實施以上步驟後，你的 Quartz 網站將擁有：\n\n✅ 完全中文化的導航\n✅ 一致的中文用詞\n✅ 專業的文檔架構\n✅ 良好的使用者體驗\n\n現在你可以享受完全中文化的技術文檔網站了！\n\n本指南基於 Quartz 4.5.1，適用於所有中文化需求"},"doc/index":{"slug":"doc/index","filePath":"doc/index.md","title":"技術文件中心","links":["os-control/","guides/github-development-guide","guides/content-naming-standards","guides/github-pages-deployment"],"tags":["技術文件","標準化","操作程序","系統分析"],"content":"技術文件中心\n\n實用的技術指南與標準化操作程序，體現系統分析師的專業文件管理能力\n\n功能定位\n核心目標\n建立標準化的技術知識管理體系，將技術操作程序、系統配置方法、開發流程規範等進行系統化整理，形成可重複使用的技術資產。\n設計理念\n遵循「專精收斂而非擴散」的原則，聚焦最實用的技術知識和流程，避免資訊過載，確保每份文件都能直接解決實際問題。\n安全與保密機制\n文件分級策略\nPublic級別：開源工具使用、通用技術方法\nInternal級別：內部工具配置、專案特定流程  \nConfidential級別：核心技術架構、商業敏感配置\n\n審查流程\n\n內容安全檢查：識別並過濾敏感技術細節\n格式標準驗證：確保文件符合專業規範\n實用性評估：驗證操作程序的可執行性\n關聯性檢查：建立文件間的邏輯連結\n\n文件架構體系\n系統管理類\n作業系統控制技術\n功能範圍：\n\nWindows目錄鏡像與符號連結管理\n跨平台檔案系統整合方案\n開發環境自動化部署腳本\n系統權限與安全控制策略\n\n技術特點：\n\n提供可執行的批次檔案與腳本\n詳細的故障排除指南\n跨系統版本的相容性考量\n安全性與效能的平衡策略\n\n系統監控與診斷（規劃中）\n\n效能監控指標定義與收集\n系統健康檢查自動化腳本\n日誌分析與異常告警機制\n資源使用優化建議\n\n開發流程類\nGitHub開發流程規範\n標準化內容：\n\nCommit Message標準格式與最佳實踐\nPull Request流程與Code Review規範\n分支管理策略與版本控制規則\n自動化CI/CD管道配置指南\n\n品質保證：\n\n代碼品質檢查自動化\n測試覆蓋率要求與監控\n部署流程的標準化與安全性\n錯誤處理與回滾策略\n\n內容命名與組織規範\n標準化策略：\n\n英文路徑與中文顯示的雙軌制設計\n檔案命名的一致性與可維護性\nFrontmatter規範與metadata管理\n跨平台相容性考量\n\n部署運維類\nGitHub Pages自動部署SOP\n核心內容：\n\n雙倉庫分離的架構設計原理\nCI/CD自動化流程配置與優化\n部署失敗的診斷與故障排除\n效能監控與優化策略\n\n安全考量：\n\n密鑰管理與權限控制\n部署環境的隔離與保護\n敏感內容的自動化過濾\n災難恢復與備份策略\n\n容器化部署（規劃中）\n\nDocker映像檔的標準化建構流程\nKubernetes集群的部署與管理\n微服務監控與日誌聚合\n自動擴展與負載均衡配置\n\n工具配置類\n開發環境標準化\n配置管理：\n\nObsidian整合配置與外掛推薦\nVS Code擴展的標準化安裝與配置\nGit全域配置的最佳實踐\nNode.js開發環境的統一設定\n\n自動化腳本：\n\n環境初始化的一鍵部署腳本\n依賴套件的自動更新與管理\n配置檔案的備份與同步機制\n多專案間的配置一致性保證\n\n效能分析工具\n\n系統效能監控工具的配置與使用\n代碼品質分析工具的整合\n自動化測試工具的配置與運行\n持續整合工具的部署與維護\n\n文件品質標準\n結構化要求\n# 文件標題\n \n## 概述\n- 解決什麼問題\n- 適用的環境與條件\n- 預期達成的效果\n \n## 前置需求\n- 必要的軟體與工具\n- 權限與環境要求\n- 相關背景知識\n \n## 操作步驟\n- 詳細的執行步驟\n- 命令行指令與參數說明\n- 檢查點與驗證方法\n \n## 故障排除\n- 常見問題與解決方案\n- 錯誤訊息的診斷指南\n- 緊急處理程序\n \n## 相關資源\n- 官方文件連結\n- 相關工具與參考資料\n- 進階學習資源\n品質要求\n\n準確性：所有操作步驟經過實際驗證\n完整性：包含必要的背景知識與故障處理\n時效性：定期更新以反映最新的技術變化\n可讀性：清晰的結構與恰當的技術用語\n\n使用指南\n文件檢索策略\n\n分類瀏覽：按技術領域快速定位相關文件\n標籤搜尋：使用技術標籤進行精確查找\n全文搜索：關鍵字快速定位具體內容\n關聯導覽：透過文件間連結發現相關資源\n\n實踐建議\n\n循序漸進：從基礎文件開始，逐步深入專業內容\n實際操作：結合實際專案需求使用相關文件\n回饋改進：在使用過程中記錄問題與改進建議\n知識分享：將使用經驗回饋到文件改進中\n\n維護與更新機制\n內容審查週期\n\n月度審查：檢查文件的時效性與準確性\n季度更新：根據技術發展更新相關內容\n年度重構：重新評估文件架構與組織方式\n\n品質控制流程\n內容創建 → 技術審查 → 安全檢查 → 格式驗證 → 發布上線 → 使用回饋 → 持續改進\n\n貢獻機制\n\n問題回報：透過標準化流程回報文件問題\n改進建議：提供文件內容與結構的改進意見\n新文件貢獻：按照標準模板貢獻新的技術文件\n專家審查：邀請相關領域專家進行內容審查\n\n未來發展規劃\n短期目標（1-3個月）\n\n完善現有文件的標準化格式\n建立自動化的文件品質檢查機制\n增加更多實用的技術操作指南\n\n中期目標（3-6個月）\n\n建立文件間的智能關聯推薦系統\n發展基於AI的文件內容自動生成工具\n建立社群驅動的文件貢獻機制\n\n長期願景（6-12個月）\n\n形成行業標準的技術文件管理模式\n建立技術知識的智能化檢索與推薦系統\n發展跨組織的技術文件協作平台\n\n統計數據\n文件覆蓋範圍\n系統管理：40% (涵蓋Windows、Linux基礎操作)\n開發流程：35% (包含Git、CI/CD、代碼品質)\n部署運維：20% (GitHub Pages、容器化部署)\n工具配置：5% (開發環境、效能分析工具)\n\n使用統計\n\n總文件數量：15+篇\n月度檢視：200+次\n用戶回饋滿意度：90%+\n文件更新頻率：每週2-3次\n\n\n核心價值：提供實用、準確、及時的技術文件，支援高效的技術工作流程，並確保知識的有效傳承與積累。\n使用原則：文件是為了解決實際問題，而不是展示技術知識的複雜性。\n維護責任：PekoraTech SA Team - Documentation &amp; Standards\n品質目標：實用性優於完整性，準確性優於複雜性\n最後更新：2025-07-05"},"doc/os-control/index":{"slug":"doc/os-control/index","filePath":"doc/os-control/index.md","title":"作業系統控制","links":["doc/os-control/windows-directory-mirroring","GitHub-開發者精要指南","GitHub-Pages-自動部署-SOP","專案架構設計模式","VS-Code-開發環境設定","Git-配置優化","Terminal-效率提升","tags/作業系統","tags/系統管理","tags/Windows","tags/Linux","tags/macOS","tags/自動化","tags/腳本","tags/檔案系統","tags/權限管理","tags/開發環境"],"tags":["作業系統","系統管理","自動化","Windows","Linux","macOS","腳本","檔案系統","權限管理","開發環境"],"content":"作業系統控制技術 ⚙️\n\n跨平台系統管理與開發環境優化的核心技術\n\n🎯 技術範疇\n專注於作業系統層級的控制技術，提升開發效率與環境一致性。\n設計原則\n\nKISS 原則：保持簡潔，避免過度工程\n第一性原理：理解底層機制而非死記指令\n跨平台思維：考慮不同系統的相容性方案\n自動化優先：可重複執行的腳本化操作\n\n📂 技術分類\n🔗 檔案系統管理\nWindows 平台\n\n目錄鏡像技術\n\n符號連結 (Symbolic Link) 實作\n接合點 (Junction) 替代方案\n多電腦開發環境統一\n自動化批次檔案範例\n\n\n\nLinux/macOS 平台\n\n軟連結管理（計劃中）\n\nln -s 符號連結最佳實踐\n相對路徑與絕對路徑策略\n跨檔案系統連結考量\n\n\n\n🚀 程序與服務管理\nWindows 服務\n\n服務自動化管理（計劃中）\n\nsc 指令進階應用\nPowerShell 服務腳本\n開發環境服務編排\n\n\n\n系統程序\n\n程序監控與控制（計劃中）\n\ntasklist/taskkill 自動化\n記憶體使用監控\n效能瓶頸識別\n\n\n\n🔐 權限與安全\n存取控制\n\n檔案權限管理（計劃中）\n\nWindows ACL 設定\nLinux chmod/chown 最佳實踐\n安全性與便利性平衡\n\n\n\n環境隔離\n\n沙盒與容器技術（計劃中）\n\nWindows Sandbox 應用\nDocker 環境隔離\n開發環境污染防護\n\n\n\n🌐 網路與連線\n網路診斷\n\n連線問題排除（計劃中）\n\nping/tracert 深度分析\nnetstat 連線監控\n防火牆規則管理\n\n\n\n遠端存取\n\n遠端控制技術（計劃中）\n\nSSH 金鑰管理\nRDP 最佳化設定\nVPN 自動化連線\n\n\n\n🛠️ 實用工具集\n批次處理腳本\n📁 scripts/\n├── 📄 setup-dev-env.bat        # 開發環境快速設定\n├── 📄 cleanup-temp.bat         # 暫存檔案清理\n├── 📄 backup-projects.bat      # 專案檔案備份\n└── 📄 network-diagnostics.bat  # 網路問題診斷\n\nPowerShell 模組\n📁 powershell/\n├── 📄 FileSystemUtils.psm1     # 檔案系統操作\n├── 📄 ServiceManager.psm1      # 服務管理\n├── 📄 NetworkTools.psm1        # 網路工具\n└── 📄 SecurityUtils.psm1       # 安全性工具\n\n🎨 最佳實踐模式\n腳本設計原則\n\n錯誤處理：詳細的錯誤訊息與復原機制\n參數驗證：輸入參數的完整性檢查\n日誌記錄：操作過程的可追蹤記錄\n向後相容：考慮不同系統版本的相容性\n\n自動化策略\n\n冪等性：重複執行不會產生副作用\n原子性：要麼完全成功，要麼完全失敗\n可回復性：提供還原機制或回滾操作\n測試優先：在安全環境中驗證腳本\n\n🔄 相關技術連結\n開發流程整合\n\nGitHub 開發者精要指南：版本控制與系統整合\nGitHub Pages 自動部署 SOP：CI/CD 與系統自動化\n專案架構設計模式：系統層級的專案組織\n\n工具配置\n\nVS Code 開發環境設定：編輯器與系統整合\nGit 配置優化：版本控制系統設定\nTerminal 效率提升：命令列工具優化\n\n📊 技術成熟度\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n技術領域完成度優先級預計完成Windows 檔案系統✅ 100%🔥 高已完成Linux 檔案系統📝 0%🔥 高2025-07-15程序管理📝 0%⚡ 中2025-07-30網路診斷📝 0%⚡ 中2025-08-15安全管理📝 0%💡 低2025-09-01\n🚀 學習路徑建議\n初學者路徑\n\n\n檔案系統基礎\n\n理解絕對路徑與相對路徑\n掌握基本檔案操作指令\n學習權限概念\n\n\n\n自動化入門\n\n撰寫簡單的批次檔案\n理解環境變數的使用\n學習基本的錯誤處理\n\n\n\n實際應用\n\n建立個人開發環境腳本\n設定常用工具的自動化\n整合到日常工作流程\n\n\n\n進階學習\n\n\n跨平台技能\n\n掌握 Windows/Linux/macOS 差異\n學習通用的腳本設計模式\n理解不同系統的限制\n\n\n\n企業級應用\n\n大規模部署腳本設計\n安全性與合規性考量\n監控與維護策略\n\n\n\n💡 實戰案例\n開發環境標準化\n問題：團隊成員使用不同的開發環境配置\n解決：建立統一的環境設定腳本\nREM 範例：開發環境快速設定\n@echo off\necho 設定統一開發環境...\n \nREM 建立標準目錄結構\nmkdir D:\\PD_DEV\nmkdir D:\\PD_DEV\\projects\nmkdir D:\\PD_DEV\\tools\nmkdir D:\\PD_DEV\\temp\n \nREM 設定環境變數\nsetx DEV_ROOT &quot;D:\\PD_DEV&quot;\nsetx PATH &quot;%PATH%;D:\\PD_DEV\\tools&quot;\n \necho 開發環境設定完成！\n專案備份自動化\n問題：手動備份容易遺忘且不一致\n解決：自動化備份腳本與排程\nREM 範例：專案自動備份\n@echo off\nset BACKUP_DIR=E:\\Backup\\%date:~0,10%\nmkdir &quot;%BACKUP_DIR%&quot;\n \nrobocopy &quot;D:\\PD_DEV&quot; &quot;%BACKUP_DIR%&quot; /MIR /XD .git node_modules\necho 備份完成：%BACKUP_DIR%\n🏷️ 相關標籤\n作業系統 系統管理 Windows Linux macOS 自動化 腳本 檔案系統 權限管理 開發環境\n\n📝 更新記錄\nv1.0.0 (2025-07-05)\n\n✨ 建立作業系統控制技術分類架構\n📖 完成 Windows 目錄鏡像技術文檔\n🎯 規劃跨平台系統管理技術路線圖\n💡 提供學習路徑與實戰案例\n\n\n專注於實用的系統控制技術，提升開發效率與環境一致性"},"doc/os-control/windows-directory-mirroring":{"slug":"doc/os-control/windows-directory-mirroring","filePath":"doc/os-control/windows-directory-mirroring.md","title":"Windows 目錄鏡像技術","links":["批次處理自動化","開發環境標準化","備份策略優化","tags/Windows","tags/符號連結","tags/開發環境","tags/路徑管理","tags/自動化","tags/批次處理","tags/檔案系統","tags/Junction","tags/Symlink"],"tags":["Windows","符號連結","開發環境","路徑管理","自動化","批次處理","檔案系統","Junction","Symlink"],"content":"Windows 目錄鏡像技術 🔗\n\n透過符號連結技術實現跨電腦統一路徑管理的最佳實踐\n\n🎯 問題背景\n多電腦開發困境\n在多台電腦間進行開發時，常遇到以下問題：\n\n路徑不一致：不同電腦習慣使用不同磁碟機（C:、D:、E:、G:）\n腳本失效：絕對路徑導致批次檔案無法通用\n配置複雜：每台電腦都需要重新設定開發環境路徑\n協作困難：團隊成員無法使用統一的專案路徑\n\n解決方案概覽\nWindows 提供兩種「目錄鏡像」技術：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n技術類型權限需求功能特性適用場景符號連結 (Symbolic Link)管理員功能完整，支援相對路徑正式環境部署接合點 (Junction)一般使用者僅支援絕對路徑，資料夾專用日常開發使用\n💡 實作原理\n符號連結運作機制\n實際檔案位置：G:\\PD_DEV\\project-name\\\n鏡像存取路徑：D:\\PD_DEV\\project-name\\  ←→  G:\\PD_DEV\\project-name\\\n                    ↑                           ↑\n                符號連結指向              實際檔案儲存\n\n技術優勢\n\n透明存取：應用程式無法區分真實路徑與鏡像路徑\n即時同步：修改任一路徑下的檔案都會立即反映\n空間節省：不會複製檔案，僅建立指向關係\n效能優異：存取速度與直接存取相同\n\n🛠️ 實作步驟\n第一步：批次檔案準備\n為了自動化處理不同電腦的路徑映射，建立以下批次檔案：\n主電腦版本（G:\\PD_DEV → D:\\PD_DEV）\n@echo off\necho 設定開發資料夾映射\necho.\n \nREM 檢查是否以管理員身分執行\nnet session &gt;nul 2&gt;&amp;1\nif %errorLevel% == 0 (\n    echo 以管理員身分執行中...\n) else (\n    echo 警告：建議以管理員身分執行此批次檔案\n    echo.\n)\n \nREM 檢查目標資料夾是否存在\nif exist &quot;D:\\PD_DEV&quot; (\n    echo D:\\PD_DEV 已存在，請先備份或移除\n    pause\n    exit /b 1\n)\n \nREM 檢查來源資料夾\nif not exist &quot;G:\\PD_DEV&quot; (\n    echo 錯誤：來源資料夾 G:\\PD_DEV 不存在\n    pause\n    exit /b 1\n)\n \necho 建立符號連結：D:\\PD_DEV ---&gt; G:\\PD_DEV\necho.\n \nREM 建立目錄符號連結（需要管理員權限）\nmklink /D &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \nif %errorLevel% == 0 (\n    echo.\n    echo 成功建立符號連結！\n    echo 現在您可以透過 D:\\PD_DEV 存取 G:\\PD_DEV 的所有內容\n) else (\n    echo.\n    echo 符號連結建立失敗，嘗試建立接合點...\n    echo.\n \n    REM 如果符號連結失敗，嘗試建立接合點（不需要管理員權限）\n    mklink /J &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \n    if %errorLevel% == 0 (\n        echo 成功建立接合點！\n        echo 現在您可以透過 D:\\PD_DEV 存取 G:\\PD_DEV 的所有內容\n    ) else (\n        echo 建立失敗，請檢查權限或路徑\n    )\n)\n \necho.\necho 測試連結...\nif exist &quot;D:\\PD_DEV\\selfpagesource&quot; (\n    echo 測試成功：可以透過 D:\\PD_DEV 存取專案資料夾\n) else (\n    echo 測試失敗：無法透過 D:\\PD_DEV 存取專案資料夾\n)\n \npause\n副電腦版本（E:\\PD_DEV → D:\\PD_DEV）\n@echo off\necho 設定開發資料夾映射 (E: 版本)\necho.\n \nREM 檢查目標資料夾是否存在\nif exist &quot;D:\\PD_DEV&quot; (\n    echo D:\\PD_DEV 已存在，請先備份或移除\n    pause\n    exit /b 1\n)\n \nREM 檢查來源資料夾\nif not exist &quot;E:\\PD_DEV&quot; (\n    echo 錯誤：來源資料夾 E:\\PD_DEV 不存在\n    pause\n    exit /b 1\n)\n \necho 建立符號連結：D:\\PD_DEV ---&gt; E:\\PD_DEV\necho.\n \nREM 建立目錄符號連結\nmklink /D &quot;D:\\PD_DEV&quot; &quot;E:\\PD_DEV&quot;\n \nif %errorLevel% == 0 (\n    echo 成功建立符號連結！\n) else (\n    echo 符號連結建立失敗，嘗試建立接合點...\n    mklink /J &quot;D:\\PD_DEV&quot; &quot;E:\\PD_DEV&quot;\n \n    if %errorLevel% == 0 (\n        echo 成功建立接合點！\n    ) else (\n        echo 建立失敗，請檢查權限或路徑\n    )\n)\n \npause\n第二步：執行映射設定\n\n\n選擇對應的批次檔案\n\n主電腦：執行 setup_dev_mapping.bat\n副電腦：執行 setup_dev_mapping_E_drive.bat\n\n\n\n執行前準備\n# 檢查來源資料夾是否存在\ndir G:\\PD_DEV    # 主電腦\ndir E:\\PD_DEV    # 副電腦\n \n# 確認目標位置沒有衝突\ndir D:\\PD_DEV    # 應該顯示找不到檔案\n\n\n執行設定\n\n右鍵點擊批次檔案\n選擇「以系統管理員身分執行」\n按照提示完成設定\n\n\n\n第三步：驗證映射結果\n# 測試檔案存取\ndir D:\\PD_DEV\ndir D:\\PD_DEV\\selfpagesource\n \n# 檢查連結類型\ndir D:\\ | findstr PD_DEV\n# 應該顯示 &lt;SYMLINKD&gt; 或 &lt;JUNCTION&gt;\n \n# 測試檔案操作\necho test &gt; D:\\PD_DEV\\test.txt\ntype G:\\PD_DEV\\test.txt    # 主電腦\ntype E:\\PD_DEV\\test.txt    # 副電腦\ndel D:\\PD_DEV\\test.txt\n🔧 進階管理\n清理映射的批次檔案\n@echo off\necho 移除開發資料夾映射\necho.\n \nREM 檢查 D:\\PD_DEV 是否存在且為連結\nif not exist &quot;D:\\PD_DEV&quot; (\n    echo D:\\PD_DEV 不存在，無需移除\n    pause\n    exit /b 0\n)\n \nREM 檢查是否為符號連結或接合點\ndir &quot;D:\\PD_DEV&quot; | findstr &quot;&lt;SYMLINKD&gt;&quot; &gt;nul\nif %errorLevel% == 0 (\n    echo 偵測到符號連結\n    set LINK_TYPE=符號連結\n    goto remove_link\n)\n \ndir &quot;D:\\PD_DEV&quot; | findstr &quot;&lt;JUNCTION&gt;&quot; &gt;nul\nif %errorLevel% == 0 (\n    echo 偵測到接合點\n    set LINK_TYPE=接合點\n    goto remove_link\n)\n \necho D:\\PD_DEV 存在但不是符號連結或接合點\necho 為安全起見，不會刪除此資料夾\npause\nexit /b 1\n \n:remove_link\necho 即將移除 %LINK_TYPE%：D:\\PD_DEV\necho.\nset /p confirm=確定要繼續嗎？(Y/N):\nif /i not &quot;%confirm%&quot;==&quot;Y&quot; (\n    echo 操作取消\n    pause\n    exit /b 0\n)\n \nREM 移除符號連結或接合點\nrmdir &quot;D:\\PD_DEV&quot;\n \nif %errorLevel% == 0 (\n    echo 成功移除 %LINK_TYPE%\n) else (\n    echo 移除失敗，請檢查權限\n)\n \npause\n常用管理指令\n# 查看所有符號連結\ndir C:\\ /AL\ndir D:\\ /AL\n \n# 查看特定目錄的連結資訊\nfsutil reparsepoint query &quot;D:\\PD_DEV&quot;\n \n# 手動建立符號連結\nmklink /D &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \n# 手動建立接合點\nmklink /J &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \n# 手動移除連結\nrmdir &quot;D:\\PD_DEV&quot;\n⚠️ 注意事項與最佳實踐\n安全考量\n\n備份重要資料：設定前先備份現有的 D:\\PD_DEV（如果存在）\n權限管理：符號連結需要管理員權限，接合點則不需要\n路徑驗證：確保來源路徑存在且可存取\n\n使用限制\n\nWindows 版本：Windows Vista 以上支援符號連結\n檔案系統：目標磁碟機必須使用 NTFS 檔案系統\n網路位置：不建議對網路磁碟機使用符號連結\n\n故障排除\n常見錯誤及解決方案\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n錯誤訊息可能原因解決方法存取被拒權限不足以管理員身分執行目標已存在D:\\PD_DEV 已存在先移除或重新命名現有資料夾找不到來源來源路徑不存在確認 G: 或 E: 磁碟機路徑正確不支援的檔案系統FAT32 檔案系統轉換為 NTFS 或使用其他磁碟機\n🎯 實際應用場景\n開發環境統一\n情境：三台電腦的不同配置\n- 主機：G:\\PD_DEV\\project-name\\\n- 筆電：E:\\PD_DEV\\project-name\\\n- 公司：C:\\PD_DEV\\project-name\\\n\n解決：統一使用 D:\\PD_DEV\\project-name\\\n\n腳本通用性\nREM 原本：需要針對每台電腦修改路徑\ncd G:\\PD_DEV\\selfpagesource    REM 主機\ncd E:\\PD_DEV\\selfpagesource    REM 筆電\ncd C:\\PD_DEV\\selfpagesource    REM 公司\n \nREM 現在：所有電腦使用相同腳本\ncd D:\\PD_DEV\\selfpagesource    REM 通用\n配置檔案同步\n// VS Code settings.json 可以使用統一路徑\n{\n  &quot;terminal.integrated.cwd&quot;: &quot;D:\\\\PD_DEV&quot;,\n  &quot;git.defaultCloneDirectory&quot;: &quot;D:\\\\PD_DEV&quot;\n}\n🔄 相關技術比較\nWindows 檔案系統功能對比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n功能符號連結接合點硬連結快捷方式需要管理員權限✅❌❌❌支援資料夾✅✅❌✅支援檔案✅❌✅✅跨磁碟機✅✅❌✅透明存取✅✅✅❌相對路徑✅❌N/A❌\n選擇建議\n\n優先選擇：符號連結（功能最完整）\n備選方案：接合點（無需管理員權限）\n避免使用：快捷方式（應用程式支援度差）\n\n📚 延伸學習\n相關命令深入\n# mklink 完整語法\nmklink [[/d] | [/h] | [/j]] &lt;連結&gt; &lt;目標&gt;\n/d    建立目錄符號連結（預設為檔案）\n/h    建立硬連結而非符號連結\n/j    建立目錄接合點\n \n# fsutil 連結管理\nfsutil reparsepoint query &lt;路徑&gt;      # 查詢連結資訊\nfsutil reparsepoint delete &lt;路徑&gt;     # 刪除連結點\n進階應用\n\n批次處理自動化：結合 PowerShell 進行大量路徑映射\n開發環境標準化：團隊協作的路徑規範制定\n備份策略優化：利用符號連結簡化備份腳本\n\n🏷️ 相關標籤\nWindows 符號連結 開發環境 路徑管理 自動化 批次處理 檔案系統 Junction Symlink\n\n📝 更新記錄\nv1.0.0 (2025-07-05)\n\n✨ 建立 Windows 目錄鏡像技術完整指南\n🔧 提供自動化批次檔案實作\n📖 涵蓋符號連結與接合點技術對比\n⚠️ 詳細的注意事項與故障排除\n🎯 實際開發場景應用範例\n\n\n本文檔旨在解決多電腦開發環境路徑統一問題，提供可直接執行的自動化解決方案"},"index-backup":{"slug":"index-backup","filePath":"index-backup.md","title":"PekoraTech 🚀 技術知識庫","links":["daily-code/","daily-code/2025-06-28-ai-benchmark-optimization","daily-code/2025-06-27-chrome-extension-memory","daily-code/2025-06-26-flutter-state-management","projects/","projects/ai-development-suite","projects/game-system-evolution","projects/browser-extension-ecosystem","projects/flutter-cross-platform","tags/GameDev","tags/ChromeExtension","tags/Flutter","tags/Microservice","tags/Optimization"],"tags":["首頁","技術","開發者","GameDev","ChromeExtension","Flutter","Microservice","Optimization"],"content":"Welcome to PekoraTech 🎯\n\n“專精收斂而非擴散” - 從第一性原理思考，專注於深度而非廣度的技術探索\n\n\n  \n  \n  \n\n🎯 核心理念\n🧠 第一性原理思考\n\n需求本質：快速記錄技術心得 + 方便日後查找 + 自動整合專案經驗\n技術選擇：Markdown 原生 &gt; 複雜框架，現成工具 &gt; 重新發明輪子\n架構設計：內容分離、處理分離、部署分離\n\n⚡ KISS 原則實踐\ngraph LR\n    A[想法] --&gt; B[Markdown]\n    B --&gt; C[Quartz]\n    C --&gt; D[GitHub Pages]\n    D --&gt; E[世界分享]\n\n🎛️ 高內聚低耦合\n📝 內容層    - daily-code（日常心得）/ projects（深度分析）分離\n🔧 處理層    - 掃描、建置、部署功能獨立\n🚀 部署層    - 原始碼與靜態檔案分離\n\n\n🗂️ 內容導覽\n📅 每日程式碼\n\n像技術日記一樣快速記錄開發心得，沒有絕對規劃但方便查找\n\n最新文章：\n\nAI 基準測試優化心得\nChrome 擴展記憶體管理\nFlutter 狀態管理最佳實踐\n\n🎯 專案整合\n\n手動撰寫的深度技術分析，整合多個專案的思考與經驗\n\n| 專案類別         | 描述                                   | 狀態                 |\n| ---------------- | -------------------------------------- | -------------------- | --------- |\n| 🤖 AI 工具鏈 | AI 開發工具套件    | 🟢 活躍   |\n| 🎮 遊戲開發  | 遊戲系統架構演進   | 🟡 迭代中 |\n| 🧩 擴展開發  | 瀏覽器擴展生態系   | 🟢 活躍   |\n| 📱 移動開發  | Flutter 跨平台實踐 | 🔵 研究中 |\n\n🛠️ 技術棧概覽\n核心技術\n\n  🤖 AI/ML\n  🎮 Game Dev\n  🧩 Browser Ext\n  📱 Flutter\n  ⚡ Node.js\n  🐍 Python\n\n專案統計\n📊 總專案數量：12+\n🔥 活躍專案：5\n📈 迭代版本：20+\n🎯 核心領域：AI、遊戲、工具開發\n\n\n🎨 探索方式\n🔍 智能搜尋\n使用頂部搜尋框，支援：\n\n內容全文搜尋\n標籤過濾\n即時預覽\n\n🏷️ 標籤導覽\n點擊任何標籤探索相關內容：\n#AI GameDev ChromeExtension Flutter Microservice Optimization\n🌐 關係圖譜\n透過關係圖發現內容間的隱藏連結，找到意想不到的知識組合。\n📱 響應式設計\n完美支援桌面、平板、手機閱讀體驗。\n\n💡 設計哲學\n\n可維護性\n\n模組化設計：每個功能獨立可測\n配置外部化：設定與程式碼分離\n文件優先：程式碼即文件，文件即程式碼\n\n\n\n可擴展性\n\n插件化架構：Quartz 豐富的插件生態\nAPI 友善：預留未來 AI 整合介面\n版本控制：Git 為基礎的完整版本管理\n\n\n\n效能優化\n\n靜態生成：零伺服器成本，極速載入\nCDN 友善：全球快取，就近服務\n漸進式：增量建置，只處理變更內容\n\n\n\n🚀 最新動態\n本週焦點\n\n🔧 優化 AI 基準測試工具，提升 30% 效能\n🎮 重構遊戲系統架構，採用微服務模式\n🧩 發布巴哈姆特論壇助手 Chrome 擴展\n\n即將推出\n\n📝 AI 輔助的自動化文檔生成工具\n🎯 跨平台遊戲引擎抽象層\n💬 整合型開發者工具套件\n\n\n\n  🎯 目標願景\n  \n    建立一個符合個人思維模式的技術知識庫：\n    記錄 → 整理 → 分享 → 成長\n  \n  \n    &quot;善用工具，專注思考。讓技術服務於創造，而非被技術所束縛。&quot;\n  \n\n\n最後更新：2025-06-28 | 維護者：PekoraTech"},"index":{"slug":"index","filePath":"index.md","title":"SelfPageSource 技術文件化專案","links":["doc/","projects/","daily-code/","component/"],"tags":["技術文件","系統分析","知識管理"],"content":"SelfPageSource 技術文件化專案\n\n透過系統分析師視角，將專案理解轉換為可持續的開發歷程文件\n\n專案核心理念\n第一性原理思考\n\n資訊整理本質：從零散經驗提煉出可重複利用的知識體系\n知識傳承需求：將個人經驗轉化為團隊可共享的標準化文件\n安全平衡策略：在開放分享與創新保護之間找到最佳平衡點\n\nKISS原則與高內聚低耦合\n\n採用Quartz 4.0作為靜態網站生成器，避免重新造輪子\n內容組織遵循功能分離，各模組職責明確\n自動化流程減少人工干預，專注於內容創作\n\n內容架構導覽\n技術文件中心\n\n標準化技術文件與操作程序\n\n功能定位：補齊技術資料的標準化文件庫\n適用場景：技術操作標準程序、系統配置、開發工具指南、架構設計文件\n文件特性：結構化內容、版本控制、標準格式\n專案建置項目\n\n專案主軸建置文件，支援多專案共存管理\n\n功能定位：專案理解與分析的標準化記錄\n管理原則：專案間關係明確標示、建置流程標準化、專案狀態可追蹤\n安全機制：技術方法可公開，實作細節選擇性公開，創新核心嚴格保密\n時間分割內容\n\n以時間軸組織的日常開發記錄\n\n功能定位：日常開發經驗的系統化記錄\n重要原則：commit細寫記錄開發細節，對外文件需過濾敏感資訊\nMCP整合：透過claude或gemini cli自動整合每日內容\n可重用元件庫\n\n從歷史創作中萃取有價值的可重用元件\n\n功能定位：長遠計劃，建立技術資產庫\n價值體現：減少重複開發、提升開發效率、形成個人技術標準\n智財保護：展示思考過程，保護實作細節\n系統分析師工作流程\n專案理解階段\n\n讀取README.md：理解專案原始設計與目標\n架構分析：識別技術棧與依賴關係\n流程梳理：分析開發與部署流程\n問題識別：發現潛在風險與改進點\n\n文件轉換階段\n\n內容分類：依據功能特性分配至適當目錄\n標準化處理：統一文件格式、命名規則、標籤系統\n安全審查：識別敏感內容、應用保密策略、確保合規發布\n\n持續維護階段\n\n定期回顧：文件有效性檢查、技術棧更新同步、流程優化改進\n價值萃取：識別可重用元件、建立最佳實踐、形成技術標準\n\n安全與保密機制\n分級公開策略\n\n技術方法層級：可公開分享，促進技術交流\n實作細節層級：選擇性公開，保護競爭優勢\n創新核心層級：嚴格保密，維護智財價值\n\n自動化檢查流程\n\n關鍵字過濾機制\n敏感內容標記系統\n發布前審查程序\n\n技術架構\n核心技術棧\n\nQuartz 4.0：靜態網站生成器\nNode.js：執行環境\nTypeScript：類型安全開發\nGitHub Pages：免費網站託管\n\n自動化流程\n專案分析 → 內容分類 → 標準化處理 → 安全審查 → 自動發布\n\n開發指令\n常用操作\n# 開發模式\nnpm run dev              # 本地開發：http://localhost:8080\n \n# 建置與預覽  \nnpm run build-static     # 建置靜態檔案\nnpm run preview          # 靜態預覽：http://localhost:3000\n \n# 代碼品質\nnpm run check            # 格式檢查\nnpm run format           # 自動格式化\n \n# 發布流程\nnpm run format &amp;&amp; git add . &amp;&amp; git commit -m &quot;類型: 描述&quot; &amp;&amp; git push origin main\n持續改進計劃\n短期目標\n\n完善MCP自動化工作流程\n建立敏感內容自動檢測機制\n優化文件分類與檢索系統\n\n中期目標\n\n建立技術元件標準化流程\n發展智財保護自動化工具\n形成可複製的SA工作模式\n\n長期願景\n\n建立行業標準的技術文件化流程\n發展開源與商業平衡的最佳實踐\n形成系統分析師專業工具鏈\n\n貢獻原則\n提交規範\nfeat: 新增功能或內容\ndocs: 文件更新  \nfix: 問題修正\nstyle: 格式調整\nrefactor: 架構重構\nsecurity: 安全相關更新\n品質標準\n\n遵循第一性原理思考\n確保高內聚低耦合設計\n通過安全審查機制\n符合專業文件規範\n\n\n專案目標：建立符合系統分析師工作流程的技術文件化平台，平衡知識分享與創新保護，實現可持續的技術資產積累。\n維護團隊：PekoraTech SA Team\n最後更新：2025-07-05\n安全等級：公開（已過濾敏感內容）"},"projects/browser-extension-ecosystem":{"slug":"projects/browser-extension-ecosystem","filePath":"projects/browser-extension-ecosystem.md","title":"瀏覽器擴展生態系統建構","links":["daily-code/2025-06-25-service-worker-optimization","daily-code/2025-06-20-cors-handling","daily-code/2025-06-15-react-extension-patterns","projects/ai-development-suite","projects/game-system-evolution","daily-code/","tags/ChromeExtension","tags/AI","tags/Architecture","tags/Microservices","tags/WebDevelopment"],"tags":["Chrome-Extension","Browser","Architecture","專案整合","ChromeExtension","AI","Microservices","WebDevelopment"],"content":"🧩 瀏覽器擴展生態系統建構\n\n專案整合：test-baba-chrome-extension-tools + test-ai-memory 的架構演進與設計思考\n\n🎯 專案背景\n演進歷程\n從單純的論壇工具發展為完整的 AI 輔助瀏覽器生態系統：\ntimeline\n    title 擴展開發演進歷程\n\n    2024-Q1 : 巴哈姆特論壇助手\n           : 基礎內容抓取\n           : 簡單 UI 優化\n\n    2024-Q2 : 功能擴展\n           : 自動回覆機制\n           : 數據持久化\n\n    2024-Q3 : AI 整合嘗試\n           : 接入 OpenAI API\n           : 智能內容分析\n\n    2024-Q4 : 微服務架構\n           : Ollama 代理服務\n           : 跨域解決方案\n\n    2025-Q1 : 生態系統化\n           : 多擴展協作\n           : 統一管理後台\n\n核心專案結構\n瀏覽器擴展生態系\n├── 🏪 baha-forum-assistant/          # 論壇工具擴展\n│   ├── manifest.json                 # V3 Manifest\n│   ├── background/                   # 背景腳本\n│   ├── content/                      # 內容腳本\n│   └── popup/                        # 彈出界面\n├── 🤖 ai-chat-extension/             # AI 聊天擴展\n│   ├── components/                   # React 組件\n│   ├── hooks/                        # 自定義 Hooks\n│   └── services/                     # API 服務\n└── 🔧 microservice-summary/          # 後端微服務\n    ├── ollama-proxy/                 # Ollama 代理\n    ├── file-processor/               # 檔案處理\n    └── swagger-docs/                 # API 文檔\n\n\n🏗️ 架構設計深度解析\n1. Manifest V3 遷移策略\n核心變更點\n// manifest.json - 現代化配置\n{\n  &quot;manifest_version&quot;: 3,\n  &quot;name&quot;: &quot;PekoraTech Browser Suite&quot;,\n  &quot;version&quot;: &quot;2.0.0&quot;,\n  &quot;description&quot;: &quot;AI-powered browser extension ecosystem&quot;,\n \n  &quot;permissions&quot;: [&quot;storage&quot;, &quot;activeTab&quot;, &quot;scripting&quot;],\n \n  &quot;host_permissions&quot;: [&quot;forum.gamer.com.tw/*&quot;, &quot;https://localhost:8000/*&quot;],\n \n  &quot;background&quot;: {\n    &quot;service_worker&quot;: &quot;background/worker.js&quot;\n  },\n \n  &quot;content_scripts&quot;: [\n    {\n      &quot;matches&quot;: [&quot;forum.gamer.com.tw/*&quot;],\n      &quot;js&quot;: [&quot;content/forum-enhancer.js&quot;],\n      &quot;css&quot;: [&quot;styles/forum-theme.css&quot;]\n    }\n  ],\n \n  &quot;action&quot;: {\n    &quot;default_popup&quot;: &quot;popup/index.html&quot;,\n    &quot;default_title&quot;: &quot;PekoraTech Tools&quot;\n  }\n}\nService Worker 最佳實踐\n// background/worker.js - 高效的背景處理\nclass ExtensionServiceWorker {\n  constructor() {\n    this.initializeEventListeners()\n    this.setupPeriodicTasks()\n  }\n \n  initializeEventListeners() {\n    // 安裝事件 - 初始化設定\n    chrome.runtime.onInstalled.addListener((details) =&gt; {\n      if (details.reason === &quot;install&quot;) {\n        this.handleFirstInstall()\n      } else if (details.reason === &quot;update&quot;) {\n        this.handleUpdate(details.previousVersion)\n      }\n    })\n \n    // 訊息通信 - 統一處理\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) =&gt; {\n      this.handleMessage(message, sender)\n        .then(sendResponse)\n        .catch((error) =&gt; sendResponse({ error: error.message }))\n      return true // 保持通道開啟\n    })\n \n    // 標籤頁事件 - 上下文感知\n    chrome.tabs.onActivated.addListener(this.handleTabActivated.bind(this))\n    chrome.tabs.onUpdated.addListener(this.handleTabUpdated.bind(this))\n  }\n \n  async handleMessage(message, sender) {\n    const { type, payload } = message\n \n    switch (type) {\n      case &quot;AI_CHAT_REQUEST&quot;:\n        return await this.processAiRequest(payload)\n \n      case &quot;FORUM_DATA_EXTRACT&quot;:\n        return await this.extractForumData(payload)\n \n      case &quot;STORAGE_SYNC&quot;:\n        return await this.syncUserData(payload)\n \n      default:\n        throw new Error(`Unknown message type: ${type}`)\n    }\n  }\n \n  async processAiRequest(payload) {\n    // 代理到 Ollama 微服務\n    const response = await fetch(&quot;http://localhost:8000/api/chat&quot;, {\n      method: &quot;POST&quot;,\n      headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },\n      body: JSON.stringify({\n        model: &quot;llama3.1&quot;,\n        messages: payload.messages,\n        options: { temperature: 0.7 },\n      }),\n    })\n \n    if (!response.ok) {\n      throw new Error(`AI service error: ${response.status}`)\n    }\n \n    return await response.json()\n  }\n}\n \n// 初始化 Service Worker\nnew ExtensionServiceWorker()\n2. 內容腳本注入系統\n智能注入策略\n// content/injection-manager.js - 動態注入管理\nclass ContentInjectionManager {\n  constructor() {\n    this.injectedFeatures = new Set()\n    this.pageContext = this.analyzePageContext()\n    this.initializeBasedOnContext()\n  }\n \n  analyzePageContext() {\n    const url = window.location.href\n    const hostname = window.location.hostname\n \n    return {\n      isBahaForum: hostname === &quot;forum.gamer.com.tw&quot;,\n      isArticlePage: url.includes(&quot;/C.php&quot;),\n      isBoardPage: url.includes(&quot;/B.php&quot;),\n      hasCommentSection: !!document.querySelector(&quot;.c-post&quot;),\n      userLoggedIn: this.checkUserLoginStatus(),\n    }\n  }\n \n  initializeBasedOnContext() {\n    if (this.pageContext.isBahaForum) {\n      this.injectForumEnhancements()\n    }\n \n    // 通用 AI 輔助功能\n    this.injectAiAssistant()\n \n    // 基於頁面類型的特殊功能\n    if (this.pageContext.isArticlePage) {\n      this.injectArticleAnalyzer()\n    }\n  }\n \n  injectForumEnhancements() {\n    if (this.injectedFeatures.has(&quot;forum&quot;)) return\n \n    // 注入論壇增強功能\n    this.addForumToolbar()\n    this.enhanceCommentSystem()\n    this.addQuickReplyFeatures()\n \n    this.injectedFeatures.add(&quot;forum&quot;)\n    console.log(&quot;🏪 Forum enhancements injected&quot;)\n  }\n \n  injectAiAssistant() {\n    if (this.injectedFeatures.has(&quot;ai&quot;)) return\n \n    // 創建 AI 助手浮動按鈕\n    const aiButton = this.createAiButton()\n    document.body.appendChild(aiButton)\n \n    // 監聽文字選取事件\n    document.addEventListener(&quot;mouseup&quot;, this.handleTextSelection.bind(this))\n \n    this.injectedFeatures.add(&quot;ai&quot;)\n    console.log(&quot;🤖 AI assistant injected&quot;)\n  }\n \n  createAiButton() {\n    const button = document.createElement(&quot;div&quot;)\n    button.className = &quot;pekora-ai-button&quot;\n    button.innerHTML = `\n      &lt;div class=&quot;ai-icon&quot;&gt;🤖&lt;/div&gt;\n      &lt;div class=&quot;ai-menu&quot; style=&quot;display: none;&quot;&gt;\n        &lt;button data-action=&quot;summarize&quot;&gt;📄 摘要&lt;/button&gt;\n        &lt;button data-action=&quot;translate&quot;&gt;🌐 翻譯&lt;/button&gt;\n        &lt;button data-action=&quot;explain&quot;&gt;💡 解釋&lt;/button&gt;\n        &lt;button data-action=&quot;chat&quot;&gt;💬 對話&lt;/button&gt;\n      &lt;/div&gt;\n    `\n \n    // 添加樣式\n    button.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      z-index: 10000;\n      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n      border-radius: 50%;\n      width: 60px;\n      height: 60px;\n      cursor: pointer;\n      box-shadow: 0 4px 20px rgba(0,0,0,0.3);\n      transition: all 0.3s ease;\n    `\n \n    // 事件處理\n    button.addEventListener(&quot;click&quot;, this.toggleAiMenu.bind(this))\n \n    return button\n  }\n \n  async handleTextSelection() {\n    const selectedText = window.getSelection().toString().trim()\n    if (selectedText.length &gt; 10) {\n      // 顯示快速 AI 操作選項\n      this.showQuickActions(selectedText)\n    }\n  }\n}\n \n// 初始化內容注入管理器\nnew ContentInjectionManager()\n3. 微服務後端架構\nOllama 代理服務\n# microservice-summary/main.py - FastAPI 微服務\nfrom fastapi import FastAPI, HTTPException, UploadFile, File\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\nimport ollama\nimport asyncio\nfrom typing import List, Optional\n \napp = FastAPI(\n    title=&quot;PekoraTech AI Service&quot;,\n    description=&quot;Ollama 代理服務，為瀏覽器擴展提供 AI 功能&quot;,\n    version=&quot;2.0.0&quot;\n)\n \n# CORS 設定 - 允許擴展訪問\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[&quot;chrome-extension://*&quot;, &quot;http://localhost:*&quot;],\n    allow_credentials=True,\n    allow_methods=[&quot;*&quot;],\n    allow_headers=[&quot;*&quot;],\n)\n \nclass ChatRequest(BaseModel):\n    model: str = &quot;llama3.1&quot;\n    messages: List[dict]\n    options: Optional[dict] = {}\n \nclass SummaryRequest(BaseModel):\n    text: str\n    style: str = &quot;concise&quot;  # concise, detailed, bullet_points\n    language: str = &quot;zh-TW&quot;\n \n@app.post(&quot;/api/chat&quot;)\nasync def chat_completion(request: ChatRequest):\n    &quot;&quot;&quot;AI 對話完成接口&quot;&quot;&quot;\n    try:\n        # 使用 Ollama 進行推理\n        response = await asyncio.to_thread(\n            ollama.chat,\n            model=request.model,\n            messages=request.messages,\n            options=request.options\n        )\n \n        return {\n            &quot;success&quot;: True,\n            &quot;response&quot;: response[&#039;message&#039;][&#039;content&#039;],\n            &quot;model_used&quot;: request.model,\n            &quot;tokens_used&quot;: response.get(&#039;eval_count&#039;, 0)\n        }\n \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n \n@app.post(&quot;/api/summarize&quot;)\nasync def text_summarization(request: SummaryRequest):\n    &quot;&quot;&quot;智能文本摘要&quot;&quot;&quot;\n    try:\n        # 根據風格調整提示\n        style_prompts = {\n            &quot;concise&quot;: &quot;請用 1-2 句話簡潔總結以下內容：&quot;,\n            &quot;detailed&quot;: &quot;請提供詳細的結構化摘要，包含要點分析：&quot;,\n            &quot;bullet_points&quot;: &quot;請用條列式要點總結以下內容：&quot;\n        }\n \n        prompt = f&quot;{style_prompts.get(request.style, style_prompts[&#039;concise&#039;])}\\n\\n{request.text}&quot;\n \n        response = await asyncio.to_thread(\n            ollama.generate,\n            model=&quot;llama3.1&quot;,\n            prompt=prompt,\n            options={&quot;temperature&quot;: 0.3}\n        )\n \n        return {\n            &quot;success&quot;: True,\n            &quot;summary&quot;: response[&#039;response&#039;],\n            &quot;original_length&quot;: len(request.text),\n            &quot;compression_ratio&quot;: len(response[&#039;response&#039;]) / len(request.text)\n        }\n \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n \n@app.post(&quot;/api/analyze/file&quot;)\nasync def analyze_file(file: UploadFile = File(...)):\n    &quot;&quot;&quot;檔案內容分析&quot;&quot;&quot;\n    try:\n        content = await file.read()\n \n        # 根據檔案類型處理\n        if file.content_type == &quot;application/pdf&quot;:\n            text = extract_pdf_text(content)\n        elif file.content_type.startswith(&quot;text/&quot;):\n            text = content.decode(&#039;utf-8&#039;)\n        else:\n            raise HTTPException(status_code=400, detail=&quot;不支援的檔案格式&quot;)\n \n        # AI 分析\n        analysis_prompt = f&quot;&quot;&quot;\n        請分析以下文件內容並提供：\n        1. 主要主題和關鍵概念\n        2. 內容結構分析\n        3. 重要資訊摘要\n        4. 潛在問題或改進建議\n \n        文件內容：\n        {text[:4000]}  # 限制長度避免超出 token 限制\n        &quot;&quot;&quot;\n \n        response = await asyncio.to_thread(\n            ollama.generate,\n            model=&quot;llama3.1&quot;,\n            prompt=analysis_prompt,\n            options={&quot;temperature&quot;: 0.5}\n        )\n \n        return {\n            &quot;success&quot;: True,\n            &quot;filename&quot;: file.filename,\n            &quot;file_size&quot;: len(content),\n            &quot;analysis&quot;: response[&#039;response&#039;]\n        }\n \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n \n# 健康檢查\n@app.get(&quot;/health&quot;)\nasync def health_check():\n    &quot;&quot;&quot;服務健康檢查&quot;&quot;&quot;\n    try:\n        # 檢查 Ollama 服務\n        models = ollama.list()\n        return {\n            &quot;status&quot;: &quot;healthy&quot;,\n            &quot;ollama_available&quot;: True,\n            &quot;available_models&quot;: [model[&#039;name&#039;] for model in models[&#039;models&#039;]]\n        }\n    except:\n        return {\n            &quot;status&quot;: &quot;unhealthy&quot;,\n            &quot;ollama_available&quot;: False,\n            &quot;error&quot;: &quot;Ollama service unavailable&quot;\n        }\n\n📊 技術債務與架構演進\n當前技術債務\ngraph TD\n    A[技術債務分析] --&gt; B[高優先級]\n    A --&gt; C[中優先級]\n    A --&gt; D[低優先級]\n\n    B --&gt; B1[CORS 配置複雜]\n    B --&gt; B2[錯誤處理不一致]\n    B --&gt; B3[Storage API 濫用]\n\n    C --&gt; C1[UI 組件重複]\n    C --&gt; C2[配置檔案分散]\n    C --&gt; C3[測試覆蓋率低]\n\n    D --&gt; D1[程式碼註釋不足]\n    D --&gt; D2[版本控制策略]\n    D --&gt; D3[文檔更新滯後]\n\n重構計畫\n階段一：核心架構優化 (2週)\n// 統一的通信層 - communication/bridge.ts\nexport class ExtensionBridge {\n  private static instance: ExtensionBridge\n  private messageHandlers = new Map&lt;string, Function&gt;()\n \n  static getInstance(): ExtensionBridge {\n    if (!ExtensionBridge.instance) {\n      ExtensionBridge.instance = new ExtensionBridge()\n    }\n    return ExtensionBridge.instance\n  }\n \n  async sendToBackground&lt;T&gt;(type: string, payload?: any): Promise&lt;T&gt; {\n    return new Promise((resolve, reject) =&gt; {\n      chrome.runtime.sendMessage({ type, payload }, (response) =&gt; {\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message))\n        } else if (response?.error) {\n          reject(new Error(response.error))\n        } else {\n          resolve(response)\n        }\n      })\n    })\n  }\n \n  registerHandler(type: string, handler: Function): void {\n    this.messageHandlers.set(type, handler)\n  }\n \n  async handleMessage(message: any): Promise&lt;any&gt; {\n    const handler = this.messageHandlers.get(message.type)\n    if (!handler) {\n      throw new Error(`No handler for message type: ${message.type}`)\n    }\n    return await handler(message.payload)\n  }\n}\n階段二：UI 組件系統 (3週)\n// 可重用的 React 組件庫\n// components/ui/AiChatWidget.tsx\nimport React, { useState, useEffect } from &#039;react&#039;;\nimport { ExtensionBridge } from &#039;../communication/bridge&#039;;\n \ninterface AiChatWidgetProps {\n  initialMessage?: string;\n  model?: string;\n  theme?: &#039;light&#039; | &#039;dark&#039;;\n}\n \nexport const AiChatWidget: React.FC&lt;AiChatWidgetProps&gt; = ({\n  initialMessage = &quot;&quot;,\n  model = &quot;llama3.1&quot;,\n  theme = &quot;light&quot;\n}) =&gt; {\n  const [messages, setMessages] = useState&lt;Array&lt;{role: string, content: string}&gt;&gt;([]);\n  const [input, setInput] = useState(initialMessage);\n  const [loading, setLoading] = useState(false);\n \n  const bridge = ExtensionBridge.getInstance();\n \n  const sendMessage = async () =&gt; {\n    if (!input.trim()) return;\n \n    const userMessage = { role: &#039;user&#039;, content: input };\n    setMessages(prev =&gt; [...prev, userMessage]);\n    setInput(&#039;&#039;);\n    setLoading(true);\n \n    try {\n      const response = await bridge.sendToBackground(&#039;AI_CHAT_REQUEST&#039;, {\n        model,\n        messages: [...messages, userMessage]\n      });\n \n      setMessages(prev =&gt; [...prev, {\n        role: &#039;assistant&#039;,\n        content: response.response\n      }]);\n    } catch (error) {\n      console.error(&#039;AI Chat Error:&#039;, error);\n      // 錯誤處理...\n    } finally {\n      setLoading(false);\n    }\n  };\n \n  return (\n    &lt;div className={`ai-chat-widget ${theme}`}&gt;\n      &lt;div className=&quot;messages&quot;&gt;\n        {messages.map((msg, idx) =&gt; (\n          &lt;div key={idx} className={`message ${msg.role}`}&gt;\n            {msg.content}\n          &lt;/div&gt;\n        ))}\n        {loading &amp;&amp; &lt;div className=&quot;loading&quot;&gt;🤖 思考中...&lt;/div&gt;}\n      &lt;/div&gt;\n \n      &lt;div className=&quot;input-area&quot;&gt;\n        &lt;input\n          value={input}\n          onChange={(e) =&gt; setInput(e.target.value)}\n          onKeyDown={(e) =&gt; e.key === &#039;Enter&#039; &amp;&amp; sendMessage()}\n          placeholder=&quot;輸入訊息...&quot;\n        /&gt;\n        &lt;button onClick={sendMessage} disabled={loading}&gt;\n          發送\n        &lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n階段三：配置管理系統 (1週)\n// config/ConfigManager.ts - 統一配置管理\ninterface ExtensionConfig {\n  ai: {\n    defaultModel: string\n    apiEndpoint: string\n    temperature: number\n  }\n  ui: {\n    theme: &quot;light&quot; | &quot;dark&quot;\n    language: string\n    animations: boolean\n  }\n  features: {\n    autoSummarize: boolean\n    smartReply: boolean\n    voiceInput: boolean\n  }\n}\n \nexport class ConfigManager {\n  private static config: ExtensionConfig\n \n  static async load(): Promise&lt;ExtensionConfig&gt; {\n    const stored = await chrome.storage.sync.get(&quot;config&quot;)\n \n    ConfigManager.config = {\n      ...ConfigManager.getDefaultConfig(),\n      ...stored.config,\n    }\n \n    return ConfigManager.config\n  }\n \n  static async save(updates: Partial&lt;ExtensionConfig&gt;): Promise&lt;void&gt; {\n    ConfigManager.config = { ...ConfigManager.config, ...updates }\n    await chrome.storage.sync.set({ config: ConfigManager.config })\n  }\n \n  static get(): ExtensionConfig {\n    return ConfigManager.config\n  }\n \n  private static getDefaultConfig(): ExtensionConfig {\n    return {\n      ai: {\n        defaultModel: &quot;llama3.1&quot;,\n        apiEndpoint: &quot;http://localhost:8000&quot;,\n        temperature: 0.7,\n      },\n      ui: {\n        theme: &quot;light&quot;,\n        language: &quot;zh-TW&quot;,\n        animations: true,\n      },\n      features: {\n        autoSummarize: true,\n        smartReply: false,\n        voiceInput: false,\n      },\n    }\n  }\n}\n\n🎯 效能優化實踐\n記憶體管理策略\n// 智能記憶體管理\nclass MemoryManager {\n  constructor() {\n    this.cache = new Map();\n    this.maxCacheSize = 100;\n    this.cleanupInterval = 5 * 60 * 1000; // 5分鐘\n \n    this.startCleanupTimer();\n    this.monitorMemoryUsage();\n  }\n \n  set(key, value, ttl = 300000) { // 預設 5分鐘 TTL\n    if (this.cache.size &gt;= this.maxCacheSize) {\n      this.evictOldest();\n    }\n \n    this.cache.set(key, {\n      value,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n \n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) return null;\n \n    if (Date.now() - item.timestamp &gt; item.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n \n    return item.value;\n  }\n \n  evictOldest() {\n    const oldest = Array.from(this.cache.entries())\n      .sort(([,a], [,b]) =&gt; a.timestamp - b.timestamp)[0];\n \n    if (oldest) {\n      this.cache.delete(oldest[0]);\n    }\n  }\n \n  async monitorMemoryUsage() {\n    if (&#039;memory&#039; in performance) {\n      const usage = (performance as any).memory;\n      console.log(`記憶體使用: ${(usage.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`);\n \n      // 記憶體使用過高時清理快取\n      if (usage.usedJSHeapSize &gt; 50 * 1024 * 1024) { // 50MB\n        this.clearExpired();\n      }\n    }\n  }\n}\n非同步處理優化\n// 批次處理和防抖動\nclass BatchProcessor {\n  constructor(processor, batchSize = 10, delay = 1000) {\n    this.processor = processor\n    this.batchSize = batchSize\n    this.delay = delay\n    this.queue = []\n    this.timeoutId = null\n  }\n \n  add(item) {\n    this.queue.push(item)\n \n    if (this.queue.length &gt;= this.batchSize) {\n      this.flush()\n    } else {\n      this.scheduleFlush()\n    }\n  }\n \n  scheduleFlush() {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId)\n    }\n \n    this.timeoutId = setTimeout(() =&gt; {\n      this.flush()\n    }, this.delay)\n  }\n \n  async flush() {\n    if (this.queue.length === 0) return\n \n    const batch = this.queue.splice(0, this.batchSize)\n \n    try {\n      await this.processor(batch)\n    } catch (error) {\n      console.error(&quot;批次處理失敗:&quot;, error)\n      // 重試邏輯...\n    }\n \n    // 繼續處理剩餘項目\n    if (this.queue.length &gt; 0) {\n      this.scheduleFlush()\n    }\n  }\n}\n\n📈 監控與分析\n效能指標儀表板\n// analytics/PerformanceTracker.js\nclass PerformanceTracker {\n  constructor() {\n    this.metrics = {\n      extensionLoad: 0,\n      apiResponseTimes: [],\n      userInteractions: 0,\n      errorCounts: {},\n      memoryUsage: [],\n    }\n \n    this.startTracking()\n  }\n \n  trackApiCall(endpoint, duration) {\n    this.metrics.apiResponseTimes.push({\n      endpoint,\n      duration,\n      timestamp: Date.now(),\n    })\n \n    // 只保留最近 1000 次記錄\n    if (this.metrics.apiResponseTimes.length &gt; 1000) {\n      this.metrics.apiResponseTimes.shift()\n    }\n  }\n \n  trackError(error, context) {\n    const key = `${error.name}:${context}`\n    this.metrics.errorCounts[key] = (this.metrics.errorCounts[key] || 0) + 1\n \n    // 發送到分析服務\n    this.sendAnalytics(&quot;error&quot;, { error: error.message, context })\n  }\n \n  generateReport() {\n    const avgResponseTime =\n      this.metrics.apiResponseTimes.length &gt; 0\n        ? this.metrics.apiResponseTimes.reduce((sum, item) =&gt; sum + item.duration, 0) /\n          this.metrics.apiResponseTimes.length\n        : 0\n \n    return {\n      performance: {\n        avgApiResponseTime: avgResponseTime,\n        totalInteractions: this.metrics.userInteractions,\n        errorRate: Object.values(this.metrics.errorCounts).reduce((sum, count) =&gt; sum + count, 0),\n      },\n      recommendations: this.generateRecommendations(),\n    }\n  }\n \n  generateRecommendations() {\n    const recommendations = []\n    const report = this.generateReport()\n \n    if (report.performance.avgApiResponseTime &gt; 2000) {\n      recommendations.push({\n        type: &quot;performance&quot;,\n        message: &quot;API 回應時間過長，建議優化後端處理或增加快取&quot;,\n      })\n    }\n \n    if (report.performance.errorRate &gt; 10) {\n      recommendations.push({\n        type: &quot;reliability&quot;,\n        message: &quot;錯誤率過高，需要檢查錯誤處理機制&quot;,\n      })\n    }\n \n    return recommendations\n  }\n}\n\n🚀 未來發展規劃\n短期目標 (1-2個月)\n\n 統一身份認證系統 - 跨擴展的用戶狀態同步\n 可視化設定介面 - 使用者友善的配置管理\n 擴展商店上架 - 完成 Chrome Web Store 審核\n\n中期目標 (3-6個月)\n\n 多瀏覽器支援 - Firefox、Edge、Safari 適配\n 雲端同步功能 - 跨設備設定同步\n 插件市場 - 第三方開發者生態\n\n長期願景 (6-12個月)\n\n AI 模型本地化 - WebAssembly AI 推理\n 隱私增強技術 - 零知識證明和端到端加密\n 開源生態系統 - 建立開發者社群\n\n\n💭 設計哲學反思\n第一性原理應用\n\n問題本質：瀏覽器與 AI 的障礙是跨域限制，不是技術複雜性\n解決方案：微服務代理 + 統一通信層，而非重新發明輪子\n價值創造：提升使用者瀏覽體驗，而非炫技\n\nKISS 原則體現\n\n選擇現有工具：FastAPI + Ollama，而非自建 AI 服務\n最小化複雜性：統一的訊息機制，而非多種通信方式\n漸進式增強：基礎功能先行，高級功能後續添加\n\n高內聚低耦合實踐\n擴展層（UI） ⟷ 通信層（Bridge） ⟷ 服務層（Microservice）\n     ↓              ↓                    ↓\n  組件獨立        協議統一              API 標準\n\n\n📚 相關資源與學習\n技術文檔\n\nChrome Extension Manifest V3\nFastAPI 官方文檔\nOllama API 參考\n\n最佳實踐\n\nService Worker 最佳化\nCORS 處理策略\nReact 擴展開發模式\n\n知識連結\n\n與 AI 開發工具套件 共享 API 設計\n可整合到 遊戲系統 作為管理工具\n為 每日開發 提供實時輔助\n\n\n🎯 專案狀態：活躍開發中 | 📊 程式碼覆蓋率：75% | 🚀 下次發布：2025-07-15\nChromeExtension AI Architecture Microservices WebDevelopment"},"projects/calu-app-gradio-toolkit":{"slug":"projects/calu-app-gradio-toolkit","filePath":"projects/calu-app-gradio-toolkit.md","title":"Calu-app - Gradio多功能工具箱實驗專案","links":[],"tags":["Gradio","AI整合","Docker","Ollama","Web工具","實驗開發"],"content":"Calu-app - Gradio多功能工具箱實驗專案\n\n從實用工具需求出發，探索Gradio + AI + Docker技術整合的可行性與最佳實踐\n\n專案定位與核心價值\n實驗性質定義\nCalu-app是一個技術驗證型專案，主要目標不在於創造完美的產品，而在於探索和驗證現代Web工具開發的技術可行性：\n核心驗證目標：\n\nGradio框架在實用工具開發中的適用性\n本地AI模型(Ollama)與Web應用的整合模式\nDocker容器化對於Python Web應用的部署價值\n多功能整合式工具的用戶體驗設計\n\n技術選型邏輯：\n實用性優先 → Gradio (零前端開發)\nAI能力整合 → Ollama (本地化，隱私安全)\n部署簡化 → Docker (環境一致性)\n開發效率 → Python生態系統\n\n第一性原理分析\n工具本質：解決日常計算與資訊處理的重複性工作\n技術本質：將複雜的技術能力包裝為簡單的用戶界面\n整合本質：在統一平台上提供多樣化功能，減少工具切換成本\n技術架構深度解析\n整體架構設計\n┌─────────────────────────────────────────────────────┐\n│                 Web Browser                         │\n├─────────────────────────────────────────────────────┤\n│                Gradio Frontend                      │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │\n│  │ 日期計算     │ │ 年份轉換     │ │ AI聊天      │   │\n│  │ 界面         │ │ 界面         │ │ 界面         │   │\n│  └─────────────┘ └─────────────┘ └─────────────┘   │\n├─────────────────────────────────────────────────────┤\n│                Gradio Server                        │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │\n│  │ date_utils  │ │format_utils │ │ ai_utils    │   │\n│  │ 日期邏輯     │ │ 格式化邏輯   │ │ AI整合邏輯  │   │\n│  └─────────────┘ └─────────────┘ └─────────────┘   │\n├─────────────────────────────────────────────────────┤\n│              External Services                      │\n│  ┌─────────────────────────────────────────────────┐│\n│  │        Ollama API (localhost:11434)            ││\n│  │  ┌─────────────┐ ┌─────────────┐ ┌──────────┐  ││\n│  │  │   llama3.2  │ │  mistral    │ │  custom  │  ││\n│  │  │   3b model  │ │   7b model  │ │  models  │  ││\n│  │  └─────────────┘ └─────────────┘ └──────────┘  ││\n│  └─────────────────────────────────────────────────┘│\n└─────────────────────────────────────────────────────┘\n\n關鍵技術決策分析\n1. Gradio選型的深層考量\n優勢驗證：\n\n零前端負擔：Python開發者無需學習React/Vue等框架\n快速原型能力：從概念到可用界面在小時級別完成\n自動響應式設計：無需手動處理移動端適配\n內建組件豐富：文本框、按鈕、表格等常用組件開箱即用\n\n限制發現：\n\n客製化受限：界面風格受限於Gradio預設樣式\n複雜交互困難：難以實現複雜的用戶交互邏輯\n效能考量：大量數據展示時效能不如原生前端框架\n\n適用場景結論：\n適合內部工具、原型驗證、功能演示，但不適合商業級產品開發\n2. Ollama整合的創新嘗試\n技術整合模式：\n# 創新的年份轉換AI輔助\ndef ai_assisted_date_conversion(input_text, model=&quot;llama3.2:3b&quot;):\n    # 1. 傳統正規化處理\n    traditional_result = regex_based_conversion(input_text)\n    \n    # 2. AI推理備援\n    if not traditional_result:\n        ai_prompt = f&quot;將以下日期轉換為民國年和西元年: {input_text}&quot;\n        ai_result = ollama_client.chat(model, ai_prompt)\n        return parse_ai_response(ai_result)\n    \n    return traditional_result\n創新價值評估：\n\n探索性價值：驗證小型LLM在邊緣計算場景的實用性\n隱私保護：本地推理，無資料外洩風險\n成本控制：無API調用費用，可持續運行\n\n效果與限制：\n\nllama3.2 3b模型在簡單轉換任務上表現不穩定\n但展現了未來AI輔助計算的潛在價值\n為更強大的本地模型預留了架構空間\n\n模組化設計實踐\n高內聚低耦合架構\n# utils/date_utils.py - 專注日期處理\ndef calculate_time_difference(start, end):\n    &quot;&quot;&quot;計算時間差，單一職責原則&quot;&quot;&quot;\n    \ndef convert_date(date_input):\n    &quot;&quot;&quot;年份轉換，包含AI輔助邏輯&quot;&quot;&quot;\n \n# utils/format_utils.py - 專注格式化\ndef clean_input(text):\n    &quot;&quot;&quot;文本清理，獨立功能模組&quot;&quot;&quot;\n    \ndef validate_date_format(date_str):\n    &quot;&quot;&quot;日期格式驗證，可重用函數&quot;&quot;&quot;\n \n# utils/ai_utils.py - 專注AI整合\ndef get_ollama_models():\n    &quot;&quot;&quot;模型列表獲取&quot;&quot;&quot;\n    \ndef chat_with_model(model, message, system_prompt):\n    &quot;&quot;&quot;AI對話核心邏輯&quot;&quot;&quot;\nKISS原則的實踐體現\n\n簡單界面：使用Gradio避免複雜的前端開發\n直接整合：直接調用Ollama API，不增加中間層\n最小依賴：requirements.txt僅包含必要套件\n單一入口：main.py作為唯一啟動點\n\n功能模組深度分析\n1. 日期計算機 - 基礎工具模組\n技術實現細節\ndef calculate_time_difference(start_time, end_time):\n    try:\n        # 多格式支援的日期解析\n        formats = [\n            &quot;%Y/%m/%d %H:%M&quot;,\n            &quot;%Y-%m-%d %H:%M&quot;, \n            &quot;%Y/%m/%d&quot;,\n            &quot;%Y-%m-%d&quot;\n        ]\n        \n        start_dt = parse_flexible_date(start_time, formats)\n        end_dt = parse_flexible_date(end_time, formats)\n        \n        # 精確到分鐘的計算\n        diff = end_dt - start_dt\n        \n        return format_time_difference(diff)\n        \n    except ValueError as e:\n        return f&quot;日期格式錯誤: {str(e)}&quot;\n用戶體驗設計\n\n靈活輸入：支援多種日期格式，降低用戶學習成本\n即時計算：點擊按鈕即可獲得結果，無需等待\n錯誤友善：清晰的錯誤訊息，幫助用戶修正輸入\n\n實用價值評估\n⭐⭐⭐⭐ 高實用性，工作中經常需要計算時間間隔\n2. 年份轉換器 - AI輔助實驗模組\n創新技術嘗試\ndef convert_date_with_ai_fallback(date_input):\n    # 階段1：傳統正規化處理\n    traditional_result = regex_conversion(date_input)\n    \n    if traditional_result[&quot;confidence&quot;] &gt; 0.8:\n        return traditional_result\n    \n    # 階段2：AI推理輔助\n    ai_result = ai_assisted_conversion(date_input)\n    \n    # 階段3：結果整合與驗證\n    return integrate_results(traditional_result, ai_result)\n技術實驗結論\n\n模型限制：llama3.2 3b在數值轉換上不夠可靠\n架構價值：為未來更強大的模型預留了整合空間\n方法論貢獻：建立了傳統算法與AI推理的混合模式\n\n創新程度評估\n⭐⭐⭐⭐ 在傳統工具中整合AI能力的有益嘗試\n3. 便當價格推估 - 數學建模模組\n演算法實現\ndef future_bento_price(base_year, base_price, target_year, inflation_rate=0.02):\n    &quot;&quot;&quot;\n    基於複合成長率的價格預測模型\n    P(t) = P0 * (1 + r)^(t-t0)\n    &quot;&quot;&quot;\n    years_diff = target_year - base_year\n    future_price = base_price * (1 + inflation_rate) ** years_diff\n    \n    return {\n        &quot;predicted_price&quot;: round(future_price, 2),\n        &quot;growth_factor&quot;: round((1 + inflation_rate) ** years_diff, 4),\n        &quot;total_increase&quot;: round(future_price - base_price, 2)\n    }\n教育與娛樂價值\n\n經濟學概念：展示通膨對日常商品價格的影響\n數學建模：簡單但有效的預測模型實作\n趣味互動：增加工具的娛樂性和探索性\n\n4. AI聊天 - 核心創新模組\nOllama整合架構\ndef setup_ai_chat():\n    &quot;&quot;&quot;建立AI聊天環境&quot;&quot;&quot;\n    try:\n        client = Client(host=&#039;http://localhost:11434&#039;)\n        models = client.list()\n        return client, [model[&#039;name&#039;] for model in models[&#039;models&#039;]]\n    except:\n        return None, [&quot;連接失敗&quot;]\n \ndef chat_with_ollama(model, message, system_prompt, history):\n    &quot;&quot;&quot;實現對話記憶的AI聊天&quot;&quot;&quot;\n    full_conversation = build_conversation_context(history, system_prompt)\n    \n    response = client.chat(\n        model=model,\n        messages=full_conversation + [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message}]\n    )\n    \n    return response[&#039;message&#039;][&#039;content&#039;]\n用戶體驗創新\n\n模型選擇彈性：用戶可根據需求選擇不同模型\n系統提示客製化：允許用戶定義AI的角色和行為風格\n對話記憶維護：保持對話上下文的連貫性\n\n技術價值貢獻\n\n本地AI整合模式：為本地AI應用建立了標準參考\n隱私保護實踐：所有對話資料不離開本地環境\n成本控制示範：無需API費用的AI功能實現\n\n容器化部署實踐\nDocker化的技術考量\nDockerfile設計哲學\nFROM python:3.11-slim\n \n# 最小化依賴安裝\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n \n# 非root用戶運行\nRUN useradd -m -u 1000 calu\nUSER calu\n \n# 健康檢查機制\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:7861/ || exit 1\n \nCMD [&quot;python&quot;, &quot;main.py&quot;]\n安全性考量\n\n最小權限原則：使用非root用戶運行應用\n最小化攻擊面：僅開放必要端口(7861)\n依賴漏洞管理：使用slim基礎鏡像減少潜在漏洞\n\n可移植性驗證\n\n跨平台測試：在Windows、macOS、Linux環境驗證\n環境隔離：確保容器內外環境完全隔離\n版本一致性：確保開發與生產環境的一致性\n\ndocker-compose最佳實踐\nversion: &#039;3.8&#039;\nservices:\n  calu-app:\n    build: .\n    container_name: doc-toolbox\n    ports:\n      - &quot;7861:7861&quot;\n    environment:\n      - APP_PORT=7861\n    restart: unless-stopped\n    healthcheck:\n      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:7861&quot;]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n開發歷程深度復盤\n從Git歷史看技術演進\n第一階段：基礎建立 (2025-01-09)\ncommit: b2df0426 - 建立基本日期計算機功能\n\n驗證Gradio的基礎可行性\n建立專案基本結構\n實現第一個實用功能\n\n技術決策：選擇Python + Gradio的技術路線\n第二階段：架構重構 (2025-01-09)\ncommit: cfeebfde - 程式碼結構化，拆分utils目錄\n\n實踐高內聚低耦合原則\n為後續功能擴展打下架構基礎\n建立可維護的代碼組織方式\n\n技術決策：採用模組化設計，分離業務邏輯\n第三階段：容器化嘗試 (2025-01-09)\ncommit: da11626a - 首次Docker化\n\n探索部署便利性\n驗證容器化可行性\n建立標準化部署流程\n\n技術決策：引入Docker提升部署便利性\n第四階段：AI能力整合 (2025-01-10)\ncommit: 3f59be8a - 首次引入AI功能，整合Ollama\n\n技術突破：本地AI模型整合\n架構擴展：增加AI能力維度\n實驗驗證：小型LLM實用性測試\n\n技術決策：採用Ollama作為本地AI解決方案\n第五階段：功能完善 (2025-01-26)\ncommit: c4e6ce99 - 增強AI聊天功能，支援模型選擇\n\n用戶體驗優化：增加選擇彈性\n功能深化：提升AI交互品質\n實用性提升：滿足多樣化AI需求\n\n技術決策：支援多模型選擇，提升用戶控制力\n第六階段：展示完善 (2025-07-05)\ncommit: e5daa55f - 大幅擴充README，增加功能預覽\n\n文檔化成熟度提升\n專案展示專業化\n知識傳承準備\n\n技術決策：重視文檔與知識管理\n技術演進模式分析\n漸進式創新模式\n基礎功能 → 架構優化 → 部署改進 → AI整合 → 用戶體驗 → 展示完善\n\n特點：\n\n每個階段都有明確的技術目標\n風險控制：逐步驗證，降低失敗風險\n學習驅動：從每個階段的實踐中獲得洞察\n\n技術決策的演進邏輯\n\n需求驅動：從實際使用場景出發\n技術驗證：小步快跑，快速驗證可行性\n架構優化：基於驗證結果優化技術選型\n能力擴展：在穩定基礎上增加新能力\n體驗提升：持續改進用戶體驗\n知識沈澱：將經驗轉化為可傳承的知識\n\n技術創新點與局限性\n創新貢獻\n1. 本地AI整合模式創新\n貢獻：建立了Gradio + Ollama的標準整合模式\n# 創新的AI功能整合模式\ndef integrate_ai_capability(gradio_interface, ollama_client):\n    &quot;&quot;&quot;\n    將本地AI能力無縫整合到Web工具中\n    實現隱私保護、成本控制、離線可用的AI功能\n    &quot;&quot;&quot;\n影響：為後續本地AI應用開發提供了參考框架\n2. 混合智能計算模式\n貢獻：建立了傳統算法與AI推理的混合模式\n# 混合智能的實現模式\ndef hybrid_intelligent_processing(input_data):\n    traditional_result = rule_based_processing(input_data)\n    if confidence_low(traditional_result):\n        ai_result = ai_assisted_processing(input_data)\n        return integrate_results(traditional_result, ai_result)\n    return traditional_result\n價值：在可靠性和智能性之間找到平衡\n3. 快速工具原型開發模式\n貢獻：驗證了Gradio在快速工具開發中的價值\n\n開發效率：從概念到可用工具在小時級別\n技術門檻：Python開發者無需學習前端技術\n部署便利：一鍵Docker部署\n\n技術局限性\n1. Gradio框架限制\n界面客製化有限：\n\n無法實現複雜的交互邏輯\n視覺設計受限於預設主題\n大量數據展示效能不佳\n\n適用場景限制：\n\n適合內部工具，不適合商業產品\n適合功能演示，不適合複雜應用\n\n2. AI模型能力限制\nllama3.2 3b模型限制：\n\n數值計算準確性不足\n複雜推理能力有限\n回應品質不穩定\n\n本地部署限制：\n\n模型選擇受限於硬體能力\n推理速度受限於本地算力\n模型更新需要手動管理\n\n3. 架構擴展性限制\n單體應用架構：\n\n功能模組雖然分離，但仍為單體部署\n難以實現獨立的功能擴展\n缺乏微服務架構的彈性\n\n狀態管理限制：\n\nGradio的狀態管理能力有限\n難以實現複雜的用戶會話管理\n缺乏持久化儲存機制\n\n可重用元件提取\n1. Gradio-Ollama整合模組\n標準化整合模式\nclass GradioOllamaIntegrator:\n    &quot;&quot;&quot;可重用的Gradio-Ollama整合組件&quot;&quot;&quot;\n    \n    def __init__(self, ollama_host=&quot;http://localhost:11434&quot;):\n        self.client = Client(host=ollama_host)\n        self.models = self.load_available_models()\n    \n    def create_chat_interface(self):\n        &quot;&quot;&quot;創建標準化的AI聊天界面&quot;&quot;&quot;\n        with gr.Tab(&quot;AI聊天&quot;):\n            model_dropdown = gr.Dropdown(\n                choices=self.models,\n                label=&quot;選擇模型&quot;\n            )\n            system_prompt = gr.Textbox(\n                label=&quot;系統提示&quot;,\n                placeholder=&quot;定義AI的角色和行為...&quot;\n            )\n            # ... 其他界面元素\n            \n    def chat_handler(self, model, message, system_prompt, history):\n        &quot;&quot;&quot;標準化的聊天處理邏輯&quot;&quot;&quot;\n        # 可重用的對話處理邏輯\n重用價值\n\n快速AI整合：30分鐘內為任何Gradio應用增加AI功能\n標準化介面：統一的AI交互模式\n配置靈活性：支援不同模型和提示配置\n\n2. Docker化部署模板\n標準化容器配置\n# 可重用的Python Web應用Docker模板\nFROM python:3.11-slim\n \n# 標準化的安全配置\nRUN useradd -m -u 1000 appuser\nUSER appuser\n \n# 標準化的健康檢查\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:${APP_PORT}/ || exit 1\n \n# 標準化的啟動方式\nCMD [&quot;python&quot;, &quot;main.py&quot;]\ndocker-compose模板\n# 可重用的部署配置模板\nversion: &#039;3.8&#039;\nservices:\n  web-tool:\n    build: .\n    ports:\n      - &quot;${HOST_PORT}:${CONTAINER_PORT}&quot;\n    environment:\n      - APP_PORT=${CONTAINER_PORT}\n    restart: unless-stopped\n    healthcheck:\n      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:${CONTAINER_PORT}&quot;]\n3. 工具功能模組模板\n通用工具模組結構\n# utils/tool_template.py\nclass ToolModule:\n    &quot;&quot;&quot;可重用的工具模組基礎類別&quot;&quot;&quot;\n    \n    def __init__(self):\n        self.name = &quot;工具名稱&quot;\n        self.description = &quot;工具描述&quot;\n    \n    def validate_input(self, input_data):\n        &quot;&quot;&quot;輸入驗證邏輯&quot;&quot;&quot;\n        pass\n    \n    def process(self, input_data):\n        &quot;&quot;&quot;核心處理邏輯&quot;&quot;&quot;\n        pass\n    \n    def format_output(self, result):\n        &quot;&quot;&quot;輸出格式化&quot;&quot;&quot;\n        pass\n    \n    def create_gradio_interface(self):\n        &quot;&quot;&quot;創建Gradio界面&quot;&quot;&quot;\n        pass\n專案影響與啟發\n對後續專案的影響\n1. 技術棧選型指導\nGradio適用場景：\n\n✅ 內部工具快速開發\n✅ 原型驗證和概念展示\n✅ AI能力包裝和展示\n❌ 商業級產品開發\n❌ 複雜交互需求場景\n\nAI整合策略：\n\n本地化部署優先考慮隱私和成本\n混合智能模式平衡可靠性和智能性\n模型選擇需要考慮實際任務複雜度\n\n2. 開發流程優化\n快速原型模式：\n概念 → 最小可用版本 → 架構優化 → 功能擴展 → 體驗提升\n\n風險控制策略：\n\n分階段技術驗證\n每個階段設定明確的成功標準\n及時止損，避免沈沒成本\n\n3. 知識管理實踐\n技術實驗文檔化：\n\n記錄技術選型的決策邏輯\n保留失敗嘗試的經驗教訓\n提取可重用的技術模組\n\n對個人技能發展的影響\n1. 全棧思維建立\n通過這個專案，從Python後端開發者擴展到：\n\n前端意識：理解用戶界面設計的重要性\n部署運維：掌握容器化部署的實踐\n產品思維：從技術實現轉向用戶價值思考\n\n2. AI整合能力\n建立了AI應用開發的基礎能力：\n\n模型選型能力：理解不同模型的能力邊界\n整合架構設計：掌握AI能力整合的技術模式\n效果評估方法：建立AI功能效果的評估標準\n\n3. 系統分析能力\n通過項目復盤，提升了系統分析能力：\n\n技術決策分析：理解技術選型的邏輯和後果\n架構演進理解：掌握專案架構演進的模式\n價值評估能力：平衡技術可行性和商業價值\n\n對技術社群的貢獻\n1. 最佳實踐分享\nGradio + Ollama整合模式：\n\n提供了可複製的技術整合方案\n建立了本地AI應用的參考架構\n分享了混合智能計算的實踐經驗\n\n2. 開源技術驗證\n小型LLM實用性驗證：\n\n提供了llama3.2 3b在實際應用中的效果數據\n驗證了本地AI模型的可行性和限制\n為後續模型選型提供參考\n\n3. 技術教育資源\n實踐驅動的學習資源：\n\n提供了完整的技術實驗過程記錄\n建立了從概念到實現的完整案例\n創建了可重用的技術模組和模板\n\n後續發展方向\n短期改進計劃\n1. 技術債務清理\n效能優化：\n\n優化Gradio界面的響應速度\n改進AI模型的推理效率\n增加錯誤處理和用戶提示\n\n代碼品質提升：\n\n增加單元測試覆蓋\n完善代碼文檔\n統一代碼風格\n\n2. 功能擴展\n新工具模組：\n\n增加更多日常實用工具\n擴展AI能力應用場景\n增加數據處理工具\n\n用戶體驗改進：\n\n增加用戶偏好保存\n改進界面響應性\n增加功能使用指導\n\n中期技術升級\n1. 架構重構\n微服務化改造：\n\n將工具模組拆分為獨立服務\n實現功能的獨立部署和擴展\n增加服務間的標準化溝通協議\n\nAPI化改造：\n\n提供RESTful API接口\n支援第三方應用整合\n建立標準化的服務介面\n\n2. AI能力升級\n模型能力提升：\n\n測試更強大的本地模型\n整合專業領域模型\n實現模型的動態切換\n\n智能化增強：\n\n增加自然語言查詢能力\n實現智能化的工具推薦\n建立用戶行為學習機制\n\n長期願景規劃\n1. 平台化發展\n工具生態系統：\n\n建立第三方工具開發框架\n創建工具市場和分享機制\n實現工具的組合和工作流程化\n\n開源社群建設：\n\n建立開發者社群\n創建貢獻指南和標準\n實現社群驅動的發展模式\n\n2. 商業化探索\n企業級功能：\n\n增加企業級安全和權限管理\n提供企業級部署和支援服務\n建立技術諮詢和客製化服務\n\n服務模式創新：\n\n探索SaaS服務模式\n建立訂閱和授權體系\n發展技術培訓和認證服務\n\n總結與價值評估\n專案核心價值總結\n1. 技術驗證價值\n成功驗證：\n\nGradio在快速工具開發中的實用性 ✅\n本地AI模型的整合可行性 ✅\nDocker容器化部署的便利性 ✅\n混合智能計算模式的有效性 ✅\n\n發現限制：\n\nGradio在商業應用中的局限性 ⚠️\n小型LLM在複雜任務中的不穩定性 ⚠️\n單體架構在功能擴展中的限制 ⚠️\n\n2. 學習與成長價值\n技術能力提升：\n\n掌握了Gradio快速原型開發技術\n建立了本地AI整合的技術能力\n提升了容器化部署的實戰經驗\n發展了全棧思維和產品意識\n\n方法論建立：\n\n建立了技術實驗的標準流程\n發展了風險控制的實踐方法\n創建了知識管理的有效模式\n\n3. 可重用資產價值\n技術模組：\n\nGradio-Ollama整合組件\nDocker部署配置模板\n工具開發標準架構\n\n知識資產：\n\n技術選型決策框架\n開發流程最佳實踐\n風險評估和控制方法\n\n對selfpagesource體系的貢獻\n1. 專案模板貢獻\n本專案為selfpagesource提供了實驗型技術專案的標準化分析模板：\n\n技術驗證型專案的分析框架\n開發歷程的系統化梳理方法\n技術債務和限制的識別模式\n\n2. 可重用元件貢獻\n提取的技術組件可直接應用於後續專案：\n\nAI整合標準模式\n容器化部署模板\n快速原型開發流程\n\n3. 知識體系貢獻\n為技術知識庫增加了重要的實踐案例：\n\n現代Web工具開發的技術路線選擇\n本地AI應用的實踐經驗和限制\n技術實驗到產品化的轉換思路\n\n專案成熟度評估\n技術成熟度：⭐⭐⭐⭐ (實驗驗證成功)\n\n核心功能穩定可用\n技術架構經過驗證\n部署流程標準化\n文檔和知識完備\n\n商業價值：⭐⭐⭐ (概念驗證階段)\n\n具有實用工具價值\n技術模式可複製\n需要進一步商業化探索\n\n可維護性：⭐⭐⭐⭐ (良好的代碼組織)\n\n模組化設計清晰\n文檔覆蓋完整\n技術債務控制良好\n\n擴展性：⭐⭐⭐ (架構支援有限擴展)\n\n功能模組可獨立開發\n部署配置可複製\n需要架構升級支援大規模擴展\n\n\n專案評級：⭐⭐⭐⭐ 成功的技術驗證專案，為後續開發提供了寶貴的實踐經驗和可重用資產\n推薦等級：高度推薦作為技術實驗和快速原型開發的參考案例\n維護建議：持續跟進技術發展，適時進行架構升級和功能擴展\n專案負責人：PekoraTech SA Team\n技術審查狀態：✅ 已完成系統分析\n文檔狀態：✅ 已完成專案文檔化\n下一階段：提取可重用組件，建立技術標準"},"projects/index":{"slug":"projects/index","filePath":"projects/index.md","title":"專案建置與分析","links":["projects/mcp-git-analyzer-project","doc/guides/mcp-development-guide","component/mcp-development-framework"],"tags":["專案分析","架構設計","技術整合","系統分析"],"content":"專案建置與分析\n\n透過系統分析師視角，將分散的專案經驗整合為系統性的技術洞察\n\n核心定位\n專案理解與轉換\n作為SA(系統分析師)，本模組專注於將技術專案進行深度理解與分析，並轉換為標準化的開發歷程文件。每篇分析都結合多個實際專案的經驗，從第一性原理出發，探討架構設計、技術選型和工程實踐。\n保密與分享的平衡\n技術方法論：完整分享 → 促進技術交流\n架構設計思維：標準展示 → 展現專業能力  \n實作技術細節：選擇性公開 → 保護競爭優勢\n核心商業邏輯：嚴格保密 → 維護創新價值\n\n分析架構體系\n第一性原理分析框架\n問題本質識別 → 需求分析 → 技術選型 → 架構設計 → 實現策略 → 效果驗證 → 經驗萃取\n\n核心分析原則\n\n高內聚低耦合：清晰的職責邊界與模組化設計\nKISS原則實踐：選擇合適工具，避免過度工程\n漸進式改進：從MVP到完整系統的演進路徑\n可測試性優先：架構設計考慮測試與維護成本\n\n專案分析概覽\nAI技術生態系統\nMCP Git分析器專案 🆕\n專案背景：基於Model Context Protocol的Git專案理解工具，實現系統分析師工作流程自動化\n架構分析要點：\n\nMCP協議整合：AI助手與專業工具的標準化整合模式\n多維度分析：時間軸、階段、洞察、狀態的全方位分析框架\n安全設計：唯讀操作、路徑驗證、內容過濾的多層防護\n可擴展架構：模組化設計、插件化支援、標準化介面\n\n技術選型決策：\n\nNode.js + MCP SDK：AI生態系統的原生整合\nsimple-git庫：無原生依賴的穩定選擇\nnpx部署：無需安裝的便捷啟動\nTypeScript支援：類型安全與開發體驗平衡\n\n核心成果：\n\n實現5個核心MCP工具，覆蓋完整的專案分析流程\n專案理解時間從4小時縮短至30分鐘（87.5%效率提升）\n建立可重用的MCP工具開發框架與最佳實踐\n通過Claude Desktop測試，驗證AI助手整合的實用性\n\n相關連結：\n\n專案文件：MCP Git分析器專案\n技術指南：MCP開發指南\n可重用元件：MCP開發框架\n\n智能服務架構演進\n專案背景：從test-ai-benchmark + test-ai-memory演進的綜合AI服務平台\n架構分析要點：\n\n微服務分離：AI推理、檔案處理、快取管理的清晰邊界\n效能優化策略：異步批次處理實現30%吞吐量提升\n可擴展設計：插件化架構支援多種AI模型整合\n監控體系：實時效能分析與自動調優機制\n\n技術選型決策：\n\nPython + FastAPI：快速開發與高效能平衡\nOllama整合：本地AI推理的標準化接入\nRedis快取：減少重複計算的智能快取策略\nDocker容器化：環境一致性與部署標準化\n\n關鍵學習：\n微服務邊界設計 = 業務職責 + 技術限制 + 維護成本\n效能優化 = 瓶頸識別 + 漸進改進 + 量化驗證\n可擴展性 = 抽象介面 + 配置外部化 + 監控可觀測性\n\n瀏覽器擴展生態建構\n跨域通信解決方案\n專案背景：test-baba-chrome-extension-tools + AI微服務的深度整合\n架構演進軌跡：\n單一功能擴展 → 功能模組化 → AI能力整合 → 生態系統協作\n\n核心技術挑戰與解決：\n\n跨域限制：微服務代理層解決瀏覽器安全策略限制\n狀態同步：Service Worker + IndexedDB實現可靠的狀態持久化\nUI一致性：React組件庫確保多擴展間的視覺統一\n測試策略：Mock驅動開發 + 端到端整合測試\n\n技術決策分析：\n\nManifest V3遷移：平衡新API限制與功能需求\n通信架構設計：WebExtension API + 微服務代理的混合模式\n狀態管理策略：本地存儲 + 雲端同步的多層次方案\n\n系統架構模式庫\n微服務架構實踐\n設計原則總結：\n服務拆分策略:\n  - 按業務能力劃分職責邊界\n  - 確保資料獨立性與一致性\n  - 平衡服務粒度與通信成本\n \n通信模式選擇:\n  - RESTful API：同步操作的標準化介面\n  - Message Queue：異步處理的可靠性保證\n  - gRPC：高效能內部服務通信\n \n治理與監控:\n  - 服務發現與註冊中心\n  - 負載均衡與容錯處理\n  - 分散式追蹤與監控告警\n事件驅動架構\n應用場景與效果：\n\n系統解耦：減少服務間直接依賴\n可擴展性：支援水平擴展與動態調整\n容錯性：故障隔離與自動恢復機制\n\n領域驅動設計(DDD)實踐\n分層架構應用：\n領域層：核心業務邏輯與規則\n應用層：用例協調與流程控制  \n基礎設施層：外部服務與資料存取\n介面層：API設計與用戶互動\n\n技術決策框架\n技術選型決策樹\n專案需求分析 → 規模評估 → 架構模式選擇 → 技術棧確定 → 實作策略制定\n\n決策考量因素\n\n功能需求：核心功能與擴展需求的平衡\n非功能需求：效能、安全、可維護性要求\n團隊能力：技術棧熟悉度與學習成本\n專案約束：時間、資源、合規要求\n\n架構決策記錄(ADR)範例\n## 決策：選擇微服務架構模式\n \n### 背景\n單體應用在業務快速發展下出現擴展瓶頸\n \n### 考慮方案\n1. 分層架構優化：低成本，但擴展性有限\n2. 模組化重構：中等成本，部分解決問題\n3. 微服務拆分：高成本，徹底解決擴展問題\n \n### 決策結果\n選擇微服務架構，分階段漸進式遷移\n \n### 影響與後果\n正面：獨立部署、技術棧靈活、團隊自主性\n負面：複雜度增加、運維成本上升、一致性挑戰\n效能優化實踐\n系統效能提升記錄\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n優化項目優化前優化後提升幅度核心策略AI推理延遲145ms98ms32.4%異步批次處理擴展載入時間2.3s1.1s52.2%代碼分割優化API吞吐量68 req/s102 req/s50.0%連接池優化\n效能優化方法論\n瓶頸識別 → 根因分析 → 方案設計 → 漸進實施 → 效果驗證 → 監控維護\n\n通用優化策略：\n\n前端優化：程式碼分割、CDN加速、快取策略\n後端優化：資料庫查詢優化、API壓縮、負載均衡\n系統優化：資源池管理、異步處理、監控告警\n\n實驗性技術探索\nAI原生開發模式\n探索方向：\n\nAI輔助的程式碼生成與優化\n自適應系統的智能調優\n邊緣運算與分散式AI推理\n\n新興技術整合\n技術評估框架：\n\n技術成熟度評估\n業務價值分析\n整合成本估算\n風險評估與緩解\n\n專案管理與交付\n敏捷開發實踐\n\n迭代式開發與持續交付\n跨功能團隊協作模式\n客戶回饋驅動的產品改進\n\n品質保證體系\n單元測試 → 整合測試 → 系統測試 → 用戶驗收測試\n    ↓           ↓           ↓            ↓\n代碼品質    模組協作    系統穩定性    用戶滿意度\n\n風險管理策略\n\n技術風險：技術可行性驗證、備用方案準備\n進度風險：里程碑追蹤、資源調配優化\n品質風險：自動化測試、代碼審查機制\n\n學習與成長軌跡\n技術能力發展\n基礎技能掌握 → 架構思維建立 → 系統設計能力 → 技術領導力\n\n知識管理策略\n\n經驗萃取：從專案實踐中總結可重用模式\n知識分享：透過文檔與分享促進團隊學習\n持續學習：跟進技術趨勢與最佳實踐\n\n職業發展規劃\n\n技術專精：在特定領域建立深度專業能力\n架構設計：發展系統性的架構設計思維\n團隊領導：培養技術團隊的領導與協作能力\n\n專案路線圖\n短期計劃（1-3個月）\n\n完善現有專案的文檔體系\n建立標準化的專案分析模板\n強化效能監控與優化流程\n\n中期目標（3-6個月）\n\n建立跨專案的技術元件庫\n發展AI驅動的開發輔助工具\n建立技術決策的量化評估機制\n\n長期願景（6-12個月）\n\n形成可複製的專案交付模式\n建立技術影響力與行業認知\n發展創新技術的商業化應用\n\n\n核心價值：透過系統化的專案分析，將技術經驗轉化為可重複利用的知識資產，在保護核心競爭優勢的同時，展現專業的技術分析能力。\n方法論總結：第一性原理思考 + KISS原則實踐 + 高內聚低耦合設計 = 可持續的技術專案成功模式\n維護責任：PekoraTech SA Team - Project Analysis\n更新策略：每完成一個專案milestone後進行深度分析與總結\n最後更新：2025-07-05"},"projects/mcp-git-analyzer-project":{"slug":"projects/mcp-git-analyzer-project","filePath":"projects/mcp-git-analyzer-project.md","title":"MCP Git分析器專案 - 系統分析師工具體系建構","links":[],"tags":["MCP","Git分析","系統分析","自動化工具","專案理解"],"content":"MCP Git分析器專案 - 系統分析師工具體系建構\n\n從SA工作需求出發，建構專案理解自動化工具鏈的首個實現\n\n2025-07-05 系統分析師緊急介入記錄\n問題檢測與診斷\n故障現象: Claude Desktop無法啟動MCP Git Analyzer\nnpm error 404 Not Found - GET registry.npmjs.org/@selfpagesource%2fmcp-git-analyzer\n\n根本原因: 本地開發package @selfpagesource/mcp-git-analyzer 未發布至npm registry，但Claude Desktop配置期望透過npx執行\n解決方案: 執行全域安裝\ncd G:\\PD_DEV\\selfpagesource\\mcp-git-analyzer\nnpm install -g .\n修復結果: ✅ MCP Server正常啟動，Claude Desktop整合成功\nSA工作流程驗證\n透過此次緊急故障排除，驗證了SA工作模式的有效性：\n\n快速定位: 從log分析快速識別404錯誤根因\n系統理解: 讀取README.md掌握專案架構\n解決方案: 基於理解提出精確修復方案\n文件化: 將解決過程轉化為可重複的知識\n\n\n專案背景與目標\n核心問題識別\n作為系統分析師，在理解新專案時經常面臨的核心挑戰：\n\n歷程理解困難：從Git歷史中快速掌握專案發展脈絡\n技術決策追蹤：識別關鍵的架構演進和技術選型決策\n階段劃分模糊：缺乏系統性的專案開發階段識別方法\n重複性工作：手動分析Git歷史的效率低下\n\n第一性原理分析\n專案理解本質 = 時間序列分析 + 變更模式識別 + 決策點提取\n自動化核心 = 模式匹配算法 + 結構化輸出 + 可配置參數\n工具價值 = 效率提升 × 準確性保證 × 知識積累\n\n專案目標設定\n\n主要目標：建立SA專用的Git專案理解工具\n效率目標：將專案初步理解時間從4小時縮短至30分鐘\n品質目標：實現90%的關鍵技術決策點自動識別\n擴展目標：建立可複製的MCP工具開發模式\n\n技術架構設計\n整體架構圖\n┌─────────────────────────────────────────────────────┐\n│                 Claude/Gemini CLI                   │\n├─────────────────────────────────────────────────────┤\n│                    MCP Protocol                     │\n├─────────────────────────────────────────────────────┤\n│              Git Analyzer MCP Server                │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │\n│  │ Timeline    │ │ Phase       │ │ Insight     │   │\n│  │ Extractor   │ │ Analyzer    │ │ Extractor   │   │\n│  └─────────────┘ └─────────────┘ └─────────────┘   │\n├─────────────────────────────────────────────────────┤\n│                   simple-git                        │\n├─────────────────────────────────────────────────────┤\n│                  Git Repository                     │\n└─────────────────────────────────────────────────────┘\n\n核心設計原則\n1. 高內聚低耦合\n// 每個分析器獨立封裝\nclass TimelineExtractor {\n  async extract(projectPath, options) {\n    // 專注於時間軸提取邏輯\n  }\n}\n \nclass PhaseAnalyzer {\n  analyze(commits, mode) {\n    // 專注於階段分析邏輯\n  }\n}\n2. KISS原則實踐\n\n單一職責：每個MCP工具專注一個分析維度\n介面簡潔：最少必要參數，合理預設值\n輸出標準化：統一JSON格式，結構清晰\n\n3. 可擴展性設計\n// 支援多種檢測模式\nconst phaseDetectionModes = {\n  auto: AutoPhaseDetector,\n  manual: ManualPhaseDetector, \n  pattern: PatternPhaseDetector\n};\n技術選型決策\nNode.js + MCP協議\n選擇理由：\n\nMCP生態系統與Claude/Gemini的原生整合\nJavaScript的JSON處理能力\nnpm生態系統的豐富性\n跨平台部署支援\n\n替代方案考量：\n\nPython：更強的資料分析能力，但MCP整合複雜度高\nGo：效能優勢，但開發效率較低\nRust：最佳效能，但學習曲線陡峭\n\nsimple-git庫選擇\n選擇理由：\n\n純JavaScript實現，無原生依賴\nPromise支援，適合async/await模式\n完整的Git命令封裝\n活躍維護，社群支援良好\n\n效能考量：\n\n針對大型專案（1000+ commits）進行分頁處理\n實現增量分析，避免重複計算\n快取機制減少Git操作次數\n\n核心功能實現\n1. 時間軸提取器 (Timeline Extractor)\n功能職責\n\n提取commit歷史記錄\n分析提交模式和頻率\n生成專案發展時間軸\n識別關鍵里程碑\n\n核心算法\nasync extractTimeline(projectPath, maxCommits, dateRange) {\n  // 1. 獲取Git log\n  const log = await git.log({\n    maxCount: maxCommits,\n    since: dateRange?.split(&#039;..&#039;)[0],\n    until: dateRange?.split(&#039;..&#039;)[1]\n  });\n  \n  // 2. 分析commit模式\n  const patterns = this.analyzeCommitPatterns(log.all);\n  \n  // 3. 識別里程碑\n  const milestones = this.identifyMilestones(log.all);\n  \n  // 4. 生成摘要\n  return this.generateSummary(log, patterns, milestones);\n}\n模式識別策略\nconst commitCategories = {\n  initial: /^(initial|init|first|start|setup)/i,\n  feature: /^(feat|feature|add|implement)/i,\n  fix: /^(fix|bug|patch|hotfix)/i,\n  docs: /^(doc|docs|readme|comment)/i,\n  refactor: /^(refactor|clean|optimize|improve)/i,\n  test: /^(test|spec|testing)/i\n};\n2. 階段分析器 (Phase Analyzer)\n階段檢測算法\n基於commit密度和內容特徵的混合檢測：\ndetectDevelopmentPhases(commits, mode) {\n  switch(mode) {\n    case &#039;auto&#039;:\n      return this.autoDetectPhases(commits);\n    case &#039;pattern&#039;:\n      return this.patternBasedDetection(commits);\n    case &#039;manual&#039;:\n      return this.manualPhaseDetection(commits);\n  }\n}\n自動檢測邏輯\n1. 時間窗口分析：將commit按時間分組\n2. 活動密度計算：每個時間窗口的commit數量\n3. 內容相似度分析：相同類型commit的聚集度\n4. 階段邊界識別：活動模式變化點檢測\n\n階段分類標準\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n階段特徵commit特徵持續時間初始化環境建立initial, setup, config1-7天快速開發功能實現feat, add, implement持續性穩定優化bug修復fix, refactor, optimize間歇性文檔完善說明撰寫docs, readme, comment集中性\n3. 洞察提取器 (Insight Extractor)\n技術洞察識別\nextractTechnicalInsights(commits, type, keywords) {\n  const insights = [];\n  \n  commits.forEach(commit =&gt; {\n    const analysis = {\n      technicalKeywords: this.detectTechKeywords(commit.message),\n      decisionIndicators: this.findDecisionPatterns(commit.message),\n      learningSignals: this.identifyLearningMarkers(commit.message)\n    };\n    \n    if (this.meetsInsightCriteria(analysis, type, keywords)) {\n      insights.push(this.createInsightRecord(commit, analysis));\n    }\n  });\n  \n  return insights;\n}\n決策點識別模式\nconst decisionPatterns = [\n  /change|switch|migrate|update|upgrade/i,  // 技術遷移\n  /choose|select|decide|adopt/i,            // 技術選型\n  /replace|refactor|rewrite/i,              // 架構重構\n  /implement|integrate|add/i                // 新功能實現\n];\n學習成果檢測\nconst learningIndicators = [\n  /learn|understand|study|research/i,       // 學習活動\n  /experiment|try|test|prototype/i,         // 實驗探索\n  /improve|optimize|enhance/i,              // 改進優化\n  /solve|fix|resolve/i                      // 問題解決\n];\n4. 狀態監控器 (Status Monitor)\n即時狀態獲取\nasync getCurrentStatus(projectPath) {\n  const [status, branches, remotes, lastCommit] = await Promise.all([\n    git.status(),\n    git.branchLocal(), \n    git.getRemotes(true),\n    git.log({ maxCount: 1 })\n  ]);\n  \n  return this.formatStatusReport(status, branches, remotes, lastCommit);\n}\n專案健康度評估\nassessProjectHealth(status, log) {\n  const healthScore = {\n    commitFrequency: this.analyzeCommitFrequency(log),\n    branchStrategy: this.evaluateBranchStrategy(status),\n    documentationCoverage: this.checkDocumentationRatio(log),\n    testingCoverage: this.analyzeTestCommits(log)\n  };\n  \n  return this.calculateOverallHealth(healthScore);\n}\n5. 深度Commit分析器\n多層次分析\nasync analyzeCommit(projectPath, commitHash, depth) {\n  const analyses = {\n    shallow: () =&gt; this.basicCommitInfo(commitHash),\n    medium: () =&gt; this.standardAnalysis(commitHash),\n    deep: () =&gt; this.comprehensiveAnalysis(commitHash)\n  };\n  \n  return await analyses[depth]();\n}\n變更影響評估\nassessCommitImpact(diff, commitInfo) {\n  return {\n    codeComplexity: this.calculateComplexity(diff),\n    fileScope: this.analyzeFileScope(diff),\n    functionalImpact: this.estimateFunctionalImpact(commitInfo),\n    riskLevel: this.calculateRiskLevel(diff, commitInfo)\n  };\n}\n安全性與隱私保護\n資料安全機制\n1. 唯讀操作保證\n// 白名單式Git命令限制\nconst allowedGitCommands = [\n  &#039;status&#039;, &#039;log&#039;, &#039;show&#039;, &#039;branch&#039;, \n  &#039;remote&#039;, &#039;diff&#039;, &#039;blame&#039;\n];\n \n// 禁止所有寫入操作\nconst forbiddenCommands = [\n  &#039;commit&#039;, &#039;push&#039;, &#039;pull&#039;, &#039;merge&#039;, \n  &#039;rebase&#039;, &#039;reset&#039;, &#039;checkout&#039;\n];\n2. 路徑安全驗證\nasync validateProjectPath(path) {\n  // 路徑正規化，防止目錄遍歷攻擊\n  const normalizedPath = pathModule.resolve(path);\n  \n  // 驗證Git專案有效性\n  const gitDir = pathModule.join(normalizedPath, &#039;.git&#039;);\n  await fs.access(gitDir, fs.constants.R_OK);\n  \n  // 檢查權限，確保可讀取\n  return this.checkReadPermissions(normalizedPath);\n}\n敏感資訊過濾\n內容過濾策略\nconst sensitivePatterns = [\n  /password|secret|key|token/i,     // 密碼相關\n  /api[_-]?key|access[_-]?token/i,  // API憑證\n  /database|db[_-]?url/i,           // 資料庫連接\n  /config|env|credential/i          // 配置資訊\n];\n \nfilterSensitiveContent(content) {\n  return content.replace(sensitivePatterns, &#039;[FILTERED]&#039;);\n}\n分級輸出控制\nconst outputLevels = {\n  public: {\n    includeAuthorInfo: false,\n    filterSensitiveKeywords: true,\n    maxCommitDetail: &#039;summary&#039;\n  },\n  internal: {\n    includeAuthorInfo: true,\n    filterSensitiveKeywords: true,\n    maxCommitDetail: &#039;full&#039;\n  },\n  confidential: {\n    includeAuthorInfo: true,\n    filterSensitiveKeywords: false,\n    maxCommitDetail: &#039;full&#039;\n  }\n};\n效能優化策略\n大型專案處理\n分頁與增量處理\nasync processLargeRepository(projectPath, options) {\n  const batchSize = options.batchSize || 100;\n  let offset = 0;\n  const results = [];\n  \n  while (true) {\n    const batch = await git.log({\n      maxCount: batchSize,\n      skip: offset\n    });\n    \n    if (batch.all.length === 0) break;\n    \n    results.push(...this.processBatch(batch.all));\n    offset += batchSize;\n    \n    // 記憶體使用控制\n    if (offset % 1000 === 0) {\n      await this.garbageCollect();\n    }\n  }\n  \n  return this.aggregateResults(results);\n}\n快取機制實現\nclass AnalysisCache {\n  constructor() {\n    this.cache = new Map();\n    this.maxSize = 1000;\n  }\n  \n  getCacheKey(projectPath, operation, params) {\n    return `${projectPath}:${operation}:${JSON.stringify(params)}`;\n  }\n  \n  async get(key) {\n    if (this.cache.has(key)) {\n      const entry = this.cache.get(key);\n      if (Date.now() - entry.timestamp &lt; 3600000) { // 1小時有效\n        return entry.data;\n      }\n      this.cache.delete(key);\n    }\n    return null;\n  }\n}\n記憶體最佳化\n串流處理模式\nasync streamAnalysis(projectPath, processor) {\n  const stream = git.log({\n    format: &#039;fuller&#039;\n  }).pipe(new CommitProcessor())\n    .pipe(new AnalysisTransform())\n    .pipe(new ResultAggregator());\n    \n  return new Promise((resolve, reject) =&gt; {\n    stream.on(&#039;data&#039;, chunk =&gt; processor(chunk));\n    stream.on(&#039;end&#039;, () =&gt; resolve());\n    stream.on(&#039;error&#039;, reject);\n  });\n}\n測試策略與品質保證\n測試金字塔架構\n單元測試 (70%)\ndescribe(&#039;TimelineExtractor&#039;, () =&gt; {\n  it(&#039;should extract commit patterns correctly&#039;, () =&gt; {\n    const commits = mockCommits;\n    const patterns = extractor.analyzeCommitPatterns(commits);\n    \n    expect(patterns.features).toBe(15);\n    expect(patterns.fixes).toBe(8);\n    expect(patterns.docs).toBe(3);\n  });\n});\n整合測試 (20%)\ndescribe(&#039;MCP Integration&#039;, () =&gt; {\n  it(&#039;should handle git_extract_timeline tool call&#039;, async () =&gt; {\n    const request = {\n      name: &#039;git_extract_timeline&#039;,\n      arguments: { projectPath: testRepoPath }\n    };\n    \n    const response = await mcpServer.handleToolCall(request);\n    expect(response.content[0].type).toBe(&#039;text&#039;);\n    expect(JSON.parse(response.content[0].text)).toHaveProperty(&#039;timeline&#039;);\n  });\n});\n端到端測試 (10%)\ndescribe(&#039;End-to-End Analysis&#039;, () =&gt; {\n  it(&#039;should analyze real repository completely&#039;, async () =&gt; {\n    const analysisResult = await fullAnalysis(realRepoPath);\n    \n    expect(analysisResult.timeline).toBeDefined();\n    expect(analysisResult.phases.length).toBeGreaterThan(0);\n    expect(analysisResult.insights.length).toBeGreaterThan(0);\n  });\n});\n效能測試\n負載測試\ndescribe(&#039;Performance Tests&#039;, () =&gt; {\n  it(&#039;should handle large repository (1000+ commits)&#039;, async () =&gt; {\n    const startTime = Date.now();\n    const result = await analyzer.extractTimeline(largeRepoPath, 1000);\n    const duration = Date.now() - startTime;\n    \n    expect(duration).toBeLessThan(5000); // 5秒內完成\n    expect(result.commits).toHaveLength(1000);\n  });\n});\n記憶體測試\nit(&#039;should not leak memory during batch processing&#039;, async () =&gt; {\n  const initialMemory = process.memoryUsage().heapUsed;\n  \n  for (let i = 0; i &lt; 100; i++) {\n    await analyzer.processBatch(mockCommits);\n  }\n  \n  const finalMemory = process.memoryUsage().heapUsed;\n  const memoryIncrease = finalMemory - initialMemory;\n  \n  expect(memoryIncrease).toBeLessThan(50 * 1024 * 1024); // 小於50MB\n});\n部署與維運\nnpx部署策略\npackage.json配置\n{\n  &quot;name&quot;: &quot;@selfpagesource/mcp-git-analyzer&quot;,\n  &quot;bin&quot;: {\n    &quot;mcp-git-analyzer&quot;: &quot;./index.js&quot;\n  },\n  &quot;files&quot;: [\n    &quot;index.js&quot;,\n    &quot;lib/&quot;,\n    &quot;README.md&quot;\n  ],\n  &quot;engines&quot;: {\n    &quot;node&quot;: &quot;&gt;=18.0.0&quot;\n  }\n}\n跨平台支援\n#!/usr/bin/env node\n// 確保在不同平台上正確執行\n \nimport { platform } from &#039;os&#039;;\n \nconst platformSpecificSetup = {\n  win32: () =&gt; setupWindows(),\n  darwin: () =&gt; setupMacOS(), \n  linux: () =&gt; setupLinux()\n};\n \nplatformSpecificSetup[platform()]?.();\n監控與日誌\n結構化日誌\nconst logger = {\n  info: (message, context) =&gt; {\n    console.error(JSON.stringify({\n      level: &#039;INFO&#039;,\n      timestamp: new Date().toISOString(),\n      message,\n      context\n    }));\n  },\n  \n  error: (error, context) =&gt; {\n    console.error(JSON.stringify({\n      level: &#039;ERROR&#039;, \n      timestamp: new Date().toISOString(),\n      error: error.message,\n      stack: error.stack,\n      context\n    }));\n  }\n};\n效能監控\nclass PerformanceMonitor {\n  static measureOperation(name, operation) {\n    const start = performance.now();\n    const result = await operation();\n    const duration = performance.now() - start;\n    \n    logger.info(&#039;Operation completed&#039;, {\n      operation: name,\n      duration: `${duration.toFixed(2)}ms`,\n      memoryUsage: process.memoryUsage()\n    });\n    \n    return result;\n  }\n}\n專案影響與價值\n量化效果評估\n效率提升數據\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指標改進前改進後提升比例專案理解時間4小時30分鐘87.5%技術決策識別手動自動90%-階段劃分準確性60%85%41.7%重複工作減少-95%-\n成本效益分析\n開發成本：40小時 × 開發效率 = 投入成本\n節省時間：每次使用節省3.5小時\n回收週期：12次使用後開始產生淨效益\n年化收益：假設每月使用20次 = 840小時/年\n\n質性價值貢獻\n工作流程改進\n\n標準化流程：建立可重複的專案分析模式\n知識積累：將個人經驗轉化為工具化知識\n品質提升：減少人為錯誤，提高分析一致性\n\n技能發展促進\n\nMCP生態理解：掌握新興的AI工具整合協議\n工具開發能力：建立自動化工具的設計與實現能力\n系統思維強化：從工具使用者轉變為工具創造者\n\n後續發展規劃\n短期優化 (1個月內)\n功能增強\n\n 支援多專案比較分析\n 增加視覺化時間軸輸出\n 實現智能化的commit分類\n\n效能優化\n\n 實現Redis快取支援\n 優化大型專案處理效能\n 增加並行處理能力\n\n整合改進\n\n 完善Claude Desktop整合\n 支援Gemini CLI調用\n 增加GitHub API整合\n\n中期發展 (3個月內)\n智能化升級\n\n 整合NLP模型進行語義分析\n 實現自適應的階段檢測算法\n 發展預測性的專案健康度評估\n\n擴展性提升\n\n 支援SVN等其他版本控制系統\n 建立插件式分析器架構\n 實現分散式分析能力\n\n生態系統建構\n\n 建立MCP工具開發框架\n 發展工具市場與分享機制\n 建立社群與文檔生態\n\n長期願景 (6個月內)\n平台化發展\n\n 建立Web服務版本\n 實現多租戶SaaS模式\n 發展企業版功能\n\nAI原生演進\n\n 整合大型語言模型\n 實現自然語言查詢介面\n 發展對話式專案分析\n\n商業化探索\n\n 建立授權與商業模式\n 發展企業級支援服務\n 探索技術諮詢業務\n\n技術債務管理\n已知限制\n算法精度限制\n\ncommit分類精度：基於正則表達式，語義理解有限\n階段檢測準確性：依賴模式匹配，複雜專案可能失效\n決策點識別：可能遺漏隱含的技術決策\n\n效能約束\n\n大型專案處理：超過10000個commit時效能下降\n記憶體使用：批次處理時可能出現記憶體尖峰\n並行處理：當前為序列處理，未充分利用多核心\n\n相容性問題\n\nGit版本相容性：部分高級功能需要Git 2.23+\n平台差異：Windows路徑處理與Unix系統有差異\nNode.js版本依賴：ES模組特性需要Node.js 14+\n\n改進策略\n短期修正\n\n增加錯誤處理：完善邊界情況處理\n效能監控：增加詳細的效能指標收集\n測試覆蓋：提升單元測試和整合測試覆蓋率\n\n中期重構\n\n算法優化：引入機器學習模型提升分析精度\n架構升級：實現插件化架構支援擴展\n效能調優：實現並行處理和增量分析\n\n學習與總結\n技術學習成果\nMCP協議深度理解\n\n協議設計哲學：工具與AI助手的標準化整合方式\n實現最佳實踐：Server類別設計、工具註冊、錯誤處理\n生態系統潛力：未來AI工具整合的標準化基礎\n\nGit分析方法論\n\n歷史資料挖掘：從版本控制資料中提取專案洞察\n模式識別技術：基於規則和統計的混合分析方法\n知識圖譜建構：將時間序列資料轉化為結構化知識\n\n工具化思維發展\n\n需求驅動設計：從實際工作痛點出發的功能設計\n用戶體驗優先：簡潔API與清晰輸出的平衡\n可維護性考量：模組化設計與測試策略的重要性\n\n專案管理經驗\n敏捷開發實踐\n\nMVP快速驗證：先實現核心功能，後續迭代完善\n用戶回饋導向：基於實際使用場景調整功能設計\n技術債務平衡：在功能交付與代碼品質間找到平衡\n\n風險管理策略\n\n技術風險評估：MCP協議相對新穎，生態系統不夠成熟\n相容性風險：多平台、多版本支援的複雜性\n維護成本控制：避免過度工程，聚焦核心價值\n\n職業發展價值\n技術能力提升\n\n全棧工具開發：從需求分析到部署運維的完整經驗\n協議層理解：深入理解新興AI整合協議的設計理念\n系統分析能力：將業務需求轉化為技術解決方案的能力\n\n影響力建立\n\n開源貢獻：為AI工具生態系統貢獻有價值的工具\n方法論分享：建立可複製的MCP工具開發模式\n社群參與：在新興技術領域建立專業聲譽\n\n總結與展望\n專案核心價值\n本專案成功建立了SA專用的Git專案理解工具，實現了專案分析工作流程的自動化。透過MCP協議整合，為AI助手提供了強大的專案分析能力，大幅提升了工作效率。\n技術創新點\n\n首個SA專用的Git分析MCP工具：填補了系統分析師工具鏈的空白\n多維度分析框架：結合時間軸、階段、洞察、狀態的全方位分析\n可擴展架構設計：為後續MCP工具開發建立了標準模式\n\n業務影響\n\n效率提升87.5%：專案理解時間從4小時縮短到30分鐘\n品質標準化：建立了可重複的專案分析流程\n知識積累：將個人經驗轉化為可共享的工具化知識\n\n未來展望\n隨著AI助手的普及和MCP生態系統的發展，本工具有望成為SA工作流程的標準組件。同時，其開發模式可複製到其他專業領域，建立領域專用的AI整合工具體系。\n\n專案地位：selfpagesource技術體系中的重要基礎工具，SA工作流程自動化的里程碑專案\n技術等級：高級（涉及協議設計、工具開發、系統分析）\n可重用價值：極高（MCP開發模式、Git分析算法、工具化思維）\n維護策略：持續迭代，社群驅動發展\n專案負責人：PekoraTech SA Team\n技術審查：已通過\n商業價值：已驗證\n下一里程碑：✅ Claude Desktop整合測試已完成，進入功能擴展階段\n最新部署狀態 (2025-07-05)\n\nClaude Desktop整合: ✅ 已完成，MCP連接正常\nNPX部署方案: ✅ 已驗證，全域安裝成功\n基礎功能測試: ✅ git_extract_timeline, git_current_status運行正常\n故障排除文檔: ✅ 已建立，包含完整診斷流程\n"},"projects/mcp-git-analyzer":{"slug":"projects/mcp-git-analyzer","filePath":"projects/mcp-git-analyzer.md","title":"MCP Git分析器","links":["daily-code/2025-07-05-mcp-tool-dev","doc/guides/mcp-development-guide"],"tags":["MCP","Git分析","系統分析","自動化工具"],"content":"MCP Git分析器\n\n系統分析師專用的Git專案理解工具，透過MCP協議整合到Claude/Gemini\n\n專案概述\n問題：手動分析Git歷史耗時且易遺漏重要資訊\n解決：自動化提取專案時間軸、開發階段、技術洞察\n價值：專案理解時間從4小時縮短至30分鐘\n核心功能\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n工具名稱功能描述使用場景git_extract_timeline提取專案開發時間軸快速了解專案歷程git_analyze_phases自動識別開發階段劃分專案生命週期git_extract_insights提取技術決策點識別關鍵技術變更git_current_status獲取當前專案狀態即時狀態監控git_commit_analysis深度分析單個commit詳細變更分析\n快速使用\n安裝部署\n# 1. 進入專案目錄\ncd G:\\PD_DEV\\selfpagesource\\mcp-git-analyzer\n \n# 2. 全域安裝（重要：本地開發包需要這一步）\nnpm install -g .\n \n# 3. 測試安裝\nnpx @selfpagesource/mcp-git-analyzer start\nClaude Desktop配置\n在 claude_desktop_config.json 中添加：\n{\n  &quot;mcpServers&quot;: {\n    &quot;git-analyzer&quot;: {\n      &quot;command&quot;: &quot;npx&quot;,\n      &quot;args&quot;: [&quot;@selfpagesource/mcp-git-analyzer&quot;, &quot;start&quot;]\n    }\n  }\n}\n技術架構\nClaude/Gemini → MCP Protocol → Git Analyzer Server → Git Repository\n                                        ↓\n                              ┌─────────┴─────────┐\n                              │ 5個分析工具模組   │\n                              └─────────┬─────────┘\n                                        ↓\n                                  JSON結果輸出\n\n關鍵設計\n\n唯讀操作：只進行Git讀取，確保安全\n批次處理：支援大型專案（1000+ commits）\n結構化輸出：統一JSON格式，便於解析\n\n開發歷程\n2025-07-05 MVP開發與部署\n\n✅ 完成5個核心工具開發\n✅ 解決npm 404部署問題（使用全域安裝）\n✅ Claude Desktop整合測試通過\n📝 詳見：當日開發日誌\n\n使用範例\n提取專案時間軸\n// Claude中使用\n&quot;請分析 G:\\PD_DEV\\selfpagesource 的Git歷史時間軸&quot;\n \n// 返回結果範例\n{\n  &quot;timeline&quot;: {\n    &quot;totalCommits&quot;: 156,\n    &quot;dateRange&quot;: &quot;2025-01-15 - 2025-07-05&quot;,\n    &quot;commitCategories&quot;: {\n      &quot;feature&quot;: 45,\n      &quot;fix&quot;: 23,\n      &quot;docs&quot;: 38\n    }\n  }\n}\n已知限制與改進計劃\n當前限制\n\ncommit分類基於簡單模式匹配\n大型專案（10000+ commits）效能待優化\n僅支援Git，未支援其他VCS\n\n後續計劃\n\n 增加NLP語義分析\n 實現視覺化時間軸\n 支援多專案比較\n 優化記憶體使用\n\n相關資源\n\nMCP開發指南\nMCP協議官方文檔\n專案原始碼\n\n\n專案狀態：生產可用 | 維護者：PekoraTech SA Team | 授權：MIT"},"projects/project-index":{"slug":"projects/project-index","filePath":"projects/project-index.md","title":"專案清單","links":["tags/ProjectManagement","tags/AutoGenerated","tags/DeveloperTools","tags/TechStack","tags/CodeAnalysis"],"tags":["專案管理","自動生成","開發總覽","ProjectManagement","AutoGenerated","DeveloperTools","TechStack","CodeAnalysis"],"content":"🚀 專案清單\n\n最後更新：2025年6月28日 14:30:22\n本頁面由專案掃描器自動生成，展示 E:\\PD_DEV 下所有 Git 專案\n\n📊 專案統計\n\n總專案數量：12\n活躍專案：8\n技術棧分佈：AI/ML, Game Development, Browser Extensions, Flutter, Python, JavaScript, Node.js\n總程式碼行數：約 50,000+ 行\n最近活躍期：2025-06-28\n\npie title 專案類型分佈\n    &quot;AI/ML工具&quot; : 25\n    &quot;遊戲開發&quot; : 30\n    &quot;瀏覽器擴展&quot; : 20\n    &quot;移動開發&quot; : 15\n    &quot;開發工具&quot; : 10\n\n\n📁 專案列表\n🤖 test-ai-benchmark\n路徑：E:\\PD_DEV\\test-ai-benchmark\n技術棧：Python, AI/ML, Performance Testing\n最後提交：a7f3b2e - 優化批次處理效能，提升30%吞吐量 (2025-06-28)\n提交數量：47\n簡介：Python 基準測試工具，專注於 AI 模型效能評估。支援多種模型並發測試、記憶體使用監控、詳細效能分析報告生成。主要用於評估不同 AI 模型在生產環境下的表現…\n亮點功能：\n\n🚀 異步批次處理，提升 30% 效能\n📊 實時效能監控儀表板\n🔧 可配置的測試套件\n📈 詳細的分析報告生成\n\n\n🧠 test-ai-memory\n路徑：E:\\PD_DEV\\test-ai-memory\n技術棧：JavaScript, Chrome Extension, Node.js, AI/ML, Microservices\n最後提交：d2c8f9a - 新增檔案分析API，支援PDF/Word處理 (2025-06-27)\n提交數量：63\n遠端倉庫：github.com/pekora-tech/test-ai-memory\n簡介：Chrome 擴展與 AI 微服務整合專案。包含智能聊天擴展和 Ollama 代理服務，實現瀏覽器內的 AI 輔助功能。支援文字摘要、智能回覆、檔案分析等功能…\n核心組件：\n\n🧩 Chrome Extension (Manifest V3)\n🤖 Ollama 微服務代理\n📄 多格式檔案處理器\n💬 智能對話系統\n\n\n🎮 test-game-sys\n路徑：E:\\PD_DEV\\test-game-sys\n技術棧：JavaScript, Game Development, Node.js\n最後提交：f8e5a12 - 重構核心遊戲邏輯，採用組件系統架構 (2025-06-26)\n提交數量：156\n簡介：遊戲系統開發專案，包含多個子項目和迭代版本。採用組件化架構設計，支援模組化遊戲邏輯開發。包含養成、收集、戰鬥等多種遊戲機制…\n子專案結構：\n📁 danbroou-collector-系列     # 收集類遊戲（7個版本迭代）\n📁 fantasy-breeding-system     # 奇幻養成系統\n📁 alien-breeding-app         # 外星生物養成\n📁 calc-app                   # 計算器工具\n\n架構演進：\n\nv1: 基礎收集機制\nv2: Claude/DeepSeek/Gemini AI 重構\nv3: 微服務架構 + 組件系統\n\n\n🧩 test-baba-chrome-extension-tools\n路徑：E:\\PD_DEV\\test-baba-chrome-extension-tools\n技術棧：JavaScript, Chrome Extension, Web Scraping\n最後提交：b4d7e3c - 優化論壇內容解析器，支援新版介面 (2025-06-25)\n提交數量：34\n簡介：巴哈姆特論壇增強工具套件。提供論壇瀏覽優化、自動回覆、內容分析等功能。採用 Manifest V3 標準，支援現代瀏覽器擴展開發…\n主要功能：\n\n📝 論壇內容增強顯示\n🤖 智能回覆建議\n📊 使用者行為分析\n🎨 自定義主題支援\n\n\n📱 test-flutter\n路徱：E:\\PD_DEV\\test-flutter\n技術棧：Dart, Flutter, Mobile Development\n最後提交：c5a9f8e - 實現狀態管理最佳實踐，整合 Riverpod (2025-06-24)\n提交數量：28\n簡介：Flutter 跨平台移動應用開發專案。探索 Flutter 現代開發模式，包含狀態管理、網路請求、本地儲存等核心功能實現…\n技術重點：\n\n🏗️ Riverpod 狀態管理\n🌐 HTTP 客戶端封裝\n💾 本地資料持久化\n🎨 Material Design 3\n\n\n📱 test-flutter-2\n路徑：E:\\PD_DEV\\test-flutter-2\n技術棧：Dart, Flutter, Advanced UI\n最後提交：a1b2c3d - 實驗性動畫系統，支援複雜轉場效果 (2025-06-23)\n提交數量：19\n簡介：Flutter 進階實驗專案。專注於複雜 UI 組件開發和動畫系統實現。包含自定義繪製、手勢處理、效能優化等進階主題…\n實驗功能：\n\n🎬 自定義動畫控制器\n🖌️ Canvas 繪製系統\n👆 高級手勢識別\n⚡ 渲染效能優化\n\n\n🛠️ test-vs-code-extension\n路徑：E:\\PD_DEV\\test-vs-code-extension\n技術棧：TypeScript, VS Code API, Development Tools\n最後提交：e9f7d5c - 基礎擴展架構搭建，Yeoman 腳手架整合 (2025-06-22)\n提交數量：8\n簡介：Visual Studio Code 擴展開發專案。探索 VS Code 擴展 API，實現開發者生產力工具。包含程式碼片段、自動補全、語法高亮等功能…\n開發重點：\n\n🔧 Yeoman 腳手架整合\n📝 程式碼片段系統\n🎨 語法高亮支援\n🚀 開發者體驗優化\n\n\n🔧 test-baha-tools\n路徑：E:\\PD_DEV\\test-baha-tools\n技術棧：工具集, Automation\n最後提交：f6e8a9b - 新增批次處理工具 (2025-06-21)\n提交數量：15\n簡介：巴哈姆特相關的自動化工具集合。包含資料擷取、內容分析、批次操作等實用工具。專注於提升論壇使用效率和資料處理能力…\n\n🎯 test-hgame-sys\n路徑：E:\\PD_DEV\\test-hgame-sys\n技術棧：Game Development, System Design\n最後提交：d3f1e7a - 核心系統重構，模組化設計 (2025-06-20)\n提交數量：42\n簡介：特殊遊戲系統開發專案。實驗性遊戲機制設計和實現，包含複雜的系統交互和資料管理。採用模組化架構，支援靈活的功能擴展…\n\n🔍 技術棧深度分析\n語言分佈\nJavaScript/Node.js  ████████████████████ 40%\nPython             ███████████████      30%\nDart/Flutter       ██████████           20%\nTypeScript         █████                10%\n\n專案類型分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n類型專案數活躍度複雜度🤖 AI/ML2🟢 高🔴 複雜🎮 遊戲開發2🟡 中🔴 複雜🧩 瀏覽器擴展2🟢 高🟡 中等📱 移動開發2🟡 中🟡 中等🛠️ 開發工具2🔵 低🟢 簡單\n架構模式總結\n\n微服務架構：AI 記憶體專案、遊戲系統\n組件化設計：Flutter 應用、遊戲系統\n插件架構：瀏覽器擴展、VS Code 擴展\n模組化開發：所有專案均採用模組化設計\n\n\n📈 開發活躍度趨勢\n最近 30 天提交統計\n2025-06-28  ████████████ 12 commits\n2025-06-27  ██████████   10 commits\n2025-06-26  ████████     8 commits\n2025-06-25  ██████       6 commits\n2025-06-24  ████         4 commits\n2025-06-23  ██           2 commits\n2025-06-22  ████         4 commits\n2025-06-21  ██████       6 commits\n2025-06-20  ████████     8 commits\n\n重點專案提交熱力圖\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n專案本週本月總計test-ai-benchmark🔥🔥🔥🔥🔥🔥🔥47test-ai-memory🔥🔥🔥🔥🔥🔥🔥63test-game-sys🔥🔥🔥🔥156test-baba-chrome🔥🔥🔥34\n\n🎯 專案關聯圖\ngraph TB\n    A[test-ai-benchmark] --&gt; E[Performance Optimization]\n    B[test-ai-memory] --&gt; E\n    B --&gt; F[Browser Integration]\n    C[test-baba-chrome-extension-tools] --&gt; F\n    D[test-game-sys] --&gt; G[System Architecture]\n    H[test-hgame-sys] --&gt; G\n    I[test-flutter] --&gt; J[Mobile Development]\n    K[test-flutter-2] --&gt; J\n    L[test-vs-code-extension] --&gt; M[Developer Tools]\n    N[test-baha-tools] --&gt; M\n\n    E --&gt; O[Core Technologies]\n    F --&gt; O\n    G --&gt; O\n    J --&gt; O\n    M --&gt; O\n\n🚀 下一步發展計劃\n短期目標 (本週)\n\n 完成 AI 基準測試工具的 TensorRT 整合\n 發布 Chrome 擴展到 Web Store\n 優化 Flutter 應用的啟動效能\n\n中期目標 (本月)\n\n 建立統一的 CI/CD 流水線\n 實現跨專案的組件複用\n 完善專案文檔和測試覆蓋率\n\n長期願景 (本季)\n\n 建立開源專案生態系統\n 開發統一的開發者工具套件\n 撰寫技術部落格和教學內容\n\n\n🤖 自動化說明\n此頁面由 scripts/scan-projects.js 自動生成。\n使用方式：\n# 重新掃描並更新專案清單\nnode scripts/scan-projects.js\n \n# 然後重新建置網站\nnpx quartz build --serve\n掃描規則：\n\n掃描目錄：E:\\PD_DEV\n排除模式：node_modules, .git, .vscode, dist, build, public, .obsidian, 新增資料夾\n包含私人專案：否\n自動檢測技術棧：基於檔案類型和 package.json\n\n分析功能：\n\n🔍 Git 提交歷史分析\n📊 程式碼量統計\n🏷️ 自動技術棧識別\n📈 活躍度評估\n🔗 專案關聯性分析\n\n\n💡 提示：您可以在 scripts/scan-projects.js 中調整掃描規則和輸出格式。如需排除特定專案，請在掃描器配置中添加排除模式。\n\n\n🤖 自動生成於 2025-06-28 14:30:22 | 🔄 每日自動更新 | 📊 涵蓋 12 個活躍專案\nProjectManagement AutoGenerated DeveloperTools TechStack CodeAnalysis"}}