{"README":{"slug":"README","filePath":"README.md","title":"README","links":[],"tags":[],"content":"selfpagesource Content 專案對照表\n\n內部維護文件 - 專案映射與維護記錄\n最後更新：2025-07-06 v2.2\n\n專案映射表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n專案名稱文檔路徑實際資料夾位置領域狀態最後檢查Calu-appprojects/development-tools/calu-app-gradio-toolkit.md/Volumes/Code/Calu-appdevelopment-tools✅ Active2025-07-05test-ai-memoryprojects/ai-tools/test-ai-memory.md/Volumes/Code/test-ai-memoryai-tools✅ Active2025-07-06\n領域分類結構\nprojects/\n├── ai-tools/                  # AI工具領域\n│   ├── test-ai-memory.md      # AI長期記憶系統研究平台 🌟\n│   └── .project-map.json\n├── game-systems/              # 遊戲系統領域\n├── browser-extensions/        # 瀏覽器擴展領域\n├── mobile-development/        # 移動開發領域\n├── development-tools/         # 開發工具領域\n│   ├── calu-app-gradio-toolkit.md\n│   └── .project-map.json\n└── .global-project-index.json # 全域索引(待建立)\n\n維護任務\n已完成\n\n 2025-07-05 - Calu-app 專案檢查與授權補充\n\n確認專案功能正常\n添加 PEKORA-LICENSE\n更新專案文檔\n\n\n 2025-07-06 - AI記憶系統專案文檔化\n\n深度分析 test-ai-memory 三個子專案\n突出AI長期記憶技術的創新價值\n更新 ai-tools 領域映射檔案\n為AI開發社群提供學習參考\n\n\n 2025-07-05 - 優化專案組織結構\n\n建立 development-tools 領域\n移動 calu-app 到正確位置\n建立領域映射檔案\n更新工作指南 v2.1\n\n\n\n待處理\n\n 建立全域專案索引 (.global-project-index.json)\n 掃描並分類其他專案\n 建立其他領域的映射檔案\n 定期檢查專案狀態自動化\n\nv2.1 系統改進\n新增功能\n\n自動化領域分類決策樹\n專案重新分類標準流程\n系統一致性檢查清單\n多層次映射索引系統\n\n核心改進\n\n🔧 結構化管理：按領域分層組織專案\n🤖 AI友善設計：多層次JSON索引支援\n📊 系統性思維：主動發現並解決組織問題\n🔄 持續優化：建立可擴展的管理模式\n\n快速檢查清單\n每次專案維護時確認：\n\n README.md 已讀取並理解專案架構\n 專案放在正確的領域資料夾下\n PEKORA-LICENSE 已存在\n 領域映射檔案已更新\n 專案文檔已更新時間軸\n 系統一致性保持良好\n\n注意事項\n\n此文件僅供 SA 系統分析師內部使用\n專案映射保持簡潔，便於自動化處理\n定期更新確保資訊同步\n新原則：主動發現問題，系統性解決，持續優化改進\n"},"component/index":{"slug":"component/index","filePath":"component/index.md","title":"可重用技術元件庫","links":[],"tags":["技術元件","設計模式","知識資產","標準化"],"content":"可重用技術元件庫\n\n從專案實戰經驗中提煉技術精華，建立符合高內聚低耦合原則的標準化元件庫\n\n戰略定位\n長遠目標\n將散落在各專案中的技術經驗系統化整理，形成可重複利用的技術資產庫。這不僅提升開發效率，更重要的是建立個人技術能力的系統化展示平台。\n核心價值\n專案經驗 → 模式識別 → 抽象設計 → 標準元件 → 新專案應用\n    ↓          ↓          ↓          ↓           ↓\n  具體實作   通用需求   設計原則   API標準    快速開發\n\n智慧財產權保護策略\n分享與保護的平衡\n\n展示思考過程：顯示問題分析與解決方法論 ✓\n抽象化設計：展示架構思維而非具體實作 ✓\n保護核心實作：避免洩露關鍵商業邏輯 ✓\n促進技術交流：建立專業形象與技術影響力 ✓\n\n內容分級策略\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n級別內容範圍展示方式保護重點架構級設計模式、技術選型完整展示思維過程介面級API設計、模組邊界標準展示設計原則實作級核心算法、關鍵邏輯抽象展示商業價值配置級具體參數、業務規則隱藏保護競爭優勢\n元件分類架構\n基礎設施元件\n\n支撐系統運行的底層技術元件\n\n通信與整合\n\n跨域通信抽象層：解決瀏覽器安全限制\nAPI客戶端標準化：統一的錯誤處理與重試機制\n訊息佇列處理器：異步通信的可靠性保證\n\n資源管理\n\n記憶體池管理：減少GC壓力的智能分配策略\n連接池優化：資料庫與外部服務的高效連接管理\n快取策略實現：多層次快取的一致性保證\n\n效能優化元件\n\n經過實戰驗證的效能提升模式\n\n異步處理模式\n\n批次處理調度器：平衡延遲與吞吐量的智能調度\n背壓控制機制：防止系統過載的自適應限流\n管道式處理架構：流式數據的高效處理模式\n\n監控與診斷\n\n效能分析器：自動識別系統瓶頸\n資源使用追蹤：記憶體、CPU、IO的統一監控\n錯誤追蹤系統：分散式環境的錯誤關聯分析\n\n使用者介面元件\n\n解決通用UI問題的標準化元件\n\n互動模式\n\n智能對話框：支援AI助手的標準化對話介面\n檔案處理器：拖拽上傳與進度追蹤的統一實作\n表單建構器：動態生成與驗證的可配置表單系統\n\n視覺化組件\n\n即時監控圖表：效能指標的實時視覺化展示\n數據分析儀表板：多維度數據的互動式探索\n狀態指示器：系統健康狀態的直觀展示\n\nAI整合元件\n\nAI能力的標準化封裝與整合模式\n\n模型抽象層\n\n推理引擎介面：支援多種AI模型的統一調用\n結果後處理器：AI輸出的標準化處理與優化\n上下文管理器：對話狀態與記憶的持久化管理\n\n智能化工具\n\n自動化測試生成：基於AI的測試案例自動生成\n代碼品質分析：AI驅動的代碼審查與建議\n效能優化建議：智能化的系統調優建議\n\n元件開發標準\n設計原則\n單一職責：每個元件解決一個明確的問題\n開放封閉：對擴展開放，對修改封閉\n依賴倒置：依賴抽象而非具體實作\n介面隔離：客戶端不應依賴不需要的介面\n\n文檔標準\n# 元件名稱\n \n## 問題定義\n- 解決什麼業務或技術問題\n- 適用的場景與限制條件\n \n## 設計原理  \n- 第一性原理分析\n- 架構設計決策與權衡考量\n \n## 介面設計\n- 核心API定義與使用方式\n- 配置選項與客製化方案\n \n## 實作要點\n- 關鍵技術點（抽象化展示）\n- 效能考量與優化策略\n \n## 驗證結果\n- 效能指標與改進效果\n- 在具體專案中的應用效果\n \n## 相關連結\n- 源專案應用案例\n- 相關技術文檔\n元件成熟度模型\nLevel 1: 概念驗證 (Proof of Concept)\n\n特徵：基本功能實現，單一專案驗證\n文檔：問題定義與基本設計說明\n品質：功能可用，缺少邊界情況處理\n\nLevel 2: 專案就緒 (Project Ready)\n\n特徵：多專案使用，配置化支援\n文檔：完整的使用指南與API文檔\n品質：錯誤處理完善，基本效能優化\n\nLevel 3: 生產就緒 (Production Ready)\n\n特徵：效能優化完成，監控與診斷完備\n文檔：故障排除指南與最佳實踐\n品質：全面測試覆蓋，上線運行穩定\n\nLevel 4: 社群標準 (Community Standard)\n\n特徵：廣泛使用驗證，持續演進改進\n文檔：綜合性教學與進階應用指南\n品質：行業認可，成為事實標準\n\n當前元件清單\n正在開發的元件\nExtensionBridge (Level 2)\n\n來源專案：browser-extension-ecosystem\n解決問題：瀏覽器擴展與後端服務的可靠通信\n核心價值：跨域限制的優雅解決方案\n技術特點：Service Worker整合、錯誤重試、狀態同步\n\nPerformanceAnalyzer (Level 2)\n\n來源專案：AI基準測試優化\n解決問題：系統效能瓶頸的自動化識別\n核心價值：30%效能提升的方法論\n技術特點：異步分析、記憶體追蹤、瓶頸定位\n\nConfigManager (Level 1)\n\n來源專案：多專案共同需求\n解決問題：統一的配置管理與環境適應\n核心價值：減少配置相關錯誤90%\n技術特點：類型安全、環境隔離、熱更新\n\n規劃中的元件\nAsyncBatchProcessor\n\n目標問題：大量數據的高效批次處理\n預期來源：AI訓練數據處理經驗\n成熟度目標：Level 3\n\nMemoryPool\n\n目標問題：減少GC壓力的智能記憶體管理\n預期來源：遊戲引擎開發經驗\n成熟度目標：Level 3\n\nAiChatWidget\n\n目標問題：AI對話的標準化UI元件\n預期來源：多個AI整合專案\n成熟度目標：Level 2\n\n面試展示策略\n技術能力展示\n元件展示 = 問題分析能力 + 抽象設計思維 + 工程實踐經驗\n        ≠ 具體代碼實作 + 商業機密洩露\n\n展示重點\n\n系統性思考：如何從具體問題抽象出通用解決方案\n工程實踐：如何平衡效能、可維護性、可擴展性\n技術判斷：如何選擇合適的技術方案與架構模式\n持續改進：如何根據實際使用反饋優化設計\n\n避免洩露\n\n具體的商業邏輯實現\n關鍵算法的詳細實作\n特定業務的配置參數\n競爭優勢的技術細節\n\n質量保證機制\n自動化驗證\n\nAPI一致性檢查：確保介面設計的一致性\n文檔完整性驗證：確保文檔與實作的同步\n效能基準測試：驗證效能改進宣稱的真實性\n安全性掃描：檢查是否洩露敏感資訊\n\n人工審查\n\n技術價值評估：確保元件的實際價值\n抽象化程度檢查：平衡展示與保護的需求\n專業形象維護：確保展示內容的專業性\n知識關聯性確認：建立元件間的有效連結\n\n使用與貢獻指南\n如何選擇元件\n\n問題匹配度：元件是否直接解決你的核心問題\n成熟度評估：元件的可靠性與完整性等級\n整合成本：引入元件的複雜度與依賴分析\n客製化支援：是否支援你的特定需求\n\n如何貢獻新元件\n\n實戰驗證：確保元件經過至少一個真實專案的驗證\n問題普遍性：確認解決的問題具有一定的通用性\n抽象化設計：將具體實作抽象為可重用的模式\n文檔規範：按照標準模板撰寫完整文檔\n安全審查：確保不洩露敏感的商業資訊\n\n\n戰略價值：建立個人技術能力的系統化展示平台，在保護核心競爭優勢的同時，展現技術思維與工程能力。\n下一步行動：完成ExtensionBridge元件的標準化文檔，建立元件評估與選擇的決策框架。\n維護責任：PekoraTech SA Team - Architecture &amp; Standards\n更新策略：根據專案經驗持續豐富，每季度進行一次全面審查\n最後審查：2025-07-05"},"doc/guides/content-naming-standards":{"slug":"doc/guides/content-naming-standards","filePath":"doc/guides/content-naming-standards.md","title":"內容命名與組織規範","links":[],"tags":[],"content":"📝 內容命名與組織規範\n🎯 設計原則\n路徑命名（英文）\n\n檔案路徑：英文小寫，使用連字符\n目錄結構：英文單詞，語義明確\nURL 友善：避免特殊字元，SEO 友善\n\n顯示標題（中文）\n\n標題層次：清晰的中文標題結構\n閱讀體驗：符合中文使用者習慣\n語意完整：表達完整的概念\n\n📁 目錄命名標準\n主要分類\ncontent/\n├── daily-code/          # 每日程式碼心得\n├── projects/            # 專案整合分析\n├── doc/                 # 技術文檔指南\n└── component/           # 可重用組件庫\n\n子分類範例\ndoc/\n├── guides/              # 操作指南\n├── os-control/          # 作業系統控制\n├── sop/                 # 標準作業程序\n└── reference/           # 參考資料\n\n📄 檔案命名規範\nDaily-Code 命名格式\nYYYY-MM-DD-[topic-keyword].md\n\n範例：\n- 2025-06-28-ai-benchmark-optimization.md\n- 2025-06-27-chrome-extension-memory.md\n- 2025-07-05-async-pattern-design.md\n\nProjects 命名格式\n[project-category]-[main-keyword].md\n\n範例：\n- browser-extension-ecosystem.md\n- ai-development-framework.md\n- microservice-architecture-design.md\n\nComponent 命名格式\n[component-type]-[function-name].md\n\n範例：\n- ui-ai-chat-widget.md\n- infra-extension-bridge.md\n- algo-performance-analyzer.md\n- integration-oauth-handler.md\n\nDoc 命名格式\n[category]-[specific-topic].md\n\n範例：\n- github-pages-deployment.md\n- windows-directory-mirroring.md\n- api-design-best-practices.md\n\n🏷️ 標籤系統設計\n技術領域標籤\n# 程式語言\nlanguages: [&quot;JavaScript&quot;, &quot;TypeScript&quot;, &quot;Python&quot;, &quot;Rust&quot;]\n \n# 技術框架\nframeworks: [&quot;React&quot;, &quot;FastAPI&quot;, &quot;Express&quot;, &quot;Quartz&quot;]\n \n# 領域分類\ndomains: [&quot;AI&quot;, &quot;WebDev&quot;, &quot;SystemAdmin&quot;, &quot;DevOps&quot;]\n \n# 難度等級\ndifficulty: [&quot;入門&quot;, &quot;中級&quot;, &quot;高級&quot;, &quot;專家&quot;]\n內容類型標籤\n# 內容形式\ncontent_types: [&quot;教學&quot;, &quot;心得&quot;, &quot;分析&quot;, &quot;工具&quot;, &quot;SOP&quot;]\n \n# 專案階段\nproject_phases: [&quot;規劃&quot;, &quot;開發&quot;, &quot;測試&quot;, &quot;部署&quot;, &quot;維護&quot;]\n \n# 學習深度\nlearning_depth: [&quot;概念&quot;, &quot;實作&quot;, &quot;優化&quot;, &quot;創新&quot;]\n📋 Frontmatter 標準\n基本結構\n---\ntitle: &quot;中文顯示標題&quot;\ndate: &quot;YYYY-MM-DD&quot;\ntags: [&quot;標籤1&quot;, &quot;標籤2&quot;, &quot;標籤3&quot;]\ndescription: &quot;簡潔的內容描述（1-2句話）&quot;\ndifficulty: &quot;難度等級&quot;\ncategory: &quot;內容分類&quot;\n---\nDaily-Code 特殊欄位\n---\ntitle: &quot;AI 基準測試優化心得&quot;\ndate: &quot;2025-06-28&quot;\ntags: [&quot;AI&quot;, &quot;效能優化&quot;, &quot;Python&quot;, &quot;學習筆記&quot;]\ndescription: &quot;深入探討 py-benchmark 專案的效能優化策略&quot;\ndifficulty: &quot;中級&quot;\ncategory: &quot;daily-code&quot;\nproject_source: &quot;test-ai-benchmark&quot;\ntime_spent: &quot;3小時&quot;\nachievement: &quot;30% 效能提升&quot;\n---\nProjects 特殊欄位\n---\ntitle: &quot;瀏覽器擴展生態系統建構&quot;\ndate: &quot;2025-06-28&quot;\ntags: [&quot;Chrome Extension&quot;, &quot;架構設計&quot;, &quot;專案整合&quot;]\ndescription: &quot;從單一工具到完整生態系統的演進過程&quot;\ndifficulty: &quot;高級&quot;\ncategory: &quot;projects&quot;\nrelated_projects: [&quot;test-baba-chrome-extension-tools&quot;, &quot;test-ai-memory&quot;]\narchitecture_level: &quot;系統級&quot;\nbusiness_value: &quot;高&quot;\n---\nComponent 特殊欄位\n---\ntitle: &quot;擴展通信橋接器&quot;\ndate: &quot;2025-07-05&quot;\ntags: [&quot;Component&quot;, &quot;Browser Extension&quot;, &quot;通信層&quot;]\ndescription: &quot;統一的瀏覽器擴展通信抽象層&quot;\ndifficulty: &quot;中級&quot;\ncategory: &quot;component&quot;\ncomponent_type: &quot;基礎設施&quot;\nmaturity_level: &quot;Level 2&quot;\nsource_projects: [&quot;browser-extension-ecosystem&quot;]\ndependencies: [&quot;chrome.runtime&quot;]\n---\n🔗 內部連結規範\nObsidian 連結語法\n# 標準連結\n \n[[daily-code/2025-06-28-ai-benchmark-optimization|AI 基準測試優化]]\n \n# 組件連結\n \n[[component/infra-extension-bridge|擴展通信橋接器]]\n \n# 專案連結\n \n[[projects/browser-extension-ecosystem|瀏覽器擴展生態]]\n \n# 文檔連結\n \n[[doc/guides/github-pages-deployment|GitHub Pages 部署指南]]\n連結最佳實踐\n\n使用語義化的顯示文字\n避免過長的連結文字\n保持連結的時效性\n定期檢查連結有效性\n\n🎨 內容結構模板\n標題層次設計\n# 🎯 主標題（H1）- 頁面主題\n \n## 📋 次標題（H2）- 主要章節\n \n### 💡 小標題（H3）- 具體主題\n \n#### 🔧 詳細標題（H4）- 實作細節\nEmoji 使用指南\n# 常用分類 Emoji\n \n🎯 目標/重點 📋 清單/步驟 💡 想法/概念\n🔧 工具/實作 📊 數據/分析 🚀 成果/未來\n⚠️ 注意事項 ✅ 完成/成功 ❌ 錯誤/失敗\n🎨 設計/美化 🔗 連結/關聯 📚 學習/參考\n📊 品質檢查清單\n檔案建立檢查\n\n 檔案路徑符合命名規範\n Frontmatter 完整且正確\n 標題層次清晰\n 標籤使用恰當\n 內部連結有效\n\n內容品質檢查\n\n 符合第一性原理思考\n 遵循 KISS 原則\n 具體範例充足\n 智慧財產權平衡\n 技術深度適當\n\nSEO 與可發現性\n\n 描述文字清晰\n 關鍵字佈局合理\n 連結結構良好\n 標籤分類準確\n\n\n🔄 持續改善機制\n命名規範更新\n\n根據實際使用情況調整\n考慮 SEO 和使用者體驗\n保持與技術發展同步\n\n品質監控\n\n定期檢查連結有效性\n更新過時的技術內容\n優化標籤分類系統\n\n📝 本規範將隨著內容庫的發展持續優化"},"doc/guides/github-development-guide":{"slug":"doc/guides/github-development-guide","filePath":"doc/guides/github-development-guide.md","title":"GitHub 開發者精要指南","links":[],"tags":["GitHub","開發流程","Git","最佳實踐"],"content":"GitHub 開發者精要指南 🚀\n\n專精收斂而非擴散 - 聚焦最實用的 GitHub 工作流程\n\n🏷️ Commit Message 規範（核心！）\n標準格式\n&lt;type&gt;: &lt;description&gt;\n\n範例：\nfeat: 新增用戶登入功能\nfix: 修正購物車計算錯誤\ndocs: 更新 API 使用說明\nstyle: 統一程式碼格式\nrefactor: 重構資料庫查詢邏輯\n\n快速參考\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType用途範例feat✨ 新功能feat: 新增深色模式切換fix🐛 修復錯誤fix: 修正登入驗證失效問題docs📚 文檔更新docs: 更新安裝說明style🎨 格式調整style: 修正程式碼縮排refactor♻️ 程式碼重構refactor: 優化資料處理邏輯perf⚡ 效能優化perf: 改善查詢效能chore🔧 維護更新chore: 更新依賴套件\n🌊 Git 工作流程\nGitHub Flow（推薦）\ngraph LR\n    A[main] --&gt; B[創建 feature branch]\n    B --&gt; C[開發功能]\n    C --&gt; D[Push &amp; PR]\n    D --&gt; E[Code Review]\n    E --&gt; F[Merge to main]\n    F --&gt; G[自動部署]\n\n分支命名規範\n# 功能開發\nfeature/user-authentication\nfeature/dark-mode-toggle\n \n# 錯誤修復\nfix/login-validation\nhotfix/security-patch\n \n# 文檔更新\ndocs/api-documentation\ndocs/setup-guide\n📝 Pull Request 最佳實踐\nPR 標題格式\n[Type] 簡潔描述\n\n範例：\n[Feature] 新增用戶個人資料編輯\n[Fix] 修正購物車總價計算錯誤\n[Docs] 更新部署說明文檔\n\nPR 描述模板\n## 📋 變更內容\n \n簡述此 PR 的主要變更和目的\n \n## 🔗 相關 Issue\n \nCloses #123\n \n## ✅ 測試確認\n \n- [ ] 功能測試通過\n- [ ] 程式碼格式檢查通過\n- [ ] 無破壞性變更\n \n## 📸 效果預覽\n \n![功能截圖或 GIF](image-url)\n📋 Issue 管理\nIssue 標題格式\n[類型] 具體描述問題\n\n範例：\n[Bug] 登入後頁面白屏無法載入\n[Feature] 希望新增深色模式支援\n[Question] API 速率限制相關問題\n\n常用標籤系統\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n標籤顏色用途bug🔴錯誤回報enhancement🟢功能改進documentation🔵文檔相關good first issue🟡新手友善priority: high🔴高優先級\n🚀 GitHub Actions 基礎\n基本 CI/CD 結構\nname: CI/CD Pipeline\n \non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n \njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 📥 Checkout\n        uses: actions/checkout@v4\n \n      - name: 🟢 Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: &quot;22&quot;\n \n      - name: 📦 Install\n        run: npm ci\n \n      - name: 🧪 Test\n        run: npm test\n \n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == &#039;refs/heads/main&#039;\n    steps:\n      - name: 🚀 Deploy\n        run: echo &quot;部署到生產環境&quot;\n常用觸發條件\n# 推送觸發\non:\n  push:\n    branches: [main, develop]\n \n# PR 觸發\non:\n  pull_request:\n    types: [opened, synchronize]\n \n# 手動觸發\non:\n  workflow_dispatch:\n \n# 定時執行\non:\n  schedule:\n    - cron: &#039;0 2 * * *&#039;  # 每天凌晨 2 點\n📁 Repository 結構標準\n必備檔案清單\nproject-root/\n├── 📄 README.md              # 專案說明\n├── 📄 LICENSE                # 授權條款\n├── 📄 .gitignore            # 忽略規則\n├── 📄 CHANGELOG.md          # 版本記錄\n├── 📁 .github/\n│   ├── workflows/            # CI/CD 配置\n│   ├── ISSUE_TEMPLATE/       # Issue 模板\n│   └── PULL_REQUEST_TEMPLATE.md\n├── 📁 src/                   # 原始程式碼\n├── 📁 docs/                  # 技術文檔\n└── 📁 tests/                 # 測試檔案\n\nREADME.md 結構範本\n# 專案名稱\n \n一句話描述專案的核心價值\n \n## 🚀 快速開始\n \n### 安裝\n \n\\`\\`\\`bash\nnpm install\n\\`\\`\\`\n \n### 使用\n \n\\`\\`\\`bash  \nnpm start\n\\`\\`\\`\n \n## 📖 文檔\n \n- [API 文檔](docs/api.md)\n- [部署指南](docs/deployment.md)\n \n## 🤝 貢獻\n \n歡迎提交 Issue 和 PR！\n \n## 📄 授權\n \nMIT License\n🏷️ 版本管理（Semantic Versioning）\n版本號規則\nMAJOR.MINOR.PATCH\n\n1.0.0 → 1.0.1  (patch: 修復錯誤)\n1.0.1 → 1.1.0  (minor: 新增功能)\n1.1.0 → 2.0.0  (major: 重大變更)\n\nGit Tag 操作\n# 建立版本標籤\ngit tag -a v1.2.3 -m &quot;Release v1.2.3&quot;\ngit push origin v1.2.3\n \n# 查看標籤\ngit tag -l\n \n# 刪除標籤\ngit tag -d v1.2.3\ngit push origin :refs/tags/v1.2.3\n👥 Code Review 指南\nReview 重點項目\n\n✅ 功能正確性：是否達成預期目標\n✅ 程式碼品質：可讀性和維護性\n✅ 效能考量：是否有效能瓶頸\n✅ 安全性：是否有潛在風險\n✅ 測試覆蓋：是否有充分測試\n\n良好的 Review 評論\n✅ 建設性評論：\n&quot;建議在第 15 行加入錯誤處理，避免 null 的情況&quot;\n&quot;這個邏輯很清晰！可以考慮提取成獨立函數增加復用性&quot;\n&quot;程式碼風格很棒，邏輯也沒問題&quot;\n\n❌ 無效評論：\n&quot;不對&quot;\n&quot;改掉&quot;\n&quot;這樣不好&quot;\n\n🛡️ 安全最佳實踐\n敏感資訊管理\n# 絕對不要提交的檔案\n.env*\n \n# 使用 Repository Secrets\n${{ secrets.API_KEY }}\n${{ secrets.DATABASE_URL }}\n.gitignore 模板\n# 環境變數\n.env*\n \n# 依賴套件\nnode_modules/\nvendor/\n \n# 建置輸出\ndist/\nbuild/\npublic/\n*.log\n \n# IDE 設定\n.vscode/\n.idea/\n \n# 系統檔案\n.DS_Store\nThumbs.db\n🎯 實用工具\nGitHub CLI 快速操作\n# 建立 PR\ngh pr create --title &quot;feat: 新增功能&quot; --body &quot;功能描述&quot;\n \n# 建立 Issue\ngh issue create --title &quot;bug: 發現錯誤&quot; --body &quot;錯誤描述&quot;\n \n# 查看狀態\ngh pr status\ngh issue list\n推薦 VS Code 擴展\n\nGitLens - Git 歷史增強\nGitHub Pull Requests - PR 管理\nConventional Commits - Commit 輔助\nGit History - 提交歷史視覺化\n\n📊 Repository 健康度指標\n品質徽章\n![Build](github.com/user/repo/workflows/CI/badge.svg)\n![Coverage](codecov.io/gh/user/repo/branch/main/graph/badge.svg)\n![License](img.shields.io/badge/license-MIT-blue.svg)\n![Version](img.shields.io/github/v/release/user/repo)\n定期檢查項目\n\n 依賴套件安全性更新\n CI/CD 流程運行狀況\n Issue 回應時間是否合理\n 文檔是否保持最新\n 程式碼測試覆蓋率\n\n🎯 行動清單\n新專案設定（必做）\n\n 設定 commit message 規範\n 建立 .gitignore 檔案\n 撰寫清晰的 README.md\n 設定基本的 GitHub Actions\n 建立 Issue 和 PR 模板\n\n進階優化（選做）\n\n 整合程式碼品質檢查\n 設定自動化測試流程\n 建立完整的 CI/CD pipeline\n 設定依賴套件安全掃描\n\n\n💡 核心原則\n\n🎯 保持一致性：統一的命名和格式規範\n⚡ 自動化優先：能自動化的絕不手動操作\n📚 文檔同步：程式碼變更時同步更新文檔\n🔄 持續改進：根據團隊反饋優化流程\n\n記住：工具是為了提高效率，不要被流程束縛創造力！\n\n本指南濃縮了最實用的 GitHub 開發經驗，持續更新優化"},"doc/guides/github-pages-deployment":{"slug":"doc/guides/github-pages-deployment","filePath":"doc/guides/github-pages-deployment.md","title":"GitHub Pages 自動部署 SOP","links":[],"tags":["GitHub-Pages","部署","CI/CD","SOP"],"content":"GitHub Pages 自動部署 SOP ⚡\n\n從手動到自動：建立專業級的 GitHub Pages 部署流程\n\n🎯 核心架構\n雙倉庫分離設計\ngraph TB\n    A[📝 selfpagesource&lt;br/&gt;原始碼 + 內容] --&gt;|GitHub Actions| B[🌐 username.github.io&lt;br/&gt;純靜態網站]\n\n    A1[Markdown 內容] --&gt; A\n    A2[Quartz 配置] --&gt; A\n    A3[CI/CD 腳本] --&gt; A\n\n    B --&gt; C[🚀 線上網站&lt;br/&gt;username.github.io]\n\n    B1[HTML/CSS/JS] --&gt; B\n    B2[靜態資源] --&gt; B\n\n設計原則：\n\n🔒 關注點分離：原始碼與發布內容隔離\n⚡ 自動化優先：推送即部署，零手動操作\n🧹 保持純淨：發布倉庫只含靜態檔案\n\n📋 快速設定指南\nStep 1: 建立發布倉庫\n# 1. 在 GitHub 建立新倉庫\n倉庫名稱：{username}.github.io\n可見性：Public（必須）\n初始化：✅ README\n \n# 2. 啟用 GitHub Pages\nSettings → Pages → Source: Deploy from a branch → main\nStep 2: 設定 Personal Access Token\n# 1. 生成 Token\nGitHub 右上角 → Settings → Developer settings\n→ Personal access tokens → Tokens (classic)\n→ Generate new token (classic)\n \n# 2. Token 設定\nNote: &quot;Deploy to GitHub Pages&quot;\nScopes: ✅ repo (完整倉庫權限)\n \n# 3. 保存 Token 到原始碼倉庫\nselfpagesource → Settings → Secrets and variables → Actions\n→ New repository secret\nName: DEPLOY_TOKEN\nSecret: {剛才複製的 token}\nStep 3: 配置自動部署\n建立檔案：.github/workflows/deploy.yml\nname: Deploy to GitHub Pages\n \non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n \njobs:\n  deploy:\n    runs-on: ubuntu-latest\n \n    steps:\n      - name: 📥 Checkout\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n \n      - name: 🟢 Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: &quot;22&quot;\n          cache: &quot;npm&quot;\n \n      - name: 📦 Install dependencies\n        run: npm ci\n \n      - name: 🎨 Format code\n        run: npm run format\n \n      - name: 🔧 Fix permissions\n        run: chmod +x ./quartz/bootstrap-cli.mjs\n \n      - name: 🏗️ Build site\n        run: npx quartz build --output public -v\n \n      - name: 🚀 Deploy\n        uses: peaceiris/actions-gh-pages@v4\n        with:\n          personal_token: ${{ secrets.DEPLOY_TOKEN }}\n          external_repository: {username}/{username}.github.io  # 改成你的用戶名\n          publish_dir: ./public\n          publish_branch: main\n          commit_message: ${{ github.event.head_commit.message }}\n          keep_files: false\n🔄 日常工作流程\n標準開發流程\n# 1. 📝 撰寫內容\n# 在 content/ 目錄下撰寫 Markdown\n \n# 2. 🔍 本地預覽\nnpm run dev              # 開發模式（即時編譯）\nnpm run preview          # 靜態預覽（部署測試）\n \n# 3. ✅ 品質檢查\nnpm run format           # 自動格式化\nnpm run check           # 檢查語法\n \n# 4. 🚀 部署發布\ngit add .\ngit commit -m &quot;feat: 新增 XXX 文章&quot;\ngit push origin main    # 自動觸發部署\nCommit 訊息規範\nfeat: 新增功能或文章\nfix: 修正錯誤\ndocs: 更新文檔\nstyle: 格式調整\nrefactor: 程式碼重構\nchore: 維護性更新\n🛠️ 故障排除\n常見問題速查\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n問題症狀解決方案Token 權限不足remote: Permission denied重新生成 Token，確保有 repo 權限建置失敗沒有生成 index.html檢查 wikilinks 是否指向不存在的檔案404 錯誤網站無法訪問確認 GitHub Pages 設定，等待 5-10 分鐘Actions 失敗Process completed with exit code 1查看 Actions 日誌，通常是建置問題\nDebug 工具\n# 本地診斷\nnpm run build-static    # 檢查建置是否成功\nnpm run preview        # 測試真實部署效果\nls public/index.html   # 確認首頁檔案存在\n \n# 線上診斷\n# 1. GitHub Actions 頁面查看執行日誌\n# 2. 目標倉庫確認檔案是否更新\n# 3. GitHub Pages 設定確認無誤\n📊 效果驗證\n成功指標\n\n✅ Actions 狀態：綠色勾勾，無錯誤日誌\n✅ 目標倉庫：有新的 commit 和 index.html\n✅ 線上網站：內容正確更新，路由正常\n✅ 建置速度：&lt; 5 分鐘完成端到端部署\n\n效能指標\n⚡ 推送到上線：&lt; 5 分鐘\n🔄 自動化程度：100%\n🛡️ 錯誤恢復：自動重試機制\n📈 成功率：&gt; 99%\n\n🔧 進階優化\n1. 快取優化\n- name: 📦 Cache dependencies\n  uses: actions/cache@v4\n  with:\n    path: ~/.npm\n    key: ${{ runner.os }}-node-${{ hashFiles(&#039;**/package-lock.json&#039;) }}\n2. 通知整合\n- name: 📢 Notify success\n  if: success()\n  run: echo &quot;🎉 網站已成功部署到 https://{username}.github.io&quot;\n3. 多環境支援\n# 支援 staging 環境測試\n- name: 🧪 Deploy to staging\n  if: github.ref == &#039;refs/heads/develop&#039;\n  uses: peaceiris/actions-gh-pages@v4\n  with:\n    external_repository: {username}/staging.{username}.github.io\n🎯 最佳實踐\n安全性\n\n🔒 Token 管理：定期更新，使用最小權限\n🔒 敏感資訊：永不提交 .env 檔案\n🔒 權限控制：原始碼倉庫可設為私有\n\n維護性\n\n📅 定期檢查：Token 過期提醒\n📊 監控指標：部署成功率、建置時間\n📚 文檔更新：配置變更時同步更新 SOP\n\n效率性\n\n⚡ 本地測試：使用 npm run preview 預先驗證\n⚡ 增量部署：只在內容變更時觸發\n⚡ 快速回滾：保留 Git 歷史便於恢復\n\n\n📝 檢查清單\n初次設定\n\n 建立 {username}.github.io 倉庫\n 生成 Personal Access Token\n 設定 DEPLOY_TOKEN Secret\n 配置 .github/workflows/deploy.yml\n 測試首次部署\n\n日常維護\n\n Token 是否即將過期？\n Actions 執行是否正常？\n 網站載入速度如何？\n 建置時間是否合理？\n 錯誤日誌是否有異常？\n\n\n核心理念：工具是為了提高效率，一次設定，永久受益！\n本 SOP 基於實際部署經驗，持續優化更新"},"doc/guides/index":{"slug":"doc/guides/index","filePath":"doc/guides/index.md","title":"操作指南","links":["doc/guides/github-pages-deployment","doc/guides/github-development-guide","doc/guides/mcp-development-guide"],"tags":[],"content":"操作指南 📋\n\n精選的技術操作指南，聚焦實用性和可執行性\n\n🚀 部署自動化\nGitHub Pages 自動部署 SOP\n完整的 GitHub Pages 自動化部署流程，從設定到上線的一站式指南。\n核心特色：\n\n🏗️ 雙倉庫分離架構設計\n⚡ CI/CD 全自動化流程\n🛠️ 完整的故障排除指南\n📊 效能監控和最佳實踐\n\n💻 開發流程\nGitHub 開發者精要指南\nGitHub 開發工作流程的核心要點，遵循「專精收斂而非擴散」原則。\n核心特色：\n\n🏷️ Commit Message 標準規範\n📝 Pull Request 最佳實踐\n👥 Code Review 指導原則\n🛡️ 安全性最佳實踐\n\n🤖 AI工具開發\nMCP工具開發指南\n基於Model Context Protocol的AI工具開發完整指南，從Git分析器實作經驗提煉的標準化流程。\n核心特色：\n\n🏷️ 標準化的MCP Server開發框架\n🛡️ 安全性與權限控制最佳實踐\n⚡ 效能優化與監控策略\n📝 完整的測試與部署流程\n\n🎯 設計理念\n專精收斂原則\n\n聚焦核心：只保留最實用的操作步驟\n避免冗餘：移除過度詳細的理論說明\n實戰導向：每個指南都經過實際驗證\n\n可執行性優先\n\n步驟明確：每個操作都有具體的命令和截圖\n錯誤預防：預先說明常見問題和解決方案\n快速上手：新手也能按照指南快速完成任務\n\n📈 使用建議\n🔖 快速導航\n\n首次部署：從 GitHub Pages 部署 SOP 開始\n日常開發：參考 GitHub 開發者指南\n遇到問題：查看各指南的故障排除章節\n\n📱 最佳體驗\n\n桌面端：完整的操作截圖和詳細說明\n行動端：響應式設計，隨時隨地查閱\n離線使用：可列印為 PDF 隨身攜帶\n\n🔄 持續更新\n這些指南會根據實際使用經驗持續優化：\n\n✅ 新增更多實用案例\n✅ 優化操作步驟描述\n✅ 補充最新的最佳實踐\n✅ 修正使用者回饋的問題\n\n\n核心理念：指南是為了解決實際問題，而不是展示理論知識！"},"doc/guides/knowledge-graph-building":{"slug":"doc/guides/knowledge-graph-building","filePath":"doc/guides/knowledge-graph-building.md","title":"知識圖譜建構指南","links":["tags/KnowledgeGraph","tags/Obsidian","tags/Learning","tags/SystemThinking"],"tags":["KnowledgeGraph","Obsidian","Learning","SystemThinking"],"content":"🕸️ 知識圖譜建構指南\n🎯 核心理念\n知識網路化思維\n\n知識不是孤立的點，而是相互連接的網路。透過有意識的連結建構，將零散的學習心得轉化為系統性的知識資產。\n\n🔗 連結策略框架\n1. 橫向連結（同層級）\n# Daily-Code 之間的連結\n \n[[daily-code/2025-06-28-ai-benchmark-optimization]] ↔ [[daily-code/2025-06-27-async-pattern]]\n相同技術領域的不同應用\n \n# Projects 之間的連結\n \n[[projects/browser-extension-ecosystem]] ↔ [[projects/ai-development-framework]]\n架構設計模式的共通性\n2. 縱向連結（跨層級）\n# Daily-Code → Projects（由點到面）\n \n[[daily-code/2025-06-28-ai-benchmark-optimization]] → [[projects/ai-performance-suite]]\n技術心得匯聚成專案洞察\n \n# Projects → Components（抽象化）\n \n[[projects/browser-extension-ecosystem]] → [[component/infra-extension-bridge]]\n專案經驗提煉為可重用組件\n \n# Doc → Daily-Code（理論到實踐）\n \n[[doc/guides/performance-optimization]] → [[daily-code/2025-06-28-ai-benchmark-optimization]]\n指南文檔的具體應用案例\n3. 概念連結（主題群集）\n# 效能優化主題群\n \n- [[daily-code/ai-benchmark-optimization]]\n- [[daily-code/memory-pool-management]]\n- [[component/async-batch-processor]]\n- [[projects/performance-monitoring-system]]\n- [[doc/guides/performance-best-practices]]\n🏗️ 連結類型分類\n技術傳承連結\n# 學習軌跡\n \n初學 → 應用 → 深化 → 創新\n[[doc/basic-concepts]] → [[daily-code/first-attempt]] → [[daily-code/optimization]] → [[component/innovative-solution]]\n問題解決連結\n# 問題-方案-驗證鏈\n \n[[daily-code/problem-discovery]] → [[doc/solution-research]] → [[daily-code/implementation]] → [[projects/production-validation]]\n工具生態連結\n# 工具鏈關係\n \n[[doc/tool-setup]] ↔ [[daily-code/tool-usage]] ↔ [[component/tool-wrapper]] ↔ [[projects/tool-integration]]\n🎨 連結建構技巧\n1. 智能標籤系統\n# 在 frontmatter 中建立關聯\nrelated_concepts: [&quot;效能優化&quot;, &quot;異步程式設計&quot;, &quot;記憶體管理&quot;]\nprerequisite: [&quot;基礎 JavaScript&quot;, &quot;Node.js 概念&quot;]\nnext_steps: [&quot;分散式系統&quot;, &quot;微服務架構&quot;]\ndifficulty_progression: [&quot;入門篇&quot;, &quot;進階篇&quot;, &quot;專家篇&quot;]\n2. 內容中的自然連結\n# 在內容中自然地引用相關知識\n \n當我在 [[daily-code/chrome-extension-memory|Chrome 擴展記憶體優化]] 中遇到類似問題時，\n這裡的 [[component/memory-pool|記憶體池管理組件]] 提供了通用的解決方案。\n這種模式在 [[projects/browser-extension-ecosystem|瀏覽器擴展生態系統]] 中得到了驗證。\n3. 反向連結利用\n# 在新內容中主動連結到相關的舊內容\n \n這個概念最初在 [[daily-code/2025-06-15-design-pattern]] 中提到，\n後來在 [[projects/architecture-evolution]] 中得到深化，\n現在我們將其抽象為 [[component/design-pattern-library]] 中的標準模式。\n📊 連結密度指標\n理想的連結比例\n📝 Daily-Code: 每篇 3-5 個內部連結\n🎯 Projects: 每篇 5-10 個內部連結\n🧩 Components: 每個 4-8 個內部連結\n📚 Doc: 每篇 2-6 個內部連結\n\n連結品質評估\n\n深度連結 &gt; 表面連結\n語義連結 &gt; 機械連結\n雙向連結 &gt; 單向連結\n主題群集 &gt; 零散連結\n\n🔄 知識演進追蹤\n概念成熟度路徑\ngraph LR\n    A[初次接觸&lt;br/&gt;daily-code] --&gt; B[深入理解&lt;br/&gt;doc研究]\n    B --&gt; C[實際應用&lt;br/&gt;projects整合]\n    C --&gt; D[抽象組件&lt;br/&gt;component提煉]\n    D --&gt; E[系統化知識&lt;br/&gt;knowledge-graph]\n\n    E --&gt; F[新問題發現]\n    F --&gt; A\n\n版本化知識更新\n# 在文章末尾追蹤知識演進\n \n## 🔄 知識演進記錄\n \n### v1.0 (2025-06-28)\n \n- 初次實作並記錄基礎概念\n- 連結到 [[doc/performance-basics]]\n \n### v2.0 (2025-07-05)\n \n- 發現與 [[component/async-pattern]] 的關聯\n- 整合到 [[projects/performance-ecosystem]]\n \n### v3.0 (2025-07-15)\n \n- 抽象為 [[component/performance-analyzer]]\n- 成為 [[knowledge-map/performance-optimization]] 的核心節點\n🎯 實際應用策略\n1. 每日連結檢查（5分鐘）\n# 撰寫新內容時的檢查清單\n \n- [ ] 這個概念之前在哪裡提過？\n- [ ] 相關的技術棧有哪些文章？\n- [ ] 有沒有可以抽象為組件的部分？\n- [ ] 這個問題在其他專案中如何解決？\n- [ ] 需要補充哪些文檔支援？\n2. 週期性圖譜重構（每月）\n# 知識圖譜健康檢查\n \n- [ ] 孤立節點識別與連結\n- [ ] 過度連結的簡化\n- [ ] 新興主題群集發現\n- [ ] 過時連結的清理\n- [ ] 缺失連結的補充\n3. 主題地圖建構（每季）\n# 建立主題導航頁面\n \n## 🗺️ 效能優化知識地圖\n \n### 🎯 核心概念\n \n- [[doc/performance-fundamentals]]\n- [[doc/measurement-methodology]]\n \n### 💡 實戰經驗\n \n- [[daily-code/ai-benchmark-optimization]]\n- [[daily-code/memory-optimization-patterns]]\n \n### 🔧 可重用工具\n \n- [[component/performance-analyzer]]\n- [[component/benchmark-framework]]\n \n### 🚀 系統整合\n \n- [[projects/monitoring-infrastructure]]\n- [[projects/optimization-pipeline]]\n🧠 智慧連結建議\n自動化連結發現\n# 概念：未來可開發的自動化工具\ndef suggest_links(new_content):\n    &quot;&quot;&quot;基於內容相似度和標籤重疊建議相關連結&quot;&quot;&quot;\n    similar_content = find_similar_by_tags(new_content)\n    concept_matches = extract_shared_concepts(new_content)\n    return generate_link_suggestions(similar_content, concept_matches)\n連結強度計算\n# 連結關係強度評估\n \n🔗 強連結：直接相關，互相依賴\n🔸 中連結：間接相關，可參考\n⚪ 弱連結：概念相似，可延伸\n\n💡 最佳實踐總結\nDo’s（應該做的）\n\n✅ 撰寫時主動思考關聯性\n✅ 定期回顧和強化連結\n✅ 建立主題導航頁面\n✅ 追蹤知識演進過程\n✅ 平衡連結數量和品質\n\nDon’ts（避免的）\n\n❌ 機械式的過度連結\n❌ 無意義的連結堆疊\n❌ 忽視反向連結建構\n❌ 僅建立當下的連結\n❌ 缺乏連結維護\n\n核心指標\n🎯 連結有效性 &gt; 90%\n🔗 平均連結深度 &gt; 3 層\n📊 主題覆蓋率 &gt; 80%\n🔄 更新頻率 &lt; 1 月\n\n\n🎯 目標：將零散知識轉化為系統性的個人技術資產庫\n📈 價值：透過知識網路效應，放大每一次學習的長期價值\nKnowledgeGraph Obsidian Learning SystemThinking"},"doc/guides/mcp-development-guide":{"slug":"doc/guides/mcp-development-guide","filePath":"doc/guides/mcp-development-guide.md","title":"MCP工具開發指南","links":[],"tags":["MCP","AI工具開發","協議實現","系統整合"],"content":"MCP工具開發指南\n\n基於Git分析器實作經驗，建立MCP工具開發的標準化流程與最佳實踐\n\nMCP協議概述\n協議設計理念\nModel Context Protocol (MCP) 是一個開放標準，旨在實現AI助手與外部工具的標準化整合。它解決了AI助手需要與各種外部系統互動的問題，提供了統一的介面規範。\n核心概念\nAI Assistant ←→ MCP Client ←→ MCP Server ←→ External Tools/Data\n\n主要組件\n\nMCP Server：實現具體工具功能的服務端\nMCP Client：AI助手側的協議客戶端\nTransport：通信傳輸層（stdio、HTTP、WebSocket等）\nTools：具體的功能實現單元\n\n協議特性\n\n工具註冊：動態註冊可用工具及其schema\n類型安全：基於JSON Schema的強類型介面\n錯誤處理：標準化的錯誤回報機制\n可擴展性：支援自定義工具與資源類型\n\n開發環境設置\n基礎依賴\n# 核心MCP SDK\nnpm install @modelcontextprotocol/sdk\n \n# 常用開發依賴\nnpm install --save-dev @types/node typescript tsx\n專案結構建議\nmcp-tool-project/\n├── package.json              # 專案配置\n├── index.js                  # 主要MCP Server\n├── lib/                      # 工具實現邏輯\n│   ├── tools/               # 各個工具的實現\n│   ├── utils/               # 共用工具函數\n│   └── types/               # 類型定義\n├── test/                     # 測試檔案\n├── examples/                 # 使用範例\n└── README.md                 # 文檔說明\n\nTypeScript設定\n{\n  &quot;compilerOptions&quot;: {\n    &quot;target&quot;: &quot;ES2022&quot;,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;moduleResolution&quot;: &quot;node&quot;,\n    &quot;allowSyntheticDefaultImports&quot;: true,\n    &quot;esModuleInterop&quot;: true,\n    &quot;strict&quot;: true,\n    &quot;skipLibCheck&quot;: true\n  }\n}\nMCP Server基礎架構\n核心Server類別設計\nimport { Server } from &#039;@modelcontextprotocol/sdk/server/index.js&#039;;\nimport { StdioServerTransport } from &#039;@modelcontextprotocol/sdk/server/stdio.js&#039;;\n \nclass BaseMCPServer {\n  constructor(name, version, capabilities = {}) {\n    this.server = new Server(\n      { name, version },\n      { capabilities: { tools: {}, ...capabilities } }\n    );\n    \n    this.setupHandlers();\n    this.setupErrorHandling();\n  }\n \n  setupHandlers() {\n    // 註冊工具列表處理器\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return { tools: this.getToolDefinitions() };\n    });\n \n    // 註冊工具調用處理器\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      return await this.handleToolCall(request);\n    });\n  }\n \n  async handleToolCall(request) {\n    const { name, arguments: args } = request.params;\n    \n    try {\n      const handler = this.toolHandlers[name];\n      if (!handler) {\n        throw new Error(`未知工具: ${name}`);\n      }\n      \n      return await handler(args);\n    } catch (error) {\n      return this.formatError(error);\n    }\n  }\n \n  formatError(error) {\n    return {\n      content: [{\n        type: &#039;text&#039;,\n        text: `錯誤: ${error.message}`\n      }]\n    };\n  }\n}\n工具註冊機制\nclass ToolRegistry {\n  constructor() {\n    this.tools = new Map();\n  }\n \n  register(name, definition, handler) {\n    this.tools.set(name, {\n      definition,\n      handler\n    });\n  }\n \n  getDefinitions() {\n    return Array.from(this.tools.values()).map(tool =&gt; tool.definition);\n  }\n \n  getHandler(name) {\n    return this.tools.get(name)?.handler;\n  }\n}\n \n// 使用範例\nconst registry = new ToolRegistry();\n \nregistry.register(&#039;my_tool&#039;, {\n  name: &#039;my_tool&#039;,\n  description: &#039;工具描述&#039;,\n  inputSchema: {\n    type: &#039;object&#039;,\n    properties: {\n      param1: { type: &#039;string&#039;, description: &#039;參數說明&#039; }\n    },\n    required: [&#039;param1&#039;]\n  }\n}, async (args) =&gt; {\n  // 工具實現邏輯\n  return { content: [{ type: &#039;text&#039;, text: &#039;結果&#039; }] };\n});\n工具設計最佳實踐\n1. 單一職責原則\n每個工具應該專注於一個明確的功能領域：\n// ✅ 好的設計：職責明確\nconst fileReadTool = {\n  name: &#039;read_file&#039;,\n  description: &#039;讀取指定檔案內容&#039;,\n  // ...\n};\n \n// ❌ 避免：功能過於複雜\nconst fileSystemTool = {\n  name: &#039;filesystem_operations&#039;,\n  description: &#039;執行各種檔案系統操作（讀取、寫入、刪除、移動...）&#039;,\n  // ...\n};\n2. 介面設計原則\n參數設計\n// 參數命名清晰且具描述性\nconst toolSchema = {\n  inputSchema: {\n    type: &#039;object&#039;,\n    properties: {\n      projectPath: {\n        type: &#039;string&#039;,\n        description: &#039;專案的絕對路徑&#039;,\n        examples: [&#039;/path/to/project&#039;]\n      },\n      maxItems: {\n        type: &#039;number&#039;,\n        description: &#039;最大返回項目數量&#039;,\n        default: 50,\n        minimum: 1,\n        maximum: 1000\n      },\n      options: {\n        type: &#039;object&#039;,\n        description: &#039;額外配置選項&#039;,\n        properties: {\n          includeDetails: {\n            type: &#039;boolean&#039;,\n            description: &#039;是否包含詳細資訊&#039;,\n            default: false\n          }\n        }\n      }\n    },\n    required: [&#039;projectPath&#039;]\n  }\n};\n輸出標準化\n// 標準化的成功回應格式\nfunction formatSuccess(data, metadata = {}) {\n  return {\n    content: [{\n      type: &#039;text&#039;,\n      text: JSON.stringify({\n        success: true,\n        data,\n        metadata: {\n          timestamp: new Date().toISOString(),\n          ...metadata\n        }\n      }, null, 2)\n    }]\n  };\n}\n \n// 標準化的錯誤回應格式\nfunction formatError(error, context = {}) {\n  return {\n    content: [{\n      type: &#039;text&#039;, \n      text: JSON.stringify({\n        success: false,\n        error: {\n          message: error.message,\n          code: error.code || &#039;UNKNOWN_ERROR&#039;,\n          context\n        },\n        timestamp: new Date().toISOString()\n      }, null, 2)\n    }]\n  };\n}\n3. 錯誤處理策略\n分層錯誤處理\nclass ErrorHandler {\n  static async withErrorHandling(operation, context = {}) {\n    try {\n      return await operation();\n    } catch (error) {\n      // 記錄錯誤\n      console.error(&#039;Tool execution error:&#039;, {\n        error: error.message,\n        stack: error.stack,\n        context\n      });\n \n      // 分類錯誤類型\n      if (error instanceof ValidationError) {\n        return this.formatValidationError(error);\n      } else if (error instanceof PermissionError) {\n        return this.formatPermissionError(error);\n      } else {\n        return this.formatGenericError(error);\n      }\n    }\n  }\n \n  static formatValidationError(error) {\n    return {\n      content: [{\n        type: &#039;text&#039;,\n        text: `參數驗證錯誤: ${error.message}`\n      }]\n    };\n  }\n}\n用戶友好的錯誤訊息\nconst errorMessages = {\n  FILE_NOT_FOUND: &#039;指定的檔案不存在，請檢查路徑是否正確&#039;,\n  PERMISSION_DENIED: &#039;沒有足夠的權限執行此操作&#039;,\n  INVALID_FORMAT: &#039;檔案格式不正確或已損壞&#039;,\n  NETWORK_ERROR: &#039;網路連接失敗，請檢查網路狀態&#039;,\n  TIMEOUT: &#039;操作超時，請嘗試減少資料量或稍後重試&#039;\n};\n \nfunction createUserFriendlyError(errorCode, details = &#039;&#039;) {\n  const baseMessage = errorMessages[errorCode] || &#039;發生未知錯誤&#039;;\n  return new Error(details ? `${baseMessage}。詳細資訊: ${details}` : baseMessage);\n}\n安全性與權限控制\n1. 輸入驗證\nclass InputValidator {\n  static validatePath(path) {\n    // 路徑正規化\n    const normalizedPath = pathModule.resolve(path);\n    \n    // 防止目錄遍歷攻擊\n    if (normalizedPath.includes(&#039;..&#039;)) {\n      throw new ValidationError(&#039;路徑包含非法字符&#039;);\n    }\n    \n    // 檢查允許的目錄範圍\n    const allowedPaths = [&#039;/allowed/path1&#039;, &#039;/allowed/path2&#039;];\n    if (!allowedPaths.some(allowed =&gt; normalizedPath.startsWith(allowed))) {\n      throw new PermissionError(&#039;路徑不在允許範圍內&#039;);\n    }\n    \n    return normalizedPath;\n  }\n \n  static validateStringLength(value, maxLength = 1000) {\n    if (typeof value !== &#039;string&#039;) {\n      throw new ValidationError(&#039;參數必須為字串&#039;);\n    }\n    \n    if (value.length &gt; maxLength) {\n      throw new ValidationError(`字串長度不能超過 ${maxLength} 字符`);\n    }\n    \n    return value;\n  }\n}\n2. 權限控制\nclass PermissionManager {\n  constructor(config) {\n    this.allowedOperations = new Set(config.allowedOperations || []);\n    this.blockedPatterns = config.blockedPatterns || [];\n  }\n \n  checkOperation(operation) {\n    if (!this.allowedOperations.has(operation)) {\n      throw new PermissionError(`操作 ${operation} 不被允許`);\n    }\n  }\n \n  checkContent(content) {\n    for (const pattern of this.blockedPatterns) {\n      if (pattern.test(content)) {\n        throw new SecurityError(&#039;內容包含敏感資訊&#039;);\n      }\n    }\n  }\n}\n3. 資料清理\nclass DataSanitizer {\n  static sanitizeForOutput(data) {\n    if (typeof data === &#039;string&#039;) {\n      return this.sanitizeString(data);\n    } else if (Array.isArray(data)) {\n      return data.map(item =&gt; this.sanitizeForOutput(item));\n    } else if (typeof data === &#039;object&#039; &amp;&amp; data !== null) {\n      return this.sanitizeObject(data);\n    }\n    return data;\n  }\n \n  static sanitizeString(str) {\n    // 移除敏感資訊\n    const sensitivePatterns = [\n      /password[=:]\\s*\\S+/gi,\n      /api[_-]?key[=:]\\s*\\S+/gi,\n      /secret[=:]\\s*\\S+/gi\n    ];\n \n    let cleaned = str;\n    for (const pattern of sensitivePatterns) {\n      cleaned = cleaned.replace(pattern, &#039;[REDACTED]&#039;);\n    }\n \n    return cleaned;\n  }\n \n  static sanitizeObject(obj) {\n    const cleaned = {};\n    for (const [key, value] of Object.entries(obj)) {\n      cleaned[key] = this.sanitizeForOutput(value);\n    }\n    return cleaned;\n  }\n}\n效能優化策略\n1. 異步處理最佳實踐\nclass AsyncProcessor {\n  constructor(concurrency = 5) {\n    this.concurrency = concurrency;\n  }\n \n  async processBatch(items, processor) {\n    const results = [];\n    \n    for (let i = 0; i &lt; items.length; i += this.concurrency) {\n      const batch = items.slice(i, i + this.concurrency);\n      const batchResults = await Promise.all(\n        batch.map(async (item, index) =&gt; {\n          try {\n            return await processor(item, i + index);\n          } catch (error) {\n            console.error(`處理項目 ${i + index} 失敗:`, error);\n            return { error: error.message };\n          }\n        })\n      );\n      results.push(...batchResults);\n    }\n    \n    return results;\n  }\n}\n2. 快取機制\nclass CacheManager {\n  constructor(options = {}) {\n    this.cache = new Map();\n    this.maxSize = options.maxSize || 1000;\n    this.ttl = options.ttl || 3600000; // 1小時\n  }\n \n  set(key, value) {\n    // 清理過期項目\n    this.cleanup();\n    \n    // 如果快取已滿，移除最舊的項目\n    if (this.cache.size &gt;= this.maxSize) {\n      const firstKey = this.cache.keys().next().value;\n      this.cache.delete(firstKey);\n    }\n \n    this.cache.set(key, {\n      value,\n      timestamp: Date.now()\n    });\n  }\n \n  get(key) {\n    const entry = this.cache.get(key);\n    if (!entry) return null;\n \n    if (Date.now() - entry.timestamp &gt; this.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n \n    return entry.value;\n  }\n \n  cleanup() {\n    const now = Date.now();\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp &gt; this.ttl) {\n        this.cache.delete(key);\n      }\n    }\n  }\n}\n3. 記憶體管理\nclass MemoryManager {\n  static monitorMemoryUsage() {\n    const usage = process.memoryUsage();\n    return {\n      rss: Math.round(usage.rss / 1024 / 1024) + &#039; MB&#039;,\n      heapTotal: Math.round(usage.heapTotal / 1024 / 1024) + &#039; MB&#039;,\n      heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + &#039; MB&#039;,\n      external: Math.round(usage.external / 1024 / 1024) + &#039; MB&#039;\n    };\n  }\n \n  static async withMemoryLimit(operation, limitMB = 512) {\n    const initialMemory = process.memoryUsage().heapUsed;\n    \n    try {\n      const result = await operation();\n      \n      const finalMemory = process.memoryUsage().heapUsed;\n      const usedMemory = (finalMemory - initialMemory) / 1024 / 1024;\n      \n      if (usedMemory &gt; limitMB) {\n        console.warn(`記憶體使用超過限制: ${usedMemory.toFixed(2)}MB &gt; ${limitMB}MB`);\n      }\n      \n      return result;\n    } finally {\n      // 強制垃圾回收（如果可用）\n      if (global.gc) {\n        global.gc();\n      }\n    }\n  }\n}\n測試策略\n1. 單元測試結構\nimport { describe, it, expect, beforeEach } from &#039;vitest&#039;;\nimport { MockMCPServer } from &#039;./mocks/MockMCPServer.js&#039;;\n \ndescribe(&#039;工具名稱&#039;, () =&gt; {\n  let server;\n \n  beforeEach(() =&gt; {\n    server = new MockMCPServer();\n  });\n \n  describe(&#039;正常情況&#039;, () =&gt; {\n    it(&#039;should handle valid input correctly&#039;, async () =&gt; {\n      const request = {\n        name: &#039;tool_name&#039;,\n        arguments: { param: &#039;valid_value&#039; }\n      };\n \n      const response = await server.handleToolCall(request);\n      \n      expect(response.content[0].type).toBe(&#039;text&#039;);\n      const result = JSON.parse(response.content[0].text);\n      expect(result.success).toBe(true);\n    });\n  });\n \n  describe(&#039;錯誤處理&#039;, () =&gt; {\n    it(&#039;should handle invalid input gracefully&#039;, async () =&gt; {\n      const request = {\n        name: &#039;tool_name&#039;,\n        arguments: { param: null }\n      };\n \n      const response = await server.handleToolCall(request);\n      const result = JSON.parse(response.content[0].text);\n      \n      expect(result.success).toBe(false);\n      expect(result.error.message).toContain(&#039;參數驗證錯誤&#039;);\n    });\n  });\n});\n2. 整合測試\ndescribe(&#039;MCP協議整合&#039;, () =&gt; {\n  let transport;\n  let server;\n \n  beforeEach(async () =&gt; {\n    transport = new MockTransport();\n    server = new MyMCPServer();\n    await server.connect(transport);\n  });\n \n  it(&#039;should register tools correctly&#039;, async () =&gt; {\n    const response = await transport.sendRequest({\n      method: &#039;tools/list&#039;\n    });\n \n    expect(response.tools).toHaveLength(expectedToolCount);\n    expect(response.tools[0]).toHaveProperty(&#039;name&#039;);\n    expect(response.tools[0]).toHaveProperty(&#039;description&#039;);\n    expect(response.tools[0]).toHaveProperty(&#039;inputSchema&#039;);\n  });\n});\n3. 效能測試\ndescribe(&#039;效能測試&#039;, () =&gt; {\n  it(&#039;should complete within time limit&#039;, async () =&gt; {\n    const startTime = Date.now();\n    \n    const result = await server.handleLargeDataOperation({\n      dataSize: 10000\n    });\n    \n    const duration = Date.now() - startTime;\n    \n    expect(duration).toBeLessThan(5000); // 5秒內完成\n    expect(result.success).toBe(true);\n  });\n \n  it(&#039;should not exceed memory limit&#039;, async () =&gt; {\n    const initialMemory = process.memoryUsage().heapUsed;\n    \n    await server.handleMemoryIntensiveOperation();\n    \n    const finalMemory = process.memoryUsage().heapUsed;\n    const memoryIncrease = finalMemory - initialMemory;\n    \n    expect(memoryIncrease).toBeLessThan(100 * 1024 * 1024); // 100MB限制\n  });\n});\n部署與發布\n1. package.json設定\n{\n  &quot;name&quot;: &quot;@yourorg/mcp-tool-name&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;type&quot;: &quot;module&quot;,\n  &quot;bin&quot;: {\n    &quot;mcp-tool-name&quot;: &quot;./index.js&quot;\n  },\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;node index.js&quot;,\n    &quot;dev&quot;: &quot;node --inspect index.js&quot;,\n    &quot;test&quot;: &quot;vitest&quot;,\n    &quot;build&quot;: &quot;tsc&quot;,\n    &quot;lint&quot;: &quot;eslint .&quot;,\n    &quot;format&quot;: &quot;prettier --write .&quot;\n  },\n  &quot;engines&quot;: {\n    &quot;node&quot;: &quot;&gt;=18.0.0&quot;\n  },\n  &quot;files&quot;: [\n    &quot;index.js&quot;,\n    &quot;lib/&quot;,\n    &quot;README.md&quot;,\n    &quot;LICENSE&quot;\n  ]\n}\n2. npx支援\n#!/usr/bin/env node\n \nimport { program } from &#039;commander&#039;;\nimport { MyMCPServer } from &#039;./lib/server.js&#039;;\n \nprogram\n  .name(&#039;mcp-tool-name&#039;)\n  .description(&#039;工具描述&#039;)\n  .version(&#039;1.0.0&#039;);\n \nprogram\n  .command(&#039;start&#039;)\n  .description(&#039;啟動MCP服務器&#039;)\n  .action(async () =&gt; {\n    const server = new MyMCPServer();\n    await server.start();\n  });\n \nprogram\n  .command(&#039;test&#039;)\n  .description(&#039;測試工具功能&#039;)\n  .argument(&#039;&lt;testParam&gt;&#039;, &#039;測試參數&#039;)\n  .action(async (testParam) =&gt; {\n    // 執行測試邏輯\n  });\n \nif (import.meta.url === `file://${process.argv[1]}`) {\n  program.parse();\n}\n3. Claude Desktop整合\n{\n  &quot;mcpServers&quot;: {\n    &quot;your-tool&quot;: {\n      &quot;command&quot;: &quot;npx&quot;,\n      &quot;args&quot;: [&quot;@yourorg/mcp-tool-name&quot;, &quot;start&quot;],\n      &quot;cwd&quot;: &quot;/path/to/working/directory&quot;,\n      &quot;env&quot;: {\n        &quot;NODE_ENV&quot;: &quot;production&quot;\n      }\n    }\n  }\n}\n監控與日誌\n1. 結構化日誌\nclass Logger {\n  constructor(service) {\n    this.service = service;\n  }\n \n  info(message, context = {}) {\n    this.log(&#039;INFO&#039;, message, context);\n  }\n \n  error(message, error, context = {}) {\n    this.log(&#039;ERROR&#039;, message, {\n      ...context,\n      error: {\n        message: error.message,\n        stack: error.stack\n      }\n    });\n  }\n \n  log(level, message, context) {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      service: this.service,\n      message,\n      context\n    };\n \n    console.error(JSON.stringify(logEntry));\n  }\n}\n2. 效能監控\nclass PerformanceMonitor {\n  static withMetrics(name, operation) {\n    return async (...args) =&gt; {\n      const start = performance.now();\n      const startMemory = process.memoryUsage().heapUsed;\n \n      try {\n        const result = await operation(...args);\n        \n        this.recordSuccess(name, start, startMemory);\n        return result;\n      } catch (error) {\n        this.recordError(name, error, start, startMemory);\n        throw error;\n      }\n    };\n  }\n \n  static recordSuccess(name, start, startMemory) {\n    const duration = performance.now() - start;\n    const memoryUsed = process.memoryUsage().heapUsed - startMemory;\n \n    console.error(JSON.stringify({\n      type: &#039;performance&#039;,\n      operation: name,\n      status: &#039;success&#039;,\n      duration: `${duration.toFixed(2)}ms`,\n      memoryUsed: `${(memoryUsed / 1024 / 1024).toFixed(2)}MB`\n    }));\n  }\n}\n最佳實踐總結\n開發原則\n\n單一職責：每個工具專注一個明確功能\n介面清晰：參數命名具描述性，提供預設值\n錯誤友好：提供清晰的錯誤訊息和恢復建議\n效能意識：考慮大資料集和長時間操作的效能影響\n安全第一：輸入驗證、權限控制、資料清理\n\n架構模式\n\n分層設計：協議層、業務邏輯層、資料存取層\n依賴注入：便於測試和配置管理\n插件架構：支援功能擴展和自定義\n事件驅動：非同步操作和狀態管理\n\n品質保證\n\n全面測試：單元測試、整合測試、效能測試\n代碼品質：ESLint、Prettier、TypeScript\n文檔完整：API文檔、使用範例、故障排除\n持續整合：自動化測試和部署流程\n\n\n指南價值：基於實際專案經驗的MCP工具開發標準化流程，可大幅降低開發門檻並提升工具品質。\n適用範圍：所有需要整合AI助手的專業工具開發場景\n技術等級：中高級\n維護策略：隨MCP生態系統發展持續更新\n文檔維護：PekoraTech SA Team - Technical Writing\n最後更新：2025-07-05\n版本：v1.0"},"doc/guides/quartz-localization-guide":{"slug":"doc/guides/quartz-localization-guide","filePath":"doc/guides/quartz-localization-guide.md","title":"Quartz 導航中文化指南","links":[],"tags":["Quartz","中文化","導航","設定"],"content":"Quartz 導航中文化指南 🌐\n\n讓你的 Quartz 網站導航完全中文化\n\n🎯 實現效果\n修改前：\n📁 doc\n  📁 guides\n    📄 github-development-guide\n    📄 github-pages-deployment\n\n修改後：\n📁 文件\n  📁 操作指南\n    📄 GitHub 開發者精要指南\n    📄 GitHub Pages 自動部署 SOP\n\n🔧 實作方法\n方法一：使用 Frontmatter（推薦）\n在每個檔案的開頭添加 frontmatter：\n---\ntitle: &quot;中文標題&quot;\ndescription: &quot;中文描述&quot;\n---\n \n# 原始標題\n方法二：修改檔案名稱（不推薦）\n直接重新命名檔案和資料夾，但會影響現有連結。\n📋 完整實作步驟\n第一步：為資料夾建立 index.md\n# 為每個要中文化的資料夾建立 index.md\ncontent/\n├── doc/\n│   ├── index.md          # title: &quot;文件&quot;\n│   └── guides/\n│       └── index.md      # title: &quot;操作指南&quot;\n第二步：設定資料夾的 index.md\ndoc/index.md：\n---\ntitle: &quot;文件&quot;\ndescription: &quot;技術文檔與操作指南&quot;\n---\n \n# 技術文檔中心 📚\nguides/index.md：\n---\ntitle: &quot;操作指南&quot;\ndescription: &quot;實用的技術操作指南&quot;\n---\n \n# 操作指南 📋\n第三步：設定檔案的 frontmatter\n每個 .md 檔案都加上中文 title：\n---\ntitle: &quot;GitHub Pages 自動部署 SOP&quot;\ndescription: &quot;從手動到自動的部署流程&quot;\ntags: [&quot;GitHub Pages&quot;, &quot;部署&quot;, &quot;CI/CD&quot;]\n---\n🎨 進階中文化技巧\n1. 標籤中文化\ntags: [&quot;GitHub&quot;, &quot;開發流程&quot;, &quot;最佳實踐&quot;, &quot;CI/CD&quot;, &quot;自動部署&quot;]\n2. 分類中文化\ncategory: &quot;技術文檔&quot;\nsection: &quot;部署指南&quot;\n3. 描述中文化\ndescription: &quot;完整的 GitHub Pages 自動化部署流程指南&quot;\n🔍 驗證中文化效果\n測試方法\n# 1. 本地測試\nnpm run preview\n \n# 2. 檢查導航\n# 訪問：http://localhost:3000\n# 查看左側導航是否顯示中文\n \n# 3. 測試所有頁面\n# 確認每個頁面標題都正確顯示中文\n檢查清單\n\n ✅ 主要資料夾顯示中文名稱\n ✅ 子資料夾顯示中文名稱\n ✅ 檔案標題顯示中文\n ✅ 頁面 meta 資訊中文化\n ✅ 標籤系統中文化\n\n🛠️ 故障排除\n常見問題\n❌ 導航仍顯示英文\n原因：缺少 frontmatter 或 index.md\n解決：確保每個資料夾都有 index.md 且包含 title\n❌ 中文顯示亂碼\n原因：檔案編碼問題\n解決：確保檔案使用 UTF-8 編碼保存\n❌ 部分頁面沒有中文化\n原因：忘記添加 frontmatter\n解決：檢查每個 .md 檔案是否都有 title\n📊 Quartz 導航顯示優先級\nQuartz 決定導航顯示名稱的優先級：\n\nfrontmatter title（最高優先級）\n第一個 H1 標題\n檔案名稱（最低優先級）\n\n🎯 最佳實踐\n命名規範\n# 資料夾 index.md\ntitle: &quot;文件&quot;           # 簡潔的中文名稱\ndescription: &quot;...&quot;      # 詳細的中文描述\n \n# 檔案 frontmatter\ntitle: &quot;GitHub Pages 自動部署 SOP&quot;  # 具體的功能描述\ndescription: &quot;...&quot;                  # 詳細說明\ntags: [&quot;部署&quot;, &quot;自動化&quot;]            # 中文標籤\n一致性原則\n\n用詞統一：相同概念使用相同中文詞彙\n風格一致：標題格式和長度保持一致\n分類清晰：使用邏輯清楚的中文分類\n\n🔄 批量處理腳本\n如果檔案很多，可以用腳本批量處理：\n# 查找所有缺少 frontmatter 的檔案\nfind content/ -name &quot;*.md&quot; -exec grep -L &quot;^---&quot; {} \\;\n \n# 為檔案批量添加 frontmatter（需要自訂）\n# 建議手動處理以確保準確性\n📈 維護建議\n定期檢查\n\n新增檔案時記得添加中文 frontmatter\n重新命名時同步更新 title\n定期檢查是否有遺漏的中文化項目\n\n文檔標準\n建立團隊的中文化標準：\n\n統一的詞彙表\n標題命名規範\n描述撰寫指南\n\n\n🎉 完成效果\n實施以上步驟後，你的 Quartz 網站將擁有：\n\n✅ 完全中文化的導航\n✅ 一致的中文用詞\n✅ 專業的文檔架構\n✅ 良好的使用者體驗\n\n現在你可以享受完全中文化的技術文檔網站了！\n\n本指南基於 Quartz 4.5.1，適用於所有中文化需求"},"doc/index":{"slug":"doc/index","filePath":"doc/index.md","title":"技術文件中心","links":["os-control/","guides/github-development-guide","guides/content-naming-standards","guides/github-pages-deployment"],"tags":["技術文件","標準化","操作程序","系統分析"],"content":"技術文件中心\n\n實用的技術指南與標準化操作程序，體現系統分析師的專業文件管理能力\n\n功能定位\n核心目標\n建立標準化的技術知識管理體系，將技術操作程序、系統配置方法、開發流程規範等進行系統化整理，形成可重複使用的技術資產。\n設計理念\n遵循「專精收斂而非擴散」的原則，聚焦最實用的技術知識和流程，避免資訊過載，確保每份文件都能直接解決實際問題。\n安全與保密機制\n文件分級策略\nPublic級別：開源工具使用、通用技術方法\nInternal級別：內部工具配置、專案特定流程  \nConfidential級別：核心技術架構、商業敏感配置\n\n審查流程\n\n內容安全檢查：識別並過濾敏感技術細節\n格式標準驗證：確保文件符合專業規範\n實用性評估：驗證操作程序的可執行性\n關聯性檢查：建立文件間的邏輯連結\n\n文件架構體系\n系統管理類\n作業系統控制技術\n功能範圍：\n\nWindows目錄鏡像與符號連結管理\n跨平台檔案系統整合方案\n開發環境自動化部署腳本\n系統權限與安全控制策略\n\n技術特點：\n\n提供可執行的批次檔案與腳本\n詳細的故障排除指南\n跨系統版本的相容性考量\n安全性與效能的平衡策略\n\n系統監控與診斷（規劃中）\n\n效能監控指標定義與收集\n系統健康檢查自動化腳本\n日誌分析與異常告警機制\n資源使用優化建議\n\n開發流程類\nGitHub開發流程規範\n標準化內容：\n\nCommit Message標準格式與最佳實踐\nPull Request流程與Code Review規範\n分支管理策略與版本控制規則\n自動化CI/CD管道配置指南\n\n品質保證：\n\n代碼品質檢查自動化\n測試覆蓋率要求與監控\n部署流程的標準化與安全性\n錯誤處理與回滾策略\n\n內容命名與組織規範\n標準化策略：\n\n英文路徑與中文顯示的雙軌制設計\n檔案命名的一致性與可維護性\nFrontmatter規範與metadata管理\n跨平台相容性考量\n\n部署運維類\nGitHub Pages自動部署SOP\n核心內容：\n\n雙倉庫分離的架構設計原理\nCI/CD自動化流程配置與優化\n部署失敗的診斷與故障排除\n效能監控與優化策略\n\n安全考量：\n\n密鑰管理與權限控制\n部署環境的隔離與保護\n敏感內容的自動化過濾\n災難恢復與備份策略\n\n容器化部署（規劃中）\n\nDocker映像檔的標準化建構流程\nKubernetes集群的部署與管理\n微服務監控與日誌聚合\n自動擴展與負載均衡配置\n\n工具配置類\n開發環境標準化\n配置管理：\n\nObsidian整合配置與外掛推薦\nVS Code擴展的標準化安裝與配置\nGit全域配置的最佳實踐\nNode.js開發環境的統一設定\n\n自動化腳本：\n\n環境初始化的一鍵部署腳本\n依賴套件的自動更新與管理\n配置檔案的備份與同步機制\n多專案間的配置一致性保證\n\n效能分析工具\n\n系統效能監控工具的配置與使用\n代碼品質分析工具的整合\n自動化測試工具的配置與運行\n持續整合工具的部署與維護\n\n文件品質標準\n結構化要求\n# 文件標題\n \n## 概述\n- 解決什麼問題\n- 適用的環境與條件\n- 預期達成的效果\n \n## 前置需求\n- 必要的軟體與工具\n- 權限與環境要求\n- 相關背景知識\n \n## 操作步驟\n- 詳細的執行步驟\n- 命令行指令與參數說明\n- 檢查點與驗證方法\n \n## 故障排除\n- 常見問題與解決方案\n- 錯誤訊息的診斷指南\n- 緊急處理程序\n \n## 相關資源\n- 官方文件連結\n- 相關工具與參考資料\n- 進階學習資源\n品質要求\n\n準確性：所有操作步驟經過實際驗證\n完整性：包含必要的背景知識與故障處理\n時效性：定期更新以反映最新的技術變化\n可讀性：清晰的結構與恰當的技術用語\n\n使用指南\n文件檢索策略\n\n分類瀏覽：按技術領域快速定位相關文件\n標籤搜尋：使用技術標籤進行精確查找\n全文搜索：關鍵字快速定位具體內容\n關聯導覽：透過文件間連結發現相關資源\n\n實踐建議\n\n循序漸進：從基礎文件開始，逐步深入專業內容\n實際操作：結合實際專案需求使用相關文件\n回饋改進：在使用過程中記錄問題與改進建議\n知識分享：將使用經驗回饋到文件改進中\n\n維護與更新機制\n內容審查週期\n\n月度審查：檢查文件的時效性與準確性\n季度更新：根據技術發展更新相關內容\n年度重構：重新評估文件架構與組織方式\n\n品質控制流程\n內容創建 → 技術審查 → 安全檢查 → 格式驗證 → 發布上線 → 使用回饋 → 持續改進\n\n貢獻機制\n\n問題回報：透過標準化流程回報文件問題\n改進建議：提供文件內容與結構的改進意見\n新文件貢獻：按照標準模板貢獻新的技術文件\n專家審查：邀請相關領域專家進行內容審查\n\n未來發展規劃\n短期目標（1-3個月）\n\n完善現有文件的標準化格式\n建立自動化的文件品質檢查機制\n增加更多實用的技術操作指南\n\n中期目標（3-6個月）\n\n建立文件間的智能關聯推薦系統\n發展基於AI的文件內容自動生成工具\n建立社群驅動的文件貢獻機制\n\n長期願景（6-12個月）\n\n形成行業標準的技術文件管理模式\n建立技術知識的智能化檢索與推薦系統\n發展跨組織的技術文件協作平台\n\n統計數據\n文件覆蓋範圍\n系統管理：40% (涵蓋Windows、Linux基礎操作)\n開發流程：35% (包含Git、CI/CD、代碼品質)\n部署運維：20% (GitHub Pages、容器化部署)\n工具配置：5% (開發環境、效能分析工具)\n\n使用統計\n\n總文件數量：15+篇\n月度檢視：200+次\n用戶回饋滿意度：90%+\n文件更新頻率：每週2-3次\n\n\n核心價值：提供實用、準確、及時的技術文件，支援高效的技術工作流程，並確保知識的有效傳承與積累。\n使用原則：文件是為了解決實際問題，而不是展示技術知識的複雜性。\n維護責任：PekoraTech SA Team - Documentation &amp; Standards\n品質目標：實用性優於完整性，準確性優於複雜性\n最後更新：2025-07-05"},"doc/os-control/index":{"slug":"doc/os-control/index","filePath":"doc/os-control/index.md","title":"作業系統控制","links":["doc/os-control/windows-directory-mirroring","GitHub-開發者精要指南","GitHub-Pages-自動部署-SOP","專案架構設計模式","VS-Code-開發環境設定","Git-配置優化","Terminal-效率提升","tags/作業系統","tags/系統管理","tags/Windows","tags/Linux","tags/macOS","tags/自動化","tags/腳本","tags/檔案系統","tags/權限管理","tags/開發環境"],"tags":["作業系統","系統管理","自動化","Windows","Linux","macOS","腳本","檔案系統","權限管理","開發環境"],"content":"作業系統控制技術 ⚙️\n\n跨平台系統管理與開發環境優化的核心技術\n\n🎯 技術範疇\n專注於作業系統層級的控制技術，提升開發效率與環境一致性。\n設計原則\n\nKISS 原則：保持簡潔，避免過度工程\n第一性原理：理解底層機制而非死記指令\n跨平台思維：考慮不同系統的相容性方案\n自動化優先：可重複執行的腳本化操作\n\n📂 技術分類\n🔗 檔案系統管理\nWindows 平台\n\n目錄鏡像技術\n\n符號連結 (Symbolic Link) 實作\n接合點 (Junction) 替代方案\n多電腦開發環境統一\n自動化批次檔案範例\n\n\n\nLinux/macOS 平台\n\n軟連結管理（計劃中）\n\nln -s 符號連結最佳實踐\n相對路徑與絕對路徑策略\n跨檔案系統連結考量\n\n\n\n🚀 程序與服務管理\nWindows 服務\n\n服務自動化管理（計劃中）\n\nsc 指令進階應用\nPowerShell 服務腳本\n開發環境服務編排\n\n\n\n系統程序\n\n程序監控與控制（計劃中）\n\ntasklist/taskkill 自動化\n記憶體使用監控\n效能瓶頸識別\n\n\n\n🔐 權限與安全\n存取控制\n\n檔案權限管理（計劃中）\n\nWindows ACL 設定\nLinux chmod/chown 最佳實踐\n安全性與便利性平衡\n\n\n\n環境隔離\n\n沙盒與容器技術（計劃中）\n\nWindows Sandbox 應用\nDocker 環境隔離\n開發環境污染防護\n\n\n\n🌐 網路與連線\n網路診斷\n\n連線問題排除（計劃中）\n\nping/tracert 深度分析\nnetstat 連線監控\n防火牆規則管理\n\n\n\n遠端存取\n\n遠端控制技術（計劃中）\n\nSSH 金鑰管理\nRDP 最佳化設定\nVPN 自動化連線\n\n\n\n🛠️ 實用工具集\n批次處理腳本\n📁 scripts/\n├── 📄 setup-dev-env.bat        # 開發環境快速設定\n├── 📄 cleanup-temp.bat         # 暫存檔案清理\n├── 📄 backup-projects.bat      # 專案檔案備份\n└── 📄 network-diagnostics.bat  # 網路問題診斷\n\nPowerShell 模組\n📁 powershell/\n├── 📄 FileSystemUtils.psm1     # 檔案系統操作\n├── 📄 ServiceManager.psm1      # 服務管理\n├── 📄 NetworkTools.psm1        # 網路工具\n└── 📄 SecurityUtils.psm1       # 安全性工具\n\n🎨 最佳實踐模式\n腳本設計原則\n\n錯誤處理：詳細的錯誤訊息與復原機制\n參數驗證：輸入參數的完整性檢查\n日誌記錄：操作過程的可追蹤記錄\n向後相容：考慮不同系統版本的相容性\n\n自動化策略\n\n冪等性：重複執行不會產生副作用\n原子性：要麼完全成功，要麼完全失敗\n可回復性：提供還原機制或回滾操作\n測試優先：在安全環境中驗證腳本\n\n🔄 相關技術連結\n開發流程整合\n\nGitHub 開發者精要指南：版本控制與系統整合\nGitHub Pages 自動部署 SOP：CI/CD 與系統自動化\n專案架構設計模式：系統層級的專案組織\n\n工具配置\n\nVS Code 開發環境設定：編輯器與系統整合\nGit 配置優化：版本控制系統設定\nTerminal 效率提升：命令列工具優化\n\n📊 技術成熟度\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n技術領域完成度優先級預計完成Windows 檔案系統✅ 100%🔥 高已完成Linux 檔案系統📝 0%🔥 高2025-07-15程序管理📝 0%⚡ 中2025-07-30網路診斷📝 0%⚡ 中2025-08-15安全管理📝 0%💡 低2025-09-01\n🚀 學習路徑建議\n初學者路徑\n\n\n檔案系統基礎\n\n理解絕對路徑與相對路徑\n掌握基本檔案操作指令\n學習權限概念\n\n\n\n自動化入門\n\n撰寫簡單的批次檔案\n理解環境變數的使用\n學習基本的錯誤處理\n\n\n\n實際應用\n\n建立個人開發環境腳本\n設定常用工具的自動化\n整合到日常工作流程\n\n\n\n進階學習\n\n\n跨平台技能\n\n掌握 Windows/Linux/macOS 差異\n學習通用的腳本設計模式\n理解不同系統的限制\n\n\n\n企業級應用\n\n大規模部署腳本設計\n安全性與合規性考量\n監控與維護策略\n\n\n\n💡 實戰案例\n開發環境標準化\n問題：團隊成員使用不同的開發環境配置\n解決：建立統一的環境設定腳本\nREM 範例：開發環境快速設定\n@echo off\necho 設定統一開發環境...\n \nREM 建立標準目錄結構\nmkdir D:\\PD_DEV\nmkdir D:\\PD_DEV\\projects\nmkdir D:\\PD_DEV\\tools\nmkdir D:\\PD_DEV\\temp\n \nREM 設定環境變數\nsetx DEV_ROOT &quot;D:\\PD_DEV&quot;\nsetx PATH &quot;%PATH%;D:\\PD_DEV\\tools&quot;\n \necho 開發環境設定完成！\n專案備份自動化\n問題：手動備份容易遺忘且不一致\n解決：自動化備份腳本與排程\nREM 範例：專案自動備份\n@echo off\nset BACKUP_DIR=E:\\Backup\\%date:~0,10%\nmkdir &quot;%BACKUP_DIR%&quot;\n \nrobocopy &quot;D:\\PD_DEV&quot; &quot;%BACKUP_DIR%&quot; /MIR /XD .git node_modules\necho 備份完成：%BACKUP_DIR%\n🏷️ 相關標籤\n作業系統 系統管理 Windows Linux macOS 自動化 腳本 檔案系統 權限管理 開發環境\n\n📝 更新記錄\nv1.0.0 (2025-07-05)\n\n✨ 建立作業系統控制技術分類架構\n📖 完成 Windows 目錄鏡像技術文檔\n🎯 規劃跨平台系統管理技術路線圖\n💡 提供學習路徑與實戰案例\n\n\n專注於實用的系統控制技術，提升開發效率與環境一致性"},"doc/os-control/windows-directory-mirroring":{"slug":"doc/os-control/windows-directory-mirroring","filePath":"doc/os-control/windows-directory-mirroring.md","title":"Windows 目錄鏡像技術","links":["批次處理自動化","開發環境標準化","備份策略優化","tags/Windows","tags/符號連結","tags/開發環境","tags/路徑管理","tags/自動化","tags/批次處理","tags/檔案系統","tags/Junction","tags/Symlink"],"tags":["Windows","符號連結","開發環境","路徑管理","自動化","批次處理","檔案系統","Junction","Symlink"],"content":"Windows 目錄鏡像技術 🔗\n\n透過符號連結技術實現跨電腦統一路徑管理的最佳實踐\n\n🎯 問題背景\n多電腦開發困境\n在多台電腦間進行開發時，常遇到以下問題：\n\n路徑不一致：不同電腦習慣使用不同磁碟機（C:、D:、E:、G:）\n腳本失效：絕對路徑導致批次檔案無法通用\n配置複雜：每台電腦都需要重新設定開發環境路徑\n協作困難：團隊成員無法使用統一的專案路徑\n\n解決方案概覽\nWindows 提供兩種「目錄鏡像」技術：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n技術類型權限需求功能特性適用場景符號連結 (Symbolic Link)管理員功能完整，支援相對路徑正式環境部署接合點 (Junction)一般使用者僅支援絕對路徑，資料夾專用日常開發使用\n💡 實作原理\n符號連結運作機制\n實際檔案位置：G:\\PD_DEV\\project-name\\\n鏡像存取路徑：D:\\PD_DEV\\project-name\\  ←→  G:\\PD_DEV\\project-name\\\n                    ↑                           ↑\n                符號連結指向              實際檔案儲存\n\n技術優勢\n\n透明存取：應用程式無法區分真實路徑與鏡像路徑\n即時同步：修改任一路徑下的檔案都會立即反映\n空間節省：不會複製檔案，僅建立指向關係\n效能優異：存取速度與直接存取相同\n\n🛠️ 實作步驟\n第一步：批次檔案準備\n為了自動化處理不同電腦的路徑映射，建立以下批次檔案：\n主電腦版本（G:\\PD_DEV → D:\\PD_DEV）\n@echo off\necho 設定開發資料夾映射\necho.\n \nREM 檢查是否以管理員身分執行\nnet session &gt;nul 2&gt;&amp;1\nif %errorLevel% == 0 (\n    echo 以管理員身分執行中...\n) else (\n    echo 警告：建議以管理員身分執行此批次檔案\n    echo.\n)\n \nREM 檢查目標資料夾是否存在\nif exist &quot;D:\\PD_DEV&quot; (\n    echo D:\\PD_DEV 已存在，請先備份或移除\n    pause\n    exit /b 1\n)\n \nREM 檢查來源資料夾\nif not exist &quot;G:\\PD_DEV&quot; (\n    echo 錯誤：來源資料夾 G:\\PD_DEV 不存在\n    pause\n    exit /b 1\n)\n \necho 建立符號連結：D:\\PD_DEV ---&gt; G:\\PD_DEV\necho.\n \nREM 建立目錄符號連結（需要管理員權限）\nmklink /D &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \nif %errorLevel% == 0 (\n    echo.\n    echo 成功建立符號連結！\n    echo 現在您可以透過 D:\\PD_DEV 存取 G:\\PD_DEV 的所有內容\n) else (\n    echo.\n    echo 符號連結建立失敗，嘗試建立接合點...\n    echo.\n \n    REM 如果符號連結失敗，嘗試建立接合點（不需要管理員權限）\n    mklink /J &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \n    if %errorLevel% == 0 (\n        echo 成功建立接合點！\n        echo 現在您可以透過 D:\\PD_DEV 存取 G:\\PD_DEV 的所有內容\n    ) else (\n        echo 建立失敗，請檢查權限或路徑\n    )\n)\n \necho.\necho 測試連結...\nif exist &quot;D:\\PD_DEV\\selfpagesource&quot; (\n    echo 測試成功：可以透過 D:\\PD_DEV 存取專案資料夾\n) else (\n    echo 測試失敗：無法透過 D:\\PD_DEV 存取專案資料夾\n)\n \npause\n副電腦版本（E:\\PD_DEV → D:\\PD_DEV）\n@echo off\necho 設定開發資料夾映射 (E: 版本)\necho.\n \nREM 檢查目標資料夾是否存在\nif exist &quot;D:\\PD_DEV&quot; (\n    echo D:\\PD_DEV 已存在，請先備份或移除\n    pause\n    exit /b 1\n)\n \nREM 檢查來源資料夾\nif not exist &quot;E:\\PD_DEV&quot; (\n    echo 錯誤：來源資料夾 E:\\PD_DEV 不存在\n    pause\n    exit /b 1\n)\n \necho 建立符號連結：D:\\PD_DEV ---&gt; E:\\PD_DEV\necho.\n \nREM 建立目錄符號連結\nmklink /D &quot;D:\\PD_DEV&quot; &quot;E:\\PD_DEV&quot;\n \nif %errorLevel% == 0 (\n    echo 成功建立符號連結！\n) else (\n    echo 符號連結建立失敗，嘗試建立接合點...\n    mklink /J &quot;D:\\PD_DEV&quot; &quot;E:\\PD_DEV&quot;\n \n    if %errorLevel% == 0 (\n        echo 成功建立接合點！\n    ) else (\n        echo 建立失敗，請檢查權限或路徑\n    )\n)\n \npause\n第二步：執行映射設定\n\n\n選擇對應的批次檔案\n\n主電腦：執行 setup_dev_mapping.bat\n副電腦：執行 setup_dev_mapping_E_drive.bat\n\n\n\n執行前準備\n# 檢查來源資料夾是否存在\ndir G:\\PD_DEV    # 主電腦\ndir E:\\PD_DEV    # 副電腦\n \n# 確認目標位置沒有衝突\ndir D:\\PD_DEV    # 應該顯示找不到檔案\n\n\n執行設定\n\n右鍵點擊批次檔案\n選擇「以系統管理員身分執行」\n按照提示完成設定\n\n\n\n第三步：驗證映射結果\n# 測試檔案存取\ndir D:\\PD_DEV\ndir D:\\PD_DEV\\selfpagesource\n \n# 檢查連結類型\ndir D:\\ | findstr PD_DEV\n# 應該顯示 &lt;SYMLINKD&gt; 或 &lt;JUNCTION&gt;\n \n# 測試檔案操作\necho test &gt; D:\\PD_DEV\\test.txt\ntype G:\\PD_DEV\\test.txt    # 主電腦\ntype E:\\PD_DEV\\test.txt    # 副電腦\ndel D:\\PD_DEV\\test.txt\n🔧 進階管理\n清理映射的批次檔案\n@echo off\necho 移除開發資料夾映射\necho.\n \nREM 檢查 D:\\PD_DEV 是否存在且為連結\nif not exist &quot;D:\\PD_DEV&quot; (\n    echo D:\\PD_DEV 不存在，無需移除\n    pause\n    exit /b 0\n)\n \nREM 檢查是否為符號連結或接合點\ndir &quot;D:\\PD_DEV&quot; | findstr &quot;&lt;SYMLINKD&gt;&quot; &gt;nul\nif %errorLevel% == 0 (\n    echo 偵測到符號連結\n    set LINK_TYPE=符號連結\n    goto remove_link\n)\n \ndir &quot;D:\\PD_DEV&quot; | findstr &quot;&lt;JUNCTION&gt;&quot; &gt;nul\nif %errorLevel% == 0 (\n    echo 偵測到接合點\n    set LINK_TYPE=接合點\n    goto remove_link\n)\n \necho D:\\PD_DEV 存在但不是符號連結或接合點\necho 為安全起見，不會刪除此資料夾\npause\nexit /b 1\n \n:remove_link\necho 即將移除 %LINK_TYPE%：D:\\PD_DEV\necho.\nset /p confirm=確定要繼續嗎？(Y/N):\nif /i not &quot;%confirm%&quot;==&quot;Y&quot; (\n    echo 操作取消\n    pause\n    exit /b 0\n)\n \nREM 移除符號連結或接合點\nrmdir &quot;D:\\PD_DEV&quot;\n \nif %errorLevel% == 0 (\n    echo 成功移除 %LINK_TYPE%\n) else (\n    echo 移除失敗，請檢查權限\n)\n \npause\n常用管理指令\n# 查看所有符號連結\ndir C:\\ /AL\ndir D:\\ /AL\n \n# 查看特定目錄的連結資訊\nfsutil reparsepoint query &quot;D:\\PD_DEV&quot;\n \n# 手動建立符號連結\nmklink /D &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \n# 手動建立接合點\nmklink /J &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \n# 手動移除連結\nrmdir &quot;D:\\PD_DEV&quot;\n⚠️ 注意事項與最佳實踐\n安全考量\n\n備份重要資料：設定前先備份現有的 D:\\PD_DEV（如果存在）\n權限管理：符號連結需要管理員權限，接合點則不需要\n路徑驗證：確保來源路徑存在且可存取\n\n使用限制\n\nWindows 版本：Windows Vista 以上支援符號連結\n檔案系統：目標磁碟機必須使用 NTFS 檔案系統\n網路位置：不建議對網路磁碟機使用符號連結\n\n故障排除\n常見錯誤及解決方案\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n錯誤訊息可能原因解決方法存取被拒權限不足以管理員身分執行目標已存在D:\\PD_DEV 已存在先移除或重新命名現有資料夾找不到來源來源路徑不存在確認 G: 或 E: 磁碟機路徑正確不支援的檔案系統FAT32 檔案系統轉換為 NTFS 或使用其他磁碟機\n🎯 實際應用場景\n開發環境統一\n情境：三台電腦的不同配置\n- 主機：G:\\PD_DEV\\project-name\\\n- 筆電：E:\\PD_DEV\\project-name\\\n- 公司：C:\\PD_DEV\\project-name\\\n\n解決：統一使用 D:\\PD_DEV\\project-name\\\n\n腳本通用性\nREM 原本：需要針對每台電腦修改路徑\ncd G:\\PD_DEV\\selfpagesource    REM 主機\ncd E:\\PD_DEV\\selfpagesource    REM 筆電\ncd C:\\PD_DEV\\selfpagesource    REM 公司\n \nREM 現在：所有電腦使用相同腳本\ncd D:\\PD_DEV\\selfpagesource    REM 通用\n配置檔案同步\n// VS Code settings.json 可以使用統一路徑\n{\n  &quot;terminal.integrated.cwd&quot;: &quot;D:\\\\PD_DEV&quot;,\n  &quot;git.defaultCloneDirectory&quot;: &quot;D:\\\\PD_DEV&quot;\n}\n🔄 相關技術比較\nWindows 檔案系統功能對比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n功能符號連結接合點硬連結快捷方式需要管理員權限✅❌❌❌支援資料夾✅✅❌✅支援檔案✅❌✅✅跨磁碟機✅✅❌✅透明存取✅✅✅❌相對路徑✅❌N/A❌\n選擇建議\n\n優先選擇：符號連結（功能最完整）\n備選方案：接合點（無需管理員權限）\n避免使用：快捷方式（應用程式支援度差）\n\n📚 延伸學習\n相關命令深入\n# mklink 完整語法\nmklink [[/d] | [/h] | [/j]] &lt;連結&gt; &lt;目標&gt;\n/d    建立目錄符號連結（預設為檔案）\n/h    建立硬連結而非符號連結\n/j    建立目錄接合點\n \n# fsutil 連結管理\nfsutil reparsepoint query &lt;路徑&gt;      # 查詢連結資訊\nfsutil reparsepoint delete &lt;路徑&gt;     # 刪除連結點\n進階應用\n\n批次處理自動化：結合 PowerShell 進行大量路徑映射\n開發環境標準化：團隊協作的路徑規範制定\n備份策略優化：利用符號連結簡化備份腳本\n\n🏷️ 相關標籤\nWindows 符號連結 開發環境 路徑管理 自動化 批次處理 檔案系統 Junction Symlink\n\n📝 更新記錄\nv1.0.0 (2025-07-05)\n\n✨ 建立 Windows 目錄鏡像技術完整指南\n🔧 提供自動化批次檔案實作\n📖 涵蓋符號連結與接合點技術對比\n⚠️ 詳細的注意事項與故障排除\n🎯 實際開發場景應用範例\n\n\n本文檔旨在解決多電腦開發環境路徑統一問題，提供可直接執行的自動化解決方案"},"index-backup":{"slug":"index-backup","filePath":"index-backup.md","title":"PekoraTech 🚀 技術知識庫","links":["daily-code/","daily-code/2025-06-28-ai-benchmark-optimization","daily-code/2025-06-27-chrome-extension-memory","daily-code/2025-06-26-flutter-state-management","projects/","projects/ai-development-suite","projects/game-system-evolution","projects/browser-extension-ecosystem","projects/flutter-cross-platform","tags/GameDev","tags/ChromeExtension","tags/Flutter","tags/Microservice","tags/Optimization"],"tags":["首頁","技術","開發者","GameDev","ChromeExtension","Flutter","Microservice","Optimization"],"content":"Welcome to PekoraTech 🎯\n\n“專精收斂而非擴散” - 從第一性原理思考，專注於深度而非廣度的技術探索\n\n\n  \n  \n  \n\n🎯 核心理念\n🧠 第一性原理思考\n\n需求本質：快速記錄技術心得 + 方便日後查找 + 自動整合專案經驗\n技術選擇：Markdown 原生 &gt; 複雜框架，現成工具 &gt; 重新發明輪子\n架構設計：內容分離、處理分離、部署分離\n\n⚡ KISS 原則實踐\ngraph LR\n    A[想法] --&gt; B[Markdown]\n    B --&gt; C[Quartz]\n    C --&gt; D[GitHub Pages]\n    D --&gt; E[世界分享]\n\n🎛️ 高內聚低耦合\n📝 內容層    - daily-code（日常心得）/ projects（深度分析）分離\n🔧 處理層    - 掃描、建置、部署功能獨立\n🚀 部署層    - 原始碼與靜態檔案分離\n\n\n🗂️ 內容導覽\n📅 每日程式碼\n\n像技術日記一樣快速記錄開發心得，沒有絕對規劃但方便查找\n\n最新文章：\n\nAI 基準測試優化心得\nChrome 擴展記憶體管理\nFlutter 狀態管理最佳實踐\n\n🎯 專案整合\n\n手動撰寫的深度技術分析，整合多個專案的思考與經驗\n\n| 專案類別         | 描述                                   | 狀態                 |\n| ---------------- | -------------------------------------- | -------------------- | --------- |\n| 🤖 AI 工具鏈 | AI 開發工具套件    | 🟢 活躍   |\n| 🎮 遊戲開發  | 遊戲系統架構演進   | 🟡 迭代中 |\n| 🧩 擴展開發  | 瀏覽器擴展生態系   | 🟢 活躍   |\n| 📱 移動開發  | Flutter 跨平台實踐 | 🔵 研究中 |\n\n🛠️ 技術棧概覽\n核心技術\n\n  🤖 AI/ML\n  🎮 Game Dev\n  🧩 Browser Ext\n  📱 Flutter\n  ⚡ Node.js\n  🐍 Python\n\n專案統計\n📊 總專案數量：12+\n🔥 活躍專案：5\n📈 迭代版本：20+\n🎯 核心領域：AI、遊戲、工具開發\n\n\n🎨 探索方式\n🔍 智能搜尋\n使用頂部搜尋框，支援：\n\n內容全文搜尋\n標籤過濾\n即時預覽\n\n🏷️ 標籤導覽\n點擊任何標籤探索相關內容：\n#AI GameDev ChromeExtension Flutter Microservice Optimization\n🌐 關係圖譜\n透過關係圖發現內容間的隱藏連結，找到意想不到的知識組合。\n📱 響應式設計\n完美支援桌面、平板、手機閱讀體驗。\n\n💡 設計哲學\n\n可維護性\n\n模組化設計：每個功能獨立可測\n配置外部化：設定與程式碼分離\n文件優先：程式碼即文件，文件即程式碼\n\n\n\n可擴展性\n\n插件化架構：Quartz 豐富的插件生態\nAPI 友善：預留未來 AI 整合介面\n版本控制：Git 為基礎的完整版本管理\n\n\n\n效能優化\n\n靜態生成：零伺服器成本，極速載入\nCDN 友善：全球快取，就近服務\n漸進式：增量建置，只處理變更內容\n\n\n\n🚀 最新動態\n本週焦點\n\n🔧 優化 AI 基準測試工具，提升 30% 效能\n🎮 重構遊戲系統架構，採用微服務模式\n🧩 發布巴哈姆特論壇助手 Chrome 擴展\n\n即將推出\n\n📝 AI 輔助的自動化文檔生成工具\n🎯 跨平台遊戲引擎抽象層\n💬 整合型開發者工具套件\n\n\n\n  🎯 目標願景\n  \n    建立一個符合個人思維模式的技術知識庫：\n    記錄 → 整理 → 分享 → 成長\n  \n  \n    &quot;善用工具，專注思考。讓技術服務於創造，而非被技術所束縛。&quot;\n  \n\n\n最後更新：2025-06-28 | 維護者：PekoraTech"},"index":{"slug":"index","filePath":"index.md","title":"SelfPageSource 技術文件化專案","links":["doc/","projects/","daily-code/","component/"],"tags":["技術文件","系統分析","知識管理"],"content":"SelfPageSource 技術文件化專案\n\n透過系統分析師視角，將專案理解轉換為可持續的開發歷程文件\n\n專案核心理念\n第一性原理思考\n\n資訊整理本質：從零散經驗提煉出可重複利用的知識體系\n知識傳承需求：將個人經驗轉化為團隊可共享的標準化文件\n安全平衡策略：在開放分享與創新保護之間找到最佳平衡點\n\nKISS原則與高內聚低耦合\n\n採用Quartz 4.0作為靜態網站生成器，避免重新造輪子\n內容組織遵循功能分離，各模組職責明確\n自動化流程減少人工干預，專注於內容創作\n\n內容架構導覽\n技術文件中心\n\n標準化技術文件與操作程序\n\n功能定位：補齊技術資料的標準化文件庫\n適用場景：技術操作標準程序、系統配置、開發工具指南、架構設計文件\n文件特性：結構化內容、版本控制、標準格式\n專案建置項目\n\n專案主軸建置文件，支援多專案共存管理\n\n功能定位：專案理解與分析的標準化記錄\n管理原則：專案間關係明確標示、建置流程標準化、專案狀態可追蹤\n安全機制：技術方法可公開，實作細節選擇性公開，創新核心嚴格保密\n時間分割內容\n\n以時間軸組織的日常開發記錄\n\n功能定位：日常開發經驗的系統化記錄\n重要原則：commit細寫記錄開發細節，對外文件需過濾敏感資訊\nMCP整合：透過claude或gemini cli自動整合每日內容\n可重用元件庫\n\n從歷史創作中萃取有價值的可重用元件\n\n功能定位：長遠計劃，建立技術資產庫\n價值體現：減少重複開發、提升開發效率、形成個人技術標準\n智財保護：展示思考過程，保護實作細節\n系統分析師工作流程\n專案理解階段\n\n讀取README.md：理解專案原始設計與目標\n架構分析：識別技術棧與依賴關係\n流程梳理：分析開發與部署流程\n問題識別：發現潛在風險與改進點\n\n文件轉換階段\n\n內容分類：依據功能特性分配至適當目錄\n標準化處理：統一文件格式、命名規則、標籤系統\n安全審查：識別敏感內容、應用保密策略、確保合規發布\n\n持續維護階段\n\n定期回顧：文件有效性檢查、技術棧更新同步、流程優化改進\n價值萃取：識別可重用元件、建立最佳實踐、形成技術標準\n\n安全與保密機制\n分級公開策略\n\n技術方法層級：可公開分享，促進技術交流\n實作細節層級：選擇性公開，保護競爭優勢\n創新核心層級：嚴格保密，維護智財價值\n\n自動化檢查流程\n\n關鍵字過濾機制\n敏感內容標記系統\n發布前審查程序\n\n技術架構\n核心技術棧\n\nQuartz 4.0：靜態網站生成器\nNode.js：執行環境\nTypeScript：類型安全開發\nGitHub Pages：免費網站託管\n\n自動化流程\n專案分析 → 內容分類 → 標準化處理 → 安全審查 → 自動發布\n\n開發指令\n常用操作\n# 開發模式\nnpm run dev              # 本地開發：http://localhost:8080\n \n# 建置與預覽  \nnpm run build-static     # 建置靜態檔案\nnpm run preview          # 靜態預覽：http://localhost:3000\n \n# 代碼品質\nnpm run check            # 格式檢查\nnpm run format           # 自動格式化\n \n# 發布流程\nnpm run format &amp;&amp; git add . &amp;&amp; git commit -m &quot;類型: 描述&quot; &amp;&amp; git push origin main\n持續改進計劃\n短期目標\n\n完善MCP自動化工作流程\n建立敏感內容自動檢測機制\n優化文件分類與檢索系統\n\n中期目標\n\n建立技術元件標準化流程\n發展智財保護自動化工具\n形成可複製的SA工作模式\n\n長期願景\n\n建立行業標準的技術文件化流程\n發展開源與商業平衡的最佳實踐\n形成系統分析師專業工具鏈\n\n貢獻原則\n提交規範\nfeat: 新增功能或內容\ndocs: 文件更新  \nfix: 問題修正\nstyle: 格式調整\nrefactor: 架構重構\nsecurity: 安全相關更新\n品質標準\n\n遵循第一性原理思考\n確保高內聚低耦合設計\n通過安全審查機制\n符合專業文件規範\n\n\n專案目標：建立符合系統分析師工作流程的技術文件化平台，平衡知識分享與創新保護，實現可持續的技術資產積累。\n維護團隊：PekoraTech SA Team\n最後更新：2025-07-05\n安全等級：公開（已過濾敏感內容）"},"projects/ai-tools/test-ai-memory":{"slug":"projects/ai-tools/test-ai-memory","filePath":"projects/ai-tools/test-ai-memory.md","title":"AI記憶體系統研究平台 - 長期記憶與智能交互的突破","links":["tags/AI","tags/LongTermMemory","tags/ChromeExtension","tags/Microservices","tags/Ollama","tags/FastAPI","tags/Streamlit","tags/AIResearch","tags/OpenSource","tags/MemorySystem"],"tags":["ai-memory","long-term-memory","chrome-extension","microservices","ollama","streamlit","fastapi","AI","LongTermMemory","ChromeExtension","Microservices","Ollama","FastAPI","Streamlit","AIResearch","OpenSource","MemorySystem"],"content":"🧠 AI記憶體系統研究平台\n\n突破AI記憶瓶頸，實現真正具有長期記憶能力的智能系統，為AI發展開創新篇章\n\n專案概述\n\n開發路徑：/Volumes/Code/test-ai-memory\n技術架構：三位一體微服務生態系統\n開發狀態：成功驗證，推薦學習參考\n複雜度評級：高 (多系統協同，創新性突破)\n核心價值：AI長期記憶技術的開源實踐\n\n📁 專案資料夾結構\ntest-ai-memory/\n├── README.md                              # 專案總覽\n├── CHROME_EXTENSION_DEVELOPMENT_PLAN.md   # Chrome擴展開發計劃\n├── test-love-memory-system/               # 🌟 AI長期記憶系統 (核心)\n│   ├── love_memory_system.py             # 原始單檔版本\n│   ├── main_modular.py                   # 模組化版本\n│   ├── love_memory_system/               # 模組化核心\n│   │   ├── api.py                        # FastAPI服務\n│   │   ├── ai/                           # AI女友核心邏輯\n│   │   ├── memory/                       # 記憶系統\n│   │   └── personality/                  # 人格管理\n│   └── README.md                         # 詳細技術文檔\n├── test-chrome-extension-ai-chat/         # 🚀 Chrome擴展AI對話\n│   ├── background/                       # 背景腳本\n│   ├── components/                       # React元件\n│   ├── contents/                         # 內容腳本\n│   ├── lib/                              # API工具\n│   ├── popup.tsx                         # 彈出介面\n│   └── README.md                         # 使用指南\n├── test-microservice-summary/             # ⚡ AI微服務API\n│   ├── api/                              # FastAPI微服務\n│   ├── gradio_app/                       # 驗證介面\n│   ├── requirements/                     # 依賴管理\n│   ├── docker/                           # 容器化配置\n│   └── README.md                         # 部署文檔\n└── image/                                # 專案截圖\n\n背景與問題\nAI記憶技術挑戰\n當前AI系統面臨的根本性限制：\n\n🔄 無狀態困境：每次對話都是全新開始，無法累積經驗\n📉 上下文限制：Token限制導致的記憶容量瓶頸\n🧩 碎片化記憶：缺乏有效的記憶組織和檢索機制\n💭 情感記憶缺失：無法建立情感關聯和個人化體驗\n\n技術整合需求\n\n瀏覽器整合：將AI能力無縫融入日常瀏覽體驗\n跨服務通信：不同環境下的AI服務互操作性\n本地化部署：隱私保護與效能的雙重要求\n\n技術方案\n🌟 三核心子專案生態\n1. test-love-memory-system - AI長期記憶突破\n\n最成功實現 - 推薦AI發展學習參考\n\n核心創新\n\n🧠 真正的AI記憶：SQLite持久化存儲 + 智能檢索\n🎭 多人格系統：7種不同人格的動態切換\n📊 記憶管理介面：完整的CRUD操作和分析工具\n🌐 API服務化：FastAPI驅動的RESTful介面\n\n記憶系統架構\n# 記憶核心實現\nclass MemoryManager:\n    def __init__(self):\n        self.db = sqlite3.connect(&#039;memories.db&#039;)\n        self.embedding_model = SentenceTransformer(&#039;all-MiniLM-L6-v2&#039;)\n    \n    def store_memory(self, content, importance, emotion):\n        # 向量化記憶內容\n        embedding = self.embedding_model.encode(content)\n        # 存儲到資料庫\n        self.db.execute(&quot;&quot;&quot;\n            INSERT INTO memories (content, embedding, importance, emotion, timestamp)\n            VALUES (?, ?, ?, ?, ?)\n        &quot;&quot;&quot;, (content, embedding.tobytes(), importance, emotion, datetime.now()))\n    \n    def retrieve_relevant_memories(self, query, top_k=5):\n        # 語義搜索相關記憶\n        query_embedding = self.embedding_model.encode(query)\n        # 計算相似度並返回最相關記憶\n        return self.semantic_search(query_embedding, top_k)\n人格化AI實現\n# 多人格系統\npersonality_prompts = {\n    &quot;親妹妹&quot;: &quot;可愛撒嬌型，用「哥哥」稱呼，語氣活潑親暱&quot;,\n    &quot;親姊姊&quot;: &quot;溫柔體貼型，關心照顧，語氣溫暖包容&quot;,\n    &quot;冷酷&quot;: &quot;高冷傲嬌型，表面冷淡但內心關心&quot;,\n    # ...其他人格\n}\n \nclass AIPersonality:\n    def __init__(self, personality_type):\n        self.personality = personality_type\n        self.system_prompt = personality_prompts[personality_type]\n        \n    def generate_response(self, user_input, memories):\n        # 結合人格特色 + 相關記憶 + 當前輸入\n        context = self.build_context(memories)\n        prompt = f&quot;{self.system_prompt}\\n記憶: {context}\\n用戶: {user_input}&quot;\n        return self.ai_model.generate(prompt)\n開發成果與突破\n\n✅ 記憶持久化：真正突破AI無記憶限制\n✅ 情感建模：實現情緒理解和回應\n✅ 個性化交互：根據歷史記憶調整回應風格\n✅ 研究價值：為AI記憶研究提供完整實現方案\n\n2. test-chrome-extension-ai-chat - 智能瀏覽器整合\n\n值得學習的整合典範 - Ollama + Chrome完美結合\n\n核心特色\n\n🖱️ 右鍵智能選單：選取文字即可AI分析\n📋 智能摘要生成：基於Plasmo框架的現代Chrome擴展\n💬 上下文對話：結合網頁內容的深度交互\n🤖 動態模型選擇：自動獲取Ollama可用模型\n\n技術實現亮點\n// 背景腳本 - 右鍵選單整合\nchrome.contextMenus.create({\n  id: &quot;ai-summary&quot;,\n  title: &quot;✨ AI 智能摘要&quot;,\n  contexts: [&quot;selection&quot;]\n});\n \nchrome.contextMenus.create({\n  id: &quot;ai-chat&quot;, \n  title: &quot;💬 AI 對話討論&quot;,\n  contexts: [&quot;selection&quot;]\n});\n \n// 內容腳本 - 智能對話框\nclass AIDialog extends React.Component {\n  async generateSummary(selectedText: string) {\n    const response = await fetch(&#039;http://localhost:8764/api/v1/summary/analyze&#039;, {\n      method: &#039;POST&#039;,\n      headers: { &#039;Content-Type&#039;: &#039;application/json&#039; },\n      body: JSON.stringify({\n        text: selectedText,\n        model: this.state.selectedModel,\n        summary_type: &quot;general&quot;,\n        language: &quot;zh-tw&quot;\n      })\n    });\n    \n    const result = await response.json();\n    this.setState({ summary: result.summary });\n  }\n}\n整合成就\n\n✅ Plasmo框架：現代Chrome擴展開發最佳實踐\n✅ Ollama集成：本地AI模型的完美整合\n✅ 用戶體驗：無干擾的智能增強體驗\n✅ 開源貢獻：為瀏覽器AI整合提供參考實現\n\n3. test-microservice-summary - 跨環境AI服務\n\n架構設計典範 - 微服務AI的完整實現\n\n核心價值\n\n🔌 API優先設計：RESTful微服務架構\n🐳 容器化部署：Docker + Docker Compose\n🎨 Gradio驗證介面：可視化測試環境\n📚 完整文檔：Swagger自動生成API文檔\n\n微服務架構設計\n# FastAPI微服務核心\nfrom fastapi import FastAPI, UploadFile, File\nfrom pydantic import BaseModel\n \napp = FastAPI(title=&quot;Ollama智能文字處理微服務&quot;)\n \nclass SummaryRequest(BaseModel):\n    text: str\n    summary_length: int = 300\n    summary_type: str = &quot;general&quot;\n    language: str = &quot;zh-tw&quot;\n    temperature: float = 0.7\n \n@app.post(&quot;/api/v1/summary/analyze&quot;)\nasync def analyze_text(request: SummaryRequest):\n    # 呼叫Ollama API處理\n    result = await ollama_service.generate_summary(\n        text=request.text,\n        length=request.summary_length,\n        type=request.summary_type\n    )\n    \n    return {\n        &quot;summary&quot;: result.summary,\n        &quot;tags&quot;: result.tags,\n        &quot;metadata&quot;: {\n            &quot;processing_time&quot;: result.time,\n            &quot;model_used&quot;: result.model\n        }\n    }\n \n@app.post(&quot;/api/v1/chat/message&quot;)\nasync def chat_message(message: ChatRequest):\n    # 對話處理邏輯\n    response = await ollama_service.chat(\n        message=message.message,\n        context=message.context,\n        model=message.model\n    )\n    return {&quot;response&quot;: response}\nDocker容器化部署\n# docker-compose.yml\nversion: &#039;3.8&#039;\nservices:\n  api:\n    build: \n      context: .\n      dockerfile: docker/api.Dockerfile\n    ports:\n      - &quot;8764:8000&quot;\n    environment:\n      - OLLAMA_API_URL=http://ollama:11434\n    depends_on:\n      - ollama\n      \n  gradio:\n    build:\n      context: .\n      dockerfile: docker/gradio.Dockerfile\n    ports:\n      - &quot;7860:7860&quot;\n    depends_on:\n      - api\n      \n  ollama:\n    image: ollama/ollama:latest\n    ports:\n      - &quot;11434:11434&quot;\n    volumes:\n      - ollama_data:/root/.ollama\n服務價值\n\n✅ 跨環境支援：解決Chrome擴展無法直接訪問Ollama的問題\n✅ API標準化：提供統一的AI服務介面\n✅ 可擴展性：支持多種AI模型和任務類型\n✅ 生產就緒：完整的日誌、監控和錯誤處理\n\n核心實作\nAI記憶系統的技術突破\n1. 向量化記憶存儲\n# 記憶向量化實現\ndef vectorize_memory(self, content):\n    # 使用Sentence Transformers進行語義編碼\n    embedding = self.model.encode(content)\n    return {\n        &#039;content&#039;: content,\n        &#039;embedding&#039;: embedding.tolist(),\n        &#039;timestamp&#039;: datetime.now(),\n        &#039;importance&#039;: self.calculate_importance(content)\n    }\n \ndef semantic_search(self, query, top_k=5):\n    # 語義搜索實現\n    query_vector = self.model.encode(query)\n    similarities = cosine_similarity([query_vector], self.memory_vectors)\n    indices = np.argsort(similarities[0])[::-1][:top_k]\n    return [self.memories[i] for i in indices]\n2. 情感建模系統\n# 情感分析和記憶關聯\nclass EmotionalMemory:\n    def __init__(self):\n        self.emotion_classifier = pipeline(&quot;sentiment-analysis&quot;)\n    \n    def store_with_emotion(self, content, user_emotion=None):\n        # 分析內容情感\n        content_emotion = self.emotion_classifier(content)[0]\n        \n        # 結合用戶情感和內容情感\n        combined_emotion = {\n            &#039;content_emotion&#039;: content_emotion,\n            &#039;user_emotion&#039;: user_emotion,\n            &#039;emotional_weight&#039;: self.calculate_emotional_weight(content)\n        }\n        \n        return self.store_memory(content, emotion=combined_emotion)\nChrome擴展的創新交互\n3. 智能內容提取\n// 智能文本選取和處理\nclass ContentExtractor {\n    extractSelection(): string {\n        const selection = window.getSelection();\n        if (!selection || selection.rangeCount === 0) return &#039;&#039;;\n        \n        // 獲取選取內容的上下文\n        const range = selection.getRangeAt(0);\n        const context = this.getContextualContent(range);\n        \n        return {\n            selectedText: selection.toString(),\n            context: context,\n            pageUrl: window.location.href,\n            pageTitle: document.title\n        };\n    }\n    \n    private getContextualContent(range: Range): string {\n        // 智能提取周圍上下文\n        const container = range.commonAncestorContainer;\n        const paragraph = container.parentElement(&#039;p, div, article&#039;);\n        return paragraph?.textContent?.slice(0, 500) || &#039;&#039;;\n    }\n}\n微服務的架構優勢\n4. 錯誤處理和重試機制\n# 健壯的API設計\nfrom functools import wraps\nimport asyncio\n \ndef retry_on_failure(max_retries=3):\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            for attempt in range(max_retries):\n                try:\n                    return await func(*args, **kwargs)\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise e\n                    await asyncio.sleep(2 ** attempt)  # 指數退避\n            return None\n        return wrapper\n    return decorator\n \n@retry_on_failure(max_retries=3)\nasync def call_ollama_api(self, payload):\n    # 調用Ollama API的重試邏輯\n    response = await self.http_client.post(\n        f&quot;{self.ollama_url}/api/generate&quot;,\n        json=payload,\n        timeout=30\n    )\n    return response.json()\n效果與學習\n開發成果\n技術突破：\n\n🧠 AI記憶技術：突破傳統AI無記憶限制，實現真正的長期記憶\n🔄 記憶檢索算法：基於語義相似度的智能記憶召回\n💭 情感建模：情感與記憶的深度關聯建模\n🎯 人格化AI：多人格系統的動態切換機制\n\n整合創新：\n\n🌐 瀏覽器AI整合：無縫融入日常工作流程\n🔗 微服務架構：跨環境AI服務的標準化實現\n📱 用戶體驗：零學習成本的智能增強\n\n系統價值：\n\n📊 研究價值：為AI記憶研究提供完整開源實現\n🔧 工程價值：可複用的微服務和擴展架構\n🎓 教育價值：AI開發的最佳實踐示範\n\n技術洞察與創新\n1. AI記憶系統設計哲學\n\n持久化不等於記憶：需要智能的組織、檢索和關聯\n情感是記憶的催化劑：情感標記顯著提升記憶召回效果\n個性化是記憶的表達：相同記憶在不同人格下的不同詮釋\n\n2. Chrome擴展開發心得\n\nManifest V3的Service Worker：事件驅動的新架構模式\n跨域通信的安全設計：Content Security Policy的正確配置\n用戶體驗的無感知原則：AI增強不應干擾原有體驗\n\n3. 微服務架構最佳實踐\n\nAPI優先設計：先設計接口，再實現功能\n容器化的一致性：開發、測試、生產環境的統一\n監控和日誌：系統健康狀態的可觀測性\n\n對AI發展的貢獻\n開源價值：\n\n📖 技術文檔：詳細的實現文檔和最佳實踐\n🔬 研究基礎：為AI記憶研究提供可驗證的基線實現\n🌍 社群貢獻：推動AI記憶技術的普及和發展\n\n創新啟發：\n\n💡 記憶即智能：長期記憶是通向AGI的關鍵技術\n🤝 人機協作：AI應該是智能增強而非替代\n🔮 未來願景：每個人都應該有專屬的AI記憶助手\n\n時間軸\n2025-07-06 15:30 專案總結與文檔化\n\n完成三個子專案的深度技術分析\n整理AI記憶系統的核心創新點\n撰寫推薦學習的技術文檔\n\n2025-07-01 09:00 test-love-memory-system 記憶系統突破\n\n實現真正的AI長期記憶功能\n完成7種人格的動態切換系統\n建立基於SQLite的記憶持久化存儲\n開發記憶管理的完整CRUD介面\n\n2025-06-28 14:45 test-chrome-extension-ai-chat 整合完成\n\n基於Plasmo框架完成Chrome擴展開發\n實現右鍵選單的智能AI功能\n完成與Ollama本地AI模型的無縫整合\n優化用戶體驗和錯誤處理機制\n\n2025-06-25 11:20 test-microservice-summary 微服務架構\n\n設計並實現FastAPI微服務架構\n完成Docker容器化部署方案\n建立Gradio驗證介面和API文檔\n實現跨環境AI服務的標準化接口\n\n2025-06-22 16:00 專案架構設計\n\n確定三位一體的技術架構方案\n制定AI記憶系統的核心技術路線\n設計Chrome擴展與微服務的整合方案\n\n\n⏰ 總投入時間：78小時 | 🎯 成果：AI記憶技術突破 | 📚 學習：AI長期記憶系統完整實現\n專案映射\n\n開發資料夾：/Volumes/Code/test-ai-memory\nGitHub倉庫：暫未公開（核心技術保護）\n相關專案：\n\ntest-ai-benchmark - AI效能測試工具\nbrowser-extension-ecosystem - 瀏覽器擴展生態系統\n\n\n\n下一步規劃\n短期目標 (本週)\n\n 完善記憶系統的向量檢索算法\n 優化Chrome擴展的響應速度\n 增強微服務的容錯能力\n\n中期目標 (本月)\n\n 開源AI記憶系統核心組件\n 發布Chrome擴展到Web Store\n 建立技術交流社群\n\n長期願景 (本季)\n\n 推動AI記憶技術標準化\n 建立AI記憶研究的開源生態\n 為AGI記憶系統奠定技術基礎\n\n🌟 推薦學習重點\n對AI開發者\n\n記憶系統設計：學習如何實現真正的AI長期記憶\n向量檢索技術：掌握語義搜索和記憶召回算法\n情感建模：理解情感與記憶的深度關聯\n\n對前端開發者\n\nChrome擴展現代化：Plasmo框架的最佳實踐\nAI整合模式：瀏覽器與AI服務的無縫整合\n用戶體驗設計：AI增強的界面設計原則\n\n對架構師\n\n微服務設計：AI服務的架構和部署模式\n容器化實踐：Docker在AI應用中的最佳實踐\nAPI設計：AI服務的RESTful設計原則\n\n\nAI LongTermMemory ChromeExtension Microservices Ollama FastAPI Streamlit AIResearch OpenSource MemorySystem"},"projects/browser-extension-ecosystem":{"slug":"projects/browser-extension-ecosystem","filePath":"projects/browser-extension-ecosystem.md","title":"瀏覽器擴展生態系統建構","links":["daily-code/2025-06-25-service-worker-optimization","daily-code/2025-06-20-cors-handling","daily-code/2025-06-15-react-extension-patterns","projects/ai-development-suite","projects/game-system-evolution","daily-code/","tags/ChromeExtension","tags/AI","tags/Architecture","tags/Microservices","tags/WebDevelopment"],"tags":["Chrome-Extension","Browser","Architecture","專案整合","ChromeExtension","AI","Microservices","WebDevelopment"],"content":"🧩 瀏覽器擴展生態系統建構\n\n專案整合：test-baba-chrome-extension-tools + test-ai-memory 的架構演進與設計思考\n\n🎯 專案背景\n演進歷程\n從單純的論壇工具發展為完整的 AI 輔助瀏覽器生態系統：\ntimeline\n    title 擴展開發演進歷程\n\n    2024-Q1 : 巴哈姆特論壇助手\n           : 基礎內容抓取\n           : 簡單 UI 優化\n\n    2024-Q2 : 功能擴展\n           : 自動回覆機制\n           : 數據持久化\n\n    2024-Q3 : AI 整合嘗試\n           : 接入 OpenAI API\n           : 智能內容分析\n\n    2024-Q4 : 微服務架構\n           : Ollama 代理服務\n           : 跨域解決方案\n\n    2025-Q1 : 生態系統化\n           : 多擴展協作\n           : 統一管理後台\n\n核心專案結構\n瀏覽器擴展生態系\n├── 🏪 baha-forum-assistant/          # 論壇工具擴展\n│   ├── manifest.json                 # V3 Manifest\n│   ├── background/                   # 背景腳本\n│   ├── content/                      # 內容腳本\n│   └── popup/                        # 彈出界面\n├── 🤖 ai-chat-extension/             # AI 聊天擴展\n│   ├── components/                   # React 組件\n│   ├── hooks/                        # 自定義 Hooks\n│   └── services/                     # API 服務\n└── 🔧 microservice-summary/          # 後端微服務\n    ├── ollama-proxy/                 # Ollama 代理\n    ├── file-processor/               # 檔案處理\n    └── swagger-docs/                 # API 文檔\n\n\n🏗️ 架構設計深度解析\n1. Manifest V3 遷移策略\n核心變更點\n// manifest.json - 現代化配置\n{\n  &quot;manifest_version&quot;: 3,\n  &quot;name&quot;: &quot;PekoraTech Browser Suite&quot;,\n  &quot;version&quot;: &quot;2.0.0&quot;,\n  &quot;description&quot;: &quot;AI-powered browser extension ecosystem&quot;,\n \n  &quot;permissions&quot;: [&quot;storage&quot;, &quot;activeTab&quot;, &quot;scripting&quot;],\n \n  &quot;host_permissions&quot;: [&quot;forum.gamer.com.tw/*&quot;, &quot;https://localhost:8000/*&quot;],\n \n  &quot;background&quot;: {\n    &quot;service_worker&quot;: &quot;background/worker.js&quot;\n  },\n \n  &quot;content_scripts&quot;: [\n    {\n      &quot;matches&quot;: [&quot;forum.gamer.com.tw/*&quot;],\n      &quot;js&quot;: [&quot;content/forum-enhancer.js&quot;],\n      &quot;css&quot;: [&quot;styles/forum-theme.css&quot;]\n    }\n  ],\n \n  &quot;action&quot;: {\n    &quot;default_popup&quot;: &quot;popup/index.html&quot;,\n    &quot;default_title&quot;: &quot;PekoraTech Tools&quot;\n  }\n}\nService Worker 最佳實踐\n// background/worker.js - 高效的背景處理\nclass ExtensionServiceWorker {\n  constructor() {\n    this.initializeEventListeners()\n    this.setupPeriodicTasks()\n  }\n \n  initializeEventListeners() {\n    // 安裝事件 - 初始化設定\n    chrome.runtime.onInstalled.addListener((details) =&gt; {\n      if (details.reason === &quot;install&quot;) {\n        this.handleFirstInstall()\n      } else if (details.reason === &quot;update&quot;) {\n        this.handleUpdate(details.previousVersion)\n      }\n    })\n \n    // 訊息通信 - 統一處理\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) =&gt; {\n      this.handleMessage(message, sender)\n        .then(sendResponse)\n        .catch((error) =&gt; sendResponse({ error: error.message }))\n      return true // 保持通道開啟\n    })\n \n    // 標籤頁事件 - 上下文感知\n    chrome.tabs.onActivated.addListener(this.handleTabActivated.bind(this))\n    chrome.tabs.onUpdated.addListener(this.handleTabUpdated.bind(this))\n  }\n \n  async handleMessage(message, sender) {\n    const { type, payload } = message\n \n    switch (type) {\n      case &quot;AI_CHAT_REQUEST&quot;:\n        return await this.processAiRequest(payload)\n \n      case &quot;FORUM_DATA_EXTRACT&quot;:\n        return await this.extractForumData(payload)\n \n      case &quot;STORAGE_SYNC&quot;:\n        return await this.syncUserData(payload)\n \n      default:\n        throw new Error(`Unknown message type: ${type}`)\n    }\n  }\n \n  async processAiRequest(payload) {\n    // 代理到 Ollama 微服務\n    const response = await fetch(&quot;http://localhost:8000/api/chat&quot;, {\n      method: &quot;POST&quot;,\n      headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },\n      body: JSON.stringify({\n        model: &quot;llama3.1&quot;,\n        messages: payload.messages,\n        options: { temperature: 0.7 },\n      }),\n    })\n \n    if (!response.ok) {\n      throw new Error(`AI service error: ${response.status}`)\n    }\n \n    return await response.json()\n  }\n}\n \n// 初始化 Service Worker\nnew ExtensionServiceWorker()\n2. 內容腳本注入系統\n智能注入策略\n// content/injection-manager.js - 動態注入管理\nclass ContentInjectionManager {\n  constructor() {\n    this.injectedFeatures = new Set()\n    this.pageContext = this.analyzePageContext()\n    this.initializeBasedOnContext()\n  }\n \n  analyzePageContext() {\n    const url = window.location.href\n    const hostname = window.location.hostname\n \n    return {\n      isBahaForum: hostname === &quot;forum.gamer.com.tw&quot;,\n      isArticlePage: url.includes(&quot;/C.php&quot;),\n      isBoardPage: url.includes(&quot;/B.php&quot;),\n      hasCommentSection: !!document.querySelector(&quot;.c-post&quot;),\n      userLoggedIn: this.checkUserLoginStatus(),\n    }\n  }\n \n  initializeBasedOnContext() {\n    if (this.pageContext.isBahaForum) {\n      this.injectForumEnhancements()\n    }\n \n    // 通用 AI 輔助功能\n    this.injectAiAssistant()\n \n    // 基於頁面類型的特殊功能\n    if (this.pageContext.isArticlePage) {\n      this.injectArticleAnalyzer()\n    }\n  }\n \n  injectForumEnhancements() {\n    if (this.injectedFeatures.has(&quot;forum&quot;)) return\n \n    // 注入論壇增強功能\n    this.addForumToolbar()\n    this.enhanceCommentSystem()\n    this.addQuickReplyFeatures()\n \n    this.injectedFeatures.add(&quot;forum&quot;)\n    console.log(&quot;🏪 Forum enhancements injected&quot;)\n  }\n \n  injectAiAssistant() {\n    if (this.injectedFeatures.has(&quot;ai&quot;)) return\n \n    // 創建 AI 助手浮動按鈕\n    const aiButton = this.createAiButton()\n    document.body.appendChild(aiButton)\n \n    // 監聽文字選取事件\n    document.addEventListener(&quot;mouseup&quot;, this.handleTextSelection.bind(this))\n \n    this.injectedFeatures.add(&quot;ai&quot;)\n    console.log(&quot;🤖 AI assistant injected&quot;)\n  }\n \n  createAiButton() {\n    const button = document.createElement(&quot;div&quot;)\n    button.className = &quot;pekora-ai-button&quot;\n    button.innerHTML = `\n      &lt;div class=&quot;ai-icon&quot;&gt;🤖&lt;/div&gt;\n      &lt;div class=&quot;ai-menu&quot; style=&quot;display: none;&quot;&gt;\n        &lt;button data-action=&quot;summarize&quot;&gt;📄 摘要&lt;/button&gt;\n        &lt;button data-action=&quot;translate&quot;&gt;🌐 翻譯&lt;/button&gt;\n        &lt;button data-action=&quot;explain&quot;&gt;💡 解釋&lt;/button&gt;\n        &lt;button data-action=&quot;chat&quot;&gt;💬 對話&lt;/button&gt;\n      &lt;/div&gt;\n    `\n \n    // 添加樣式\n    button.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      z-index: 10000;\n      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n      border-radius: 50%;\n      width: 60px;\n      height: 60px;\n      cursor: pointer;\n      box-shadow: 0 4px 20px rgba(0,0,0,0.3);\n      transition: all 0.3s ease;\n    `\n \n    // 事件處理\n    button.addEventListener(&quot;click&quot;, this.toggleAiMenu.bind(this))\n \n    return button\n  }\n \n  async handleTextSelection() {\n    const selectedText = window.getSelection().toString().trim()\n    if (selectedText.length &gt; 10) {\n      // 顯示快速 AI 操作選項\n      this.showQuickActions(selectedText)\n    }\n  }\n}\n \n// 初始化內容注入管理器\nnew ContentInjectionManager()\n3. 微服務後端架構\nOllama 代理服務\n# microservice-summary/main.py - FastAPI 微服務\nfrom fastapi import FastAPI, HTTPException, UploadFile, File\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\nimport ollama\nimport asyncio\nfrom typing import List, Optional\n \napp = FastAPI(\n    title=&quot;PekoraTech AI Service&quot;,\n    description=&quot;Ollama 代理服務，為瀏覽器擴展提供 AI 功能&quot;,\n    version=&quot;2.0.0&quot;\n)\n \n# CORS 設定 - 允許擴展訪問\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[&quot;chrome-extension://*&quot;, &quot;http://localhost:*&quot;],\n    allow_credentials=True,\n    allow_methods=[&quot;*&quot;],\n    allow_headers=[&quot;*&quot;],\n)\n \nclass ChatRequest(BaseModel):\n    model: str = &quot;llama3.1&quot;\n    messages: List[dict]\n    options: Optional[dict] = {}\n \nclass SummaryRequest(BaseModel):\n    text: str\n    style: str = &quot;concise&quot;  # concise, detailed, bullet_points\n    language: str = &quot;zh-TW&quot;\n \n@app.post(&quot;/api/chat&quot;)\nasync def chat_completion(request: ChatRequest):\n    &quot;&quot;&quot;AI 對話完成接口&quot;&quot;&quot;\n    try:\n        # 使用 Ollama 進行推理\n        response = await asyncio.to_thread(\n            ollama.chat,\n            model=request.model,\n            messages=request.messages,\n            options=request.options\n        )\n \n        return {\n            &quot;success&quot;: True,\n            &quot;response&quot;: response[&#039;message&#039;][&#039;content&#039;],\n            &quot;model_used&quot;: request.model,\n            &quot;tokens_used&quot;: response.get(&#039;eval_count&#039;, 0)\n        }\n \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n \n@app.post(&quot;/api/summarize&quot;)\nasync def text_summarization(request: SummaryRequest):\n    &quot;&quot;&quot;智能文本摘要&quot;&quot;&quot;\n    try:\n        # 根據風格調整提示\n        style_prompts = {\n            &quot;concise&quot;: &quot;請用 1-2 句話簡潔總結以下內容：&quot;,\n            &quot;detailed&quot;: &quot;請提供詳細的結構化摘要，包含要點分析：&quot;,\n            &quot;bullet_points&quot;: &quot;請用條列式要點總結以下內容：&quot;\n        }\n \n        prompt = f&quot;{style_prompts.get(request.style, style_prompts[&#039;concise&#039;])}\\n\\n{request.text}&quot;\n \n        response = await asyncio.to_thread(\n            ollama.generate,\n            model=&quot;llama3.1&quot;,\n            prompt=prompt,\n            options={&quot;temperature&quot;: 0.3}\n        )\n \n        return {\n            &quot;success&quot;: True,\n            &quot;summary&quot;: response[&#039;response&#039;],\n            &quot;original_length&quot;: len(request.text),\n            &quot;compression_ratio&quot;: len(response[&#039;response&#039;]) / len(request.text)\n        }\n \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n \n@app.post(&quot;/api/analyze/file&quot;)\nasync def analyze_file(file: UploadFile = File(...)):\n    &quot;&quot;&quot;檔案內容分析&quot;&quot;&quot;\n    try:\n        content = await file.read()\n \n        # 根據檔案類型處理\n        if file.content_type == &quot;application/pdf&quot;:\n            text = extract_pdf_text(content)\n        elif file.content_type.startswith(&quot;text/&quot;):\n            text = content.decode(&#039;utf-8&#039;)\n        else:\n            raise HTTPException(status_code=400, detail=&quot;不支援的檔案格式&quot;)\n \n        # AI 分析\n        analysis_prompt = f&quot;&quot;&quot;\n        請分析以下文件內容並提供：\n        1. 主要主題和關鍵概念\n        2. 內容結構分析\n        3. 重要資訊摘要\n        4. 潛在問題或改進建議\n \n        文件內容：\n        {text[:4000]}  # 限制長度避免超出 token 限制\n        &quot;&quot;&quot;\n \n        response = await asyncio.to_thread(\n            ollama.generate,\n            model=&quot;llama3.1&quot;,\n            prompt=analysis_prompt,\n            options={&quot;temperature&quot;: 0.5}\n        )\n \n        return {\n            &quot;success&quot;: True,\n            &quot;filename&quot;: file.filename,\n            &quot;file_size&quot;: len(content),\n            &quot;analysis&quot;: response[&#039;response&#039;]\n        }\n \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n \n# 健康檢查\n@app.get(&quot;/health&quot;)\nasync def health_check():\n    &quot;&quot;&quot;服務健康檢查&quot;&quot;&quot;\n    try:\n        # 檢查 Ollama 服務\n        models = ollama.list()\n        return {\n            &quot;status&quot;: &quot;healthy&quot;,\n            &quot;ollama_available&quot;: True,\n            &quot;available_models&quot;: [model[&#039;name&#039;] for model in models[&#039;models&#039;]]\n        }\n    except:\n        return {\n            &quot;status&quot;: &quot;unhealthy&quot;,\n            &quot;ollama_available&quot;: False,\n            &quot;error&quot;: &quot;Ollama service unavailable&quot;\n        }\n\n📊 技術債務與架構演進\n當前技術債務\ngraph TD\n    A[技術債務分析] --&gt; B[高優先級]\n    A --&gt; C[中優先級]\n    A --&gt; D[低優先級]\n\n    B --&gt; B1[CORS 配置複雜]\n    B --&gt; B2[錯誤處理不一致]\n    B --&gt; B3[Storage API 濫用]\n\n    C --&gt; C1[UI 組件重複]\n    C --&gt; C2[配置檔案分散]\n    C --&gt; C3[測試覆蓋率低]\n\n    D --&gt; D1[程式碼註釋不足]\n    D --&gt; D2[版本控制策略]\n    D --&gt; D3[文檔更新滯後]\n\n重構計畫\n階段一：核心架構優化 (2週)\n// 統一的通信層 - communication/bridge.ts\nexport class ExtensionBridge {\n  private static instance: ExtensionBridge\n  private messageHandlers = new Map&lt;string, Function&gt;()\n \n  static getInstance(): ExtensionBridge {\n    if (!ExtensionBridge.instance) {\n      ExtensionBridge.instance = new ExtensionBridge()\n    }\n    return ExtensionBridge.instance\n  }\n \n  async sendToBackground&lt;T&gt;(type: string, payload?: any): Promise&lt;T&gt; {\n    return new Promise((resolve, reject) =&gt; {\n      chrome.runtime.sendMessage({ type, payload }, (response) =&gt; {\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message))\n        } else if (response?.error) {\n          reject(new Error(response.error))\n        } else {\n          resolve(response)\n        }\n      })\n    })\n  }\n \n  registerHandler(type: string, handler: Function): void {\n    this.messageHandlers.set(type, handler)\n  }\n \n  async handleMessage(message: any): Promise&lt;any&gt; {\n    const handler = this.messageHandlers.get(message.type)\n    if (!handler) {\n      throw new Error(`No handler for message type: ${message.type}`)\n    }\n    return await handler(message.payload)\n  }\n}\n階段二：UI 組件系統 (3週)\n// 可重用的 React 組件庫\n// components/ui/AiChatWidget.tsx\nimport React, { useState, useEffect } from &#039;react&#039;;\nimport { ExtensionBridge } from &#039;../communication/bridge&#039;;\n \ninterface AiChatWidgetProps {\n  initialMessage?: string;\n  model?: string;\n  theme?: &#039;light&#039; | &#039;dark&#039;;\n}\n \nexport const AiChatWidget: React.FC&lt;AiChatWidgetProps&gt; = ({\n  initialMessage = &quot;&quot;,\n  model = &quot;llama3.1&quot;,\n  theme = &quot;light&quot;\n}) =&gt; {\n  const [messages, setMessages] = useState&lt;Array&lt;{role: string, content: string}&gt;&gt;([]);\n  const [input, setInput] = useState(initialMessage);\n  const [loading, setLoading] = useState(false);\n \n  const bridge = ExtensionBridge.getInstance();\n \n  const sendMessage = async () =&gt; {\n    if (!input.trim()) return;\n \n    const userMessage = { role: &#039;user&#039;, content: input };\n    setMessages(prev =&gt; [...prev, userMessage]);\n    setInput(&#039;&#039;);\n    setLoading(true);\n \n    try {\n      const response = await bridge.sendToBackground(&#039;AI_CHAT_REQUEST&#039;, {\n        model,\n        messages: [...messages, userMessage]\n      });\n \n      setMessages(prev =&gt; [...prev, {\n        role: &#039;assistant&#039;,\n        content: response.response\n      }]);\n    } catch (error) {\n      console.error(&#039;AI Chat Error:&#039;, error);\n      // 錯誤處理...\n    } finally {\n      setLoading(false);\n    }\n  };\n \n  return (\n    &lt;div className={`ai-chat-widget ${theme}`}&gt;\n      &lt;div className=&quot;messages&quot;&gt;\n        {messages.map((msg, idx) =&gt; (\n          &lt;div key={idx} className={`message ${msg.role}`}&gt;\n            {msg.content}\n          &lt;/div&gt;\n        ))}\n        {loading &amp;&amp; &lt;div className=&quot;loading&quot;&gt;🤖 思考中...&lt;/div&gt;}\n      &lt;/div&gt;\n \n      &lt;div className=&quot;input-area&quot;&gt;\n        &lt;input\n          value={input}\n          onChange={(e) =&gt; setInput(e.target.value)}\n          onKeyDown={(e) =&gt; e.key === &#039;Enter&#039; &amp;&amp; sendMessage()}\n          placeholder=&quot;輸入訊息...&quot;\n        /&gt;\n        &lt;button onClick={sendMessage} disabled={loading}&gt;\n          發送\n        &lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n階段三：配置管理系統 (1週)\n// config/ConfigManager.ts - 統一配置管理\ninterface ExtensionConfig {\n  ai: {\n    defaultModel: string\n    apiEndpoint: string\n    temperature: number\n  }\n  ui: {\n    theme: &quot;light&quot; | &quot;dark&quot;\n    language: string\n    animations: boolean\n  }\n  features: {\n    autoSummarize: boolean\n    smartReply: boolean\n    voiceInput: boolean\n  }\n}\n \nexport class ConfigManager {\n  private static config: ExtensionConfig\n \n  static async load(): Promise&lt;ExtensionConfig&gt; {\n    const stored = await chrome.storage.sync.get(&quot;config&quot;)\n \n    ConfigManager.config = {\n      ...ConfigManager.getDefaultConfig(),\n      ...stored.config,\n    }\n \n    return ConfigManager.config\n  }\n \n  static async save(updates: Partial&lt;ExtensionConfig&gt;): Promise&lt;void&gt; {\n    ConfigManager.config = { ...ConfigManager.config, ...updates }\n    await chrome.storage.sync.set({ config: ConfigManager.config })\n  }\n \n  static get(): ExtensionConfig {\n    return ConfigManager.config\n  }\n \n  private static getDefaultConfig(): ExtensionConfig {\n    return {\n      ai: {\n        defaultModel: &quot;llama3.1&quot;,\n        apiEndpoint: &quot;http://localhost:8000&quot;,\n        temperature: 0.7,\n      },\n      ui: {\n        theme: &quot;light&quot;,\n        language: &quot;zh-TW&quot;,\n        animations: true,\n      },\n      features: {\n        autoSummarize: true,\n        smartReply: false,\n        voiceInput: false,\n      },\n    }\n  }\n}\n\n🎯 效能優化實踐\n記憶體管理策略\n// 智能記憶體管理\nclass MemoryManager {\n  constructor() {\n    this.cache = new Map();\n    this.maxCacheSize = 100;\n    this.cleanupInterval = 5 * 60 * 1000; // 5分鐘\n \n    this.startCleanupTimer();\n    this.monitorMemoryUsage();\n  }\n \n  set(key, value, ttl = 300000) { // 預設 5分鐘 TTL\n    if (this.cache.size &gt;= this.maxCacheSize) {\n      this.evictOldest();\n    }\n \n    this.cache.set(key, {\n      value,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n \n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) return null;\n \n    if (Date.now() - item.timestamp &gt; item.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n \n    return item.value;\n  }\n \n  evictOldest() {\n    const oldest = Array.from(this.cache.entries())\n      .sort(([,a], [,b]) =&gt; a.timestamp - b.timestamp)[0];\n \n    if (oldest) {\n      this.cache.delete(oldest[0]);\n    }\n  }\n \n  async monitorMemoryUsage() {\n    if (&#039;memory&#039; in performance) {\n      const usage = (performance as any).memory;\n      console.log(`記憶體使用: ${(usage.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`);\n \n      // 記憶體使用過高時清理快取\n      if (usage.usedJSHeapSize &gt; 50 * 1024 * 1024) { // 50MB\n        this.clearExpired();\n      }\n    }\n  }\n}\n非同步處理優化\n// 批次處理和防抖動\nclass BatchProcessor {\n  constructor(processor, batchSize = 10, delay = 1000) {\n    this.processor = processor\n    this.batchSize = batchSize\n    this.delay = delay\n    this.queue = []\n    this.timeoutId = null\n  }\n \n  add(item) {\n    this.queue.push(item)\n \n    if (this.queue.length &gt;= this.batchSize) {\n      this.flush()\n    } else {\n      this.scheduleFlush()\n    }\n  }\n \n  scheduleFlush() {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId)\n    }\n \n    this.timeoutId = setTimeout(() =&gt; {\n      this.flush()\n    }, this.delay)\n  }\n \n  async flush() {\n    if (this.queue.length === 0) return\n \n    const batch = this.queue.splice(0, this.batchSize)\n \n    try {\n      await this.processor(batch)\n    } catch (error) {\n      console.error(&quot;批次處理失敗:&quot;, error)\n      // 重試邏輯...\n    }\n \n    // 繼續處理剩餘項目\n    if (this.queue.length &gt; 0) {\n      this.scheduleFlush()\n    }\n  }\n}\n\n📈 監控與分析\n效能指標儀表板\n// analytics/PerformanceTracker.js\nclass PerformanceTracker {\n  constructor() {\n    this.metrics = {\n      extensionLoad: 0,\n      apiResponseTimes: [],\n      userInteractions: 0,\n      errorCounts: {},\n      memoryUsage: [],\n    }\n \n    this.startTracking()\n  }\n \n  trackApiCall(endpoint, duration) {\n    this.metrics.apiResponseTimes.push({\n      endpoint,\n      duration,\n      timestamp: Date.now(),\n    })\n \n    // 只保留最近 1000 次記錄\n    if (this.metrics.apiResponseTimes.length &gt; 1000) {\n      this.metrics.apiResponseTimes.shift()\n    }\n  }\n \n  trackError(error, context) {\n    const key = `${error.name}:${context}`\n    this.metrics.errorCounts[key] = (this.metrics.errorCounts[key] || 0) + 1\n \n    // 發送到分析服務\n    this.sendAnalytics(&quot;error&quot;, { error: error.message, context })\n  }\n \n  generateReport() {\n    const avgResponseTime =\n      this.metrics.apiResponseTimes.length &gt; 0\n        ? this.metrics.apiResponseTimes.reduce((sum, item) =&gt; sum + item.duration, 0) /\n          this.metrics.apiResponseTimes.length\n        : 0\n \n    return {\n      performance: {\n        avgApiResponseTime: avgResponseTime,\n        totalInteractions: this.metrics.userInteractions,\n        errorRate: Object.values(this.metrics.errorCounts).reduce((sum, count) =&gt; sum + count, 0),\n      },\n      recommendations: this.generateRecommendations(),\n    }\n  }\n \n  generateRecommendations() {\n    const recommendations = []\n    const report = this.generateReport()\n \n    if (report.performance.avgApiResponseTime &gt; 2000) {\n      recommendations.push({\n        type: &quot;performance&quot;,\n        message: &quot;API 回應時間過長，建議優化後端處理或增加快取&quot;,\n      })\n    }\n \n    if (report.performance.errorRate &gt; 10) {\n      recommendations.push({\n        type: &quot;reliability&quot;,\n        message: &quot;錯誤率過高，需要檢查錯誤處理機制&quot;,\n      })\n    }\n \n    return recommendations\n  }\n}\n\n🚀 未來發展規劃\n短期目標 (1-2個月)\n\n 統一身份認證系統 - 跨擴展的用戶狀態同步\n 可視化設定介面 - 使用者友善的配置管理\n 擴展商店上架 - 完成 Chrome Web Store 審核\n\n中期目標 (3-6個月)\n\n 多瀏覽器支援 - Firefox、Edge、Safari 適配\n 雲端同步功能 - 跨設備設定同步\n 插件市場 - 第三方開發者生態\n\n長期願景 (6-12個月)\n\n AI 模型本地化 - WebAssembly AI 推理\n 隱私增強技術 - 零知識證明和端到端加密\n 開源生態系統 - 建立開發者社群\n\n\n💭 設計哲學反思\n第一性原理應用\n\n問題本質：瀏覽器與 AI 的障礙是跨域限制，不是技術複雜性\n解決方案：微服務代理 + 統一通信層，而非重新發明輪子\n價值創造：提升使用者瀏覽體驗，而非炫技\n\nKISS 原則體現\n\n選擇現有工具：FastAPI + Ollama，而非自建 AI 服務\n最小化複雜性：統一的訊息機制，而非多種通信方式\n漸進式增強：基礎功能先行，高級功能後續添加\n\n高內聚低耦合實踐\n擴展層（UI） ⟷ 通信層（Bridge） ⟷ 服務層（Microservice）\n     ↓              ↓                    ↓\n  組件獨立        協議統一              API 標準\n\n\n📚 相關資源與學習\n技術文檔\n\nChrome Extension Manifest V3\nFastAPI 官方文檔\nOllama API 參考\n\n最佳實踐\n\nService Worker 最佳化\nCORS 處理策略\nReact 擴展開發模式\n\n知識連結\n\n與 AI 開發工具套件 共享 API 設計\n可整合到 遊戲系統 作為管理工具\n為 每日開發 提供實時輔助\n\n\n🎯 專案狀態：活躍開發中 | 📊 程式碼覆蓋率：75% | 🚀 下次發布：2025-07-15\nChromeExtension AI Architecture Microservices WebDevelopment"},"projects/development-tools/calu-app-gradio-toolkit":{"slug":"projects/development-tools/calu-app-gradio-toolkit","filePath":"projects/development-tools/calu-app-gradio-toolkit.md","title":"Calu-app - Gradio多功能工具箱實驗專案","links":[],"tags":["gradio","ai-integration","docker","ollama","web-tools","experimental"],"content":"Calu-app - Gradio多功能工具箱實驗專案\n\n從實用工具需求出發，探索Gradio + AI + Docker技術整合的可行性與最佳實踐\n\n專案概述\n\n路徑：/Volumes/Code/Calu-app\n技術棧：Python, Gradio, Ollama, Docker\n狀態：實驗階段完成，技術驗證成功\n複雜度：複雜（多技術棧整合）\n領域：開發工具\n\n專案資料夾結構\nCalu-app/\n├── main.py                    # Gradio 應用主進入點\n├── app.py                     # (舊版) Flask + Gradio 實驗檔案\n├── app2.py                    # 版本迭代檔案\n├── app3.py                    # 版本迭代檔案\n├── requirements.txt           # Python 依賴套件列表\n├── Dockerfile                 # Docker 容器建置設定\n├── docker-compose.yml         # Docker 部署設定\n├── README.md                  # 專案說明文件\n├── README-docker.md           # Docker 部署說明\n├── PEKORA-LICENSE            # 兔田佩可拉效忠聲明\n├── .vscode/                   # VS Code 開發環境設定\n├── .gradio/                   # Gradio 運行時檔案\n├── utils/                     # 核心功能模組\n│   ├── __init__.py           # 模組初始化\n│   ├── date_utils.py         # 日期計算邏輯\n│   ├── format_utils.py       # 格式化工具\n│   ├── ai_utils.py           # AI 整合邏輯\n│   └── future_bento_price.py # 便當價格推估\n├── static/                    # 靜態資源\n│   ├── css/                  # 樣式檔案\n│   └── js/                   # JavaScript 檔案\n├── templates/                 # HTML 模板\n│   ├── layout.html           # 基礎布局\n│   ├── gradio.html           # Gradio 整合頁面\n│   └── flatpickr.html        # 日期選擇器頁面\n└── image/                     # 文檔圖片資源\n    └── README/               # README 說明圖片\n\n背景與問題\n實驗性質定義\nCalu-app是一個技術驗證型專案，主要目標不在於創造完美的產品，而在於探索和驗證現代Web工具開發的技術可行性：\n核心驗證目標：\n\nGradio框架在實用工具開發中的適用性\n本地AI模型(Ollama)與Web應用的整合模式\nDocker容器化對於Python Web應用的部署價值\n多功能整合式工具的用戶體驗設計\n\n技術選型邏輯：\n實用性優先 → Gradio (零前端開發)\nAI能力整合 → Ollama (本地化，隱私安全)\n部署簡化 → Docker (環境一致性)\n開發效率 → Python生態系統\n\n第一性原理分析\n工具本質：解決日常計算與資訊處理的重複性工作\n技術本質：將複雜的技術能力包裝為簡單的用戶界面\n整合本質：在統一平台上提供多樣化功能，減少工具切換成本\n技術架構深度解析\n整體架構設計\n┌─────────────────────────────────────────────────────┐\n│                 Web Browser                         │\n├─────────────────────────────────────────────────────┤\n│                Gradio Frontend                      │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │\n│  │ 日期計算     │ │ 年份轉換     │ │ AI聊天      │   │\n│  │ 界面         │ │ 界面         │ │ 界面         │   │\n│  └─────────────┘ └─────────────┘ └─────────────┘   │\n├─────────────────────────────────────────────────────┤\n│                Gradio Server                        │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │\n│  │ date_utils  │ │format_utils │ │ ai_utils    │   │\n│  │ 日期邏輯     │ │ 格式化邏輯   │ │ AI整合邏輯  │   │\n│  └─────────────┘ └─────────────┘ └─────────────┘   │\n├─────────────────────────────────────────────────────┤\n│              External Services                      │\n│  ┌─────────────────────────────────────────────────┐│\n│  │        Ollama API (localhost:11434)            ││\n│  │  ┌─────────────┐ ┌─────────────┐ ┌──────────┐  ││\n│  │  │   llama3.2  │ │  mistral    │ │  custom  │  ││\n│  │  │   3b model  │ │   7b model  │ │  models  │  ││\n│  │  └─────────────┘ └─────────────┘ └──────────┘  ││\n│  └─────────────────────────────────────────────────┘│\n└─────────────────────────────────────────────────────┘\n\n關鍵技術決策分析\n1. Gradio選型的深層考量\n優勢驗證：\n\n零前端負擔：Python開發者無需學習React/Vue等框架\n快速原型能力：從概念到可用界面在小時級別完成\n自動響應式設計：無需手動處理移動端適配\n內建組件豐富：文本框、按鈕、表格等常用組件開箱即用\n\n限制發現：\n\n客製化受限：界面風格受限於Gradio預設樣式\n複雜交互困難：難以實現複雜的用戶交互邏輯\n效能考量：大量數據展示時效能不如原生前端框架\n\n適用場景結論：\n適合內部工具、原型驗證、功能演示，但不適合商業級產品開發\n2. Ollama整合的創新嘗試\n技術整合模式：\n# 創新的年份轉換AI輔助\ndef ai_assisted_date_conversion(input_text, model=&quot;llama3.2:3b&quot;):\n    # 1. 傳統正規化處理\n    traditional_result = regex_based_conversion(input_text)\n    \n    # 2. AI推理備援\n    if not traditional_result:\n        ai_prompt = f&quot;將以下日期轉換為民國年和西元年: {input_text}&quot;\n        ai_result = ollama_client.chat(model, ai_prompt)\n        return parse_ai_response(ai_result)\n    \n    return traditional_result\n創新價值評估：\n\n探索性價值：驗證小型LLM在邊緣計算場景的實用性\n隱私保護：本地推理，無資料外洩風險\n成本控制：無API調用費用，可持續運行\n\n效果與限制：\n\nllama3.2 3b模型在簡單轉換任務上表現不穩定\n但展現了未來AI輔助計算的潛在價值\n為更強大的本地模型預留了架構空間\n\n模組化設計實踐\n高內聚低耦合架構\n# utils/date_utils.py - 專注日期處理\ndef calculate_time_difference(start, end):\n    &quot;&quot;&quot;計算時間差，單一職責原則&quot;&quot;&quot;\n    \ndef convert_date(date_input):\n    &quot;&quot;&quot;年份轉換，包含AI輔助邏輯&quot;&quot;&quot;\n \n# utils/format_utils.py - 專注格式化\ndef clean_input(text):\n    &quot;&quot;&quot;文本清理，獨立功能模組&quot;&quot;&quot;\n    \ndef validate_date_format(date_str):\n    &quot;&quot;&quot;日期格式驗證，可重用函數&quot;&quot;&quot;\n \n# utils/ai_utils.py - 專注AI整合\ndef get_ollama_models():\n    &quot;&quot;&quot;模型列表獲取&quot;&quot;&quot;\n    \ndef chat_with_model(model, message, system_prompt):\n    &quot;&quot;&quot;AI對話核心邏輯&quot;&quot;&quot;\nKISS原則的實踐體現\n\n簡單界面：使用Gradio避免複雜的前端開發\n直接整合：直接調用Ollama API，不增加中間層\n最小依賴：requirements.txt僅包含必要套件\n單一入口：main.py作為唯一啟動點\n\n功能模組深度分析\n1. 日期計算機 - 基礎工具模組\n技術實現細節\ndef calculate_time_difference(start_time, end_time):\n    try:\n        # 多格式支援的日期解析\n        formats = [\n            &quot;%Y/%m/%d %H:%M&quot;,\n            &quot;%Y-%m-%d %H:%M&quot;, \n            &quot;%Y/%m/%d&quot;,\n            &quot;%Y-%m-%d&quot;\n        ]\n        \n        start_dt = parse_flexible_date(start_time, formats)\n        end_dt = parse_flexible_date(end_time, formats)\n        \n        # 精確到分鐘的計算\n        diff = end_dt - start_dt\n        \n        return format_time_difference(diff)\n        \n    except ValueError as e:\n        return f&quot;日期格式錯誤: {str(e)}&quot;\n用戶體驗設計\n\n靈活輸入：支援多種日期格式，降低用戶學習成本\n即時計算：點擊按鈕即可獲得結果，無需等待\n錯誤友善：清晰的錯誤訊息，幫助用戶修正輸入\n\n實用價值評估\n⭐⭐⭐⭐ 高實用性，工作中經常需要計算時間間隔\n2. 年份轉換器 - AI輔助實驗模組\n創新技術嘗試\ndef convert_date_with_ai_fallback(date_input):\n    # 階段1：傳統正規化處理\n    traditional_result = regex_conversion(date_input)\n    \n    if traditional_result[&quot;confidence&quot;] &gt; 0.8:\n        return traditional_result\n    \n    # 階段2：AI推理輔助\n    ai_result = ai_assisted_conversion(date_input)\n    \n    # 階段3：結果整合與驗證\n    return integrate_results(traditional_result, ai_result)\n技術實驗結論\n\n模型限制：llama3.2 3b在數值轉換上不夠可靠\n架構價值：為未來更強大的模型預留了整合空間\n方法論貢獻：建立了傳統算法與AI推理的混合模式\n\n創新程度評估\n⭐⭐⭐⭐ 在傳統工具中整合AI能力的有益嘗試\n3. 便當價格推估 - 數學建模模組\n演算法實現\ndef future_bento_price(base_year, base_price, target_year, inflation_rate=0.02):\n    &quot;&quot;&quot;\n    基於複合成長率的價格預測模型\n    P(t) = P0 * (1 + r)^(t-t0)\n    &quot;&quot;&quot;\n    years_diff = target_year - base_year\n    future_price = base_price * (1 + inflation_rate) ** years_diff\n    \n    return {\n        &quot;predicted_price&quot;: round(future_price, 2),\n        &quot;growth_factor&quot;: round((1 + inflation_rate) ** years_diff, 4),\n        &quot;total_increase&quot;: round(future_price - base_price, 2)\n    }\n教育與娛樂價值\n\n經濟學概念：展示通膨對日常商品價格的影響\n數學建模：簡單但有效的預測模型實作\n趣味互動：增加工具的娛樂性和探索性\n\n4. AI聊天 - 核心創新模組\nOllama整合架構\ndef setup_ai_chat():\n    &quot;&quot;&quot;建立AI聊天環境&quot;&quot;&quot;\n    try:\n        client = Client(host=&#039;http://localhost:11434&#039;)\n        models = client.list()\n        return client, [model[&#039;name&#039;] for model in models[&#039;models&#039;]]\n    except:\n        return None, [&quot;連接失敗&quot;]\n \ndef chat_with_ollama(model, message, system_prompt, history):\n    &quot;&quot;&quot;實現對話記憶的AI聊天&quot;&quot;&quot;\n    full_conversation = build_conversation_context(history, system_prompt)\n    \n    response = client.chat(\n        model=model,\n        messages=full_conversation + [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message}]\n    )\n    \n    return response[&#039;message&#039;][&#039;content&#039;]\n用戶體驗創新\n\n模型選擇彈性：用戶可根據需求選擇不同模型\n系統提示客製化：允許用戶定義AI的角色和行為風格\n對話記憶維護：保持對話上下文的連貫性\n\n技術價值貢獻\n\n本地AI整合模式：為本地AI應用建立了標準參考\n隱私保護實踐：所有對話資料不離開本地環境\n成本控制示範：無需API費用的AI功能實現\n\n容器化部署實踐\nDocker化的技術考量\nDockerfile設計哲學\nFROM python:3.11-slim\n \n# 最小化依賴安裝\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n \n# 非root用戶運行\nRUN useradd -m -u 1000 calu\nUSER calu\n \n# 健康檢查機制\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:7861/ || exit 1\n \nCMD [&quot;python&quot;, &quot;main.py&quot;]\n安全性考量\n\n最小權限原則：使用非root用戶運行應用\n最小化攻擊面：僅開放必要端口(7861)\n依賴漏洞管理：使用slim基礎鏡像減少潜在漏洞\n\n可移植性驗證\n\n跨平台測試：在Windows、macOS、Linux環境驗證\n環境隔離：確保容器內外環境完全隔離\n版本一致性：確保開發與生產環境的一致性\n\ndocker-compose最佳實踐\nversion: &#039;3.8&#039;\nservices:\n  calu-app:\n    build: .\n    container_name: doc-toolbox\n    ports:\n      - &quot;7861:7861&quot;\n    environment:\n      - APP_PORT=7861\n    restart: unless-stopped\n    healthcheck:\n      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:7861&quot;]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n技術方案\n核心技術選型\nGradio框架選型理由：\n\n零前端開發負擔，Python開發者可直接上手\n快速原型能力，從概念到界面小時級完成\n自動響應式設計，無需手動適配移動端\n內建豐富組件，滿足基礎工具開發需求\n\nOllama本地AI整合：\n\n隱私保護：所有AI對話不離開本地環境\n成本控制：無API調用費用，可持續運行\n離線可用：不依賴網路連接的AI功能\n模型選擇：支援多種開源LLM模型\n\nDocker容器化部署：\n\n環境一致性：開發與生產環境完全相同\n部署簡化：一鍵啟動完整應用棧\n隔離安全：容器內外環境完全隔離\n跨平台支援：Windows、macOS、Linux通用\n\n核心實作\n多功能工具整合架構\n# 主應用程式架構\nwith gr.Blocks() as demo:\n    with gr.Tabs():\n        # 1. 日期計算工具\n        with gr.Tab(&quot;日期計算&quot;):\n            date_calculator_interface()\n            \n        # 2. 年份轉換工具（含AI輔助）\n        with gr.Tab(&quot;年份轉換&quot;):\n            year_converter_interface()\n            \n        # 3. 文字格式化工具\n        with gr.Tab(&quot;格式化工具&quot;):\n            text_formatter_interface()\n            \n        # 4. 價格預測工具\n        with gr.Tab(&quot;便當價格推估&quot;):\n            price_predictor_interface()\n            \n        # 5. AI聊天功能\n        with gr.Tab(&quot;AI聊天&quot;):\n            ai_chat_interface()\nAI能力整合創新\n混合智能模式：\ndef hybrid_date_conversion(input_text):\n    # 傳統正規化處理\n    traditional_result = regex_based_conversion(input_text)\n    \n    # AI推理輔助（當傳統方法失效）\n    if not traditional_result:\n        ai_result = ollama_assisted_conversion(input_text)\n        return validate_and_return(ai_result)\n    \n    return traditional_result\n本地AI整合模式：\ndef setup_ollama_integration():\n    client = Client(host=&#039;http://localhost:11434&#039;)\n    available_models = client.list()[&#039;models&#039;]\n    \n    return {\n        &#039;client&#039;: client,\n        &#039;models&#039;: [model[&#039;name&#039;] for model in available_models],\n        &#039;default_model&#039;: &#039;llama3.2:3b&#039;\n    }\n效果與學習\n技術驗證成果\n成功驗證的技術假設：\n\n✅ Gradio適合快速工具原型開發\n✅ 本地AI模型可實用化整合\n✅ Docker部署大幅簡化環境管理\n✅ 多功能整合提升工具使用效率\n\n發現的技術限制：\n\n⚠️ Gradio界面客製化能力有限\n⚠️ llama3.2 3b在數值計算上不穩定\n⚠️ 單體架構限制功能獨立擴展\n\n創新價值與影響\n技術貢獻：\n\n建立了Gradio + Ollama標準整合模式\n驗證了混合智能計算的實用性\n提供了快速工具開發的參考框架\n\n方法論貢獻：\n\n實驗驅動的技術驗證流程\n漸進式功能擴展策略\n知識沈澱與經驗傳承模式\n\n時間軸\n2025-01-09 10:00 基礎建立階段\n\n建立基本日期計算機功能\n驗證Gradio框架基礎可行性\n確立Python + Gradio技術路線\n實現第一個實用工具模組\n\n2025-01-09 14:00 架構重構階段\n\n程式碼結構化，拆分utils目錄\n實踐高內聚低耦合設計原則\n建立可維護的模組化架構\n為後續功能擴展打下基礎\n\n2025-01-09 18:00 容器化探索階段\n\n首次Docker化，建立部署標準\n驗證容器化部署的便利性\n建立跨平台部署解決方案\n確保開發與生產環境一致性\n\n2025-01-10 09:00 AI能力整合階段\n\n首次引入Ollama本地AI功能\n實現AI聊天界面與後端整合\n驗證小型LLM在實際應用中的效果\n建立本地AI應用的參考架構\n\n2025-01-26 11:00 功能完善階段\n\n增強AI聊天功能，支援多模型選擇\n優化用戶體驗，增加配置彈性\n提升AI交互品質和穩定性\n滿足多樣化AI應用需求\n\n2025-07-05 16:00 文檔完善階段\n\n大幅擴充README，增加功能預覽\n提升專案文檔化成熟度\n準備知識傳承和技術分享\n建立專案展示標準\n\n2025-07-05 20:00 系統分析階段\n\n完成專案系統化分析\n提取可重用技術組件\n建立技術實驗標準流程\n沈澱經驗為後續專案參考\n\n\n⏰ 總投入時間：約40小時分散開發 | 🎯 成果：多功能工具平台完成 | 📚 學習：Gradio+AI整合完整實踐\n開發模式與方法論\n漸進式創新模式\n發展路徑：\n基礎功能 → 架構優化 → 部署改進 → AI整合 → 用戶體驗 → 展示完善\n\n核心特點：\n\n每階段明確技術目標\n風險控制：逐步驗證，降低失敗風險\n學習驅動：從實踐中獲得技術洞察\n知識沈澱：經驗轉化為可傳承資產\n\n技術決策演進邏輯\n\n需求驅動：從實際使用場景出發\n技術驗證：小步快跑，快速驗證可行性\n架構優化：基於驗證結果優化技術選型\n能力擴展：在穩定基礎上增加新能力\n體驗提升：持續改進用戶體驗\n知識沈澱：將經驗轉化為可傳承的知識\n\n技術創新點與局限性\n創新貢獻\n1. 本地AI整合模式創新\n貢獻：建立了Gradio + Ollama的標準整合模式\n# 創新的AI功能整合模式\ndef integrate_ai_capability(gradio_interface, ollama_client):\n    &quot;&quot;&quot;\n    將本地AI能力無縫整合到Web工具中\n    實現隱私保護、成本控制、離線可用的AI功能\n    &quot;&quot;&quot;\n影響：為後續本地AI應用開發提供了參考框架\n2. 混合智能計算模式\n貢獻：建立了傳統算法與AI推理的混合模式\n# 混合智能的實現模式\ndef hybrid_intelligent_processing(input_data):\n    traditional_result = rule_based_processing(input_data)\n    if confidence_low(traditional_result):\n        ai_result = ai_assisted_processing(input_data)\n        return integrate_results(traditional_result, ai_result)\n    return traditional_result\n價值：在可靠性和智能性之間找到平衡\n3. 快速工具原型開發模式\n貢獻：驗證了Gradio在快速工具開發中的價值\n\n開發效率：從概念到可用工具在小時級別\n技術門檻：Python開發者無需學習前端技術\n部署便利：一鍵Docker部署\n\n技術局限性\n1. Gradio框架限制\n界面客製化有限：\n\n無法實現複雜的交互邏輯\n視覺設計受限於預設主題\n大量數據展示效能不佳\n\n適用場景限制：\n\n適合內部工具，不適合商業產品\n適合功能演示，不適合複雜應用\n\n2. AI模型能力限制\nllama3.2 3b模型限制：\n\n數值計算準確性不足\n複雜推理能力有限\n回應品質不穩定\n\n本地部署限制：\n\n模型選擇受限於硬體能力\n推理速度受限於本地算力\n模型更新需要手動管理\n\n3. 架構擴展性限制\n單體應用架構：\n\n功能模組雖然分離，但仍為單體部署\n難以實現獨立的功能擴展\n缺乏微服務架構的彈性\n\n狀態管理限制：\n\nGradio的狀態管理能力有限\n難以實現複雜的用戶會話管理\n缺乏持久化儲存機制\n\n可重用元件提取\n1. Gradio-Ollama整合模組\n標準化整合模式\nclass GradioOllamaIntegrator:\n    &quot;&quot;&quot;可重用的Gradio-Ollama整合組件&quot;&quot;&quot;\n    \n    def __init__(self, ollama_host=&quot;http://localhost:11434&quot;):\n        self.client = Client(host=ollama_host)\n        self.models = self.load_available_models()\n    \n    def create_chat_interface(self):\n        &quot;&quot;&quot;創建標準化的AI聊天界面&quot;&quot;&quot;\n        with gr.Tab(&quot;AI聊天&quot;):\n            model_dropdown = gr.Dropdown(\n                choices=self.models,\n                label=&quot;選擇模型&quot;\n            )\n            system_prompt = gr.Textbox(\n                label=&quot;系統提示&quot;,\n                placeholder=&quot;定義AI的角色和行為...&quot;\n            )\n            # ... 其他界面元素\n            \n    def chat_handler(self, model, message, system_prompt, history):\n        &quot;&quot;&quot;標準化的聊天處理邏輯&quot;&quot;&quot;\n        # 可重用的對話處理邏輯\n重用價值\n\n快速AI整合：30分鐘內為任何Gradio應用增加AI功能\n標準化介面：統一的AI交互模式\n配置靈活性：支援不同模型和提示配置\n\n2. Docker化部署模板\n標準化容器配置\n# 可重用的Python Web應用Docker模板\nFROM python:3.11-slim\n \n# 標準化的安全配置\nRUN useradd -m -u 1000 appuser\nUSER appuser\n \n# 標準化的健康檢查\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:${APP_PORT}/ || exit 1\n \n# 標準化的啟動方式\nCMD [&quot;python&quot;, &quot;main.py&quot;]\ndocker-compose模板\n# 可重用的部署配置模板\nversion: &#039;3.8&#039;\nservices:\n  web-tool:\n    build: .\n    ports:\n      - &quot;${HOST_PORT}:${CONTAINER_PORT}&quot;\n    environment:\n      - APP_PORT=${CONTAINER_PORT}\n    restart: unless-stopped\n    healthcheck:\n      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:${CONTAINER_PORT}&quot;]\n3. 工具功能模組模板\n通用工具模組結構\n# utils/tool_template.py\nclass ToolModule:\n    &quot;&quot;&quot;可重用的工具模組基礎類別&quot;&quot;&quot;\n    \n    def __init__(self):\n        self.name = &quot;工具名稱&quot;\n        self.description = &quot;工具描述&quot;\n    \n    def validate_input(self, input_data):\n        &quot;&quot;&quot;輸入驗證邏輯&quot;&quot;&quot;\n        pass\n    \n    def process(self, input_data):\n        &quot;&quot;&quot;核心處理邏輯&quot;&quot;&quot;\n        pass\n    \n    def format_output(self, result):\n        &quot;&quot;&quot;輸出格式化&quot;&quot;&quot;\n        pass\n    \n    def create_gradio_interface(self):\n        &quot;&quot;&quot;創建Gradio界面&quot;&quot;&quot;\n        pass\n專案影響與啟發\n對後續專案的影響\n1. 技術棧選型指導\nGradio適用場景：\n\n✅ 內部工具快速開發\n✅ 原型驗證和概念展示\n✅ AI能力包裝和展示\n❌ 商業級產品開發\n❌ 複雜交互需求場景\n\nAI整合策略：\n\n本地化部署優先考慮隱私和成本\n混合智能模式平衡可靠性和智能性\n模型選擇需要考慮實際任務複雜度\n\n2. 開發流程優化\n快速原型模式：\n概念 → 最小可用版本 → 架構優化 → 功能擴展 → 體驗提升\n\n風險控制策略：\n\n分階段技術驗證\n每個階段設定明確的成功標準\n及時止損，避免沈沒成本\n\n3. 知識管理實踐\n技術實驗文檔化：\n\n記錄技術選型的決策邏輯\n保留失敗嘗試的經驗教訓\n提取可重用的技術模組\n\n對個人技能發展的影響\n1. 全棧思維建立\n通過這個專案，從Python後端開發者擴展到：\n\n前端意識：理解用戶界面設計的重要性\n部署運維：掌握容器化部署的實踐\n產品思維：從技術實現轉向用戶價值思考\n\n2. AI整合能力\n建立了AI應用開發的基礎能力：\n\n模型選型能力：理解不同模型的能力邊界\n整合架構設計：掌握AI能力整合的技術模式\n效果評估方法：建立AI功能效果的評估標準\n\n3. 系統分析能力\n通過項目復盤，提升了系統分析能力：\n\n技術決策分析：理解技術選型的邏輯和後果\n架構演進理解：掌握專案架構演進的模式\n價值評估能力：平衡技術可行性和商業價值\n\n對技術社群的貢獻\n1. 最佳實踐分享\nGradio + Ollama整合模式：\n\n提供了可複製的技術整合方案\n建立了本地AI應用的參考架構\n分享了混合智能計算的實踐經驗\n\n2. 開源技術驗證\n小型LLM實用性驗證：\n\n提供了llama3.2 3b在實際應用中的效果數據\n驗證了本地AI模型的可行性和限制\n為後續模型選型提供參考\n\n3. 技術教育資源\n實踐驅動的學習資源：\n\n提供了完整的技術實驗過程記錄\n建立了從概念到實現的完整案例\n創建了可重用的技術模組和模板\n\n後續發展方向\n短期改進計劃\n1. 技術債務清理\n效能優化：\n\n優化Gradio界面的響應速度\n改進AI模型的推理效率\n增加錯誤處理和用戶提示\n\n代碼品質提升：\n\n增加單元測試覆蓋\n完善代碼文檔\n統一代碼風格\n\n2. 功能擴展\n新工具模組：\n\n增加更多日常實用工具\n擴展AI能力應用場景\n增加數據處理工具\n\n用戶體驗改進：\n\n增加用戶偏好保存\n改進界面響應性\n增加功能使用指導\n\n中期技術升級\n1. 架構重構\n微服務化改造：\n\n將工具模組拆分為獨立服務\n實現功能的獨立部署和擴展\n增加服務間的標準化溝通協議\n\nAPI化改造：\n\n提供RESTful API接口\n支援第三方應用整合\n建立標準化的服務介面\n\n2. AI能力升級\n模型能力提升：\n\n測試更強大的本地模型\n整合專業領域模型\n實現模型的動態切換\n\n智能化增強：\n\n增加自然語言查詢能力\n實現智能化的工具推薦\n建立用戶行為學習機制\n\n長期願景規劃\n1. 平台化發展\n工具生態系統：\n\n建立第三方工具開發框架\n創建工具市場和分享機制\n實現工具的組合和工作流程化\n\n開源社群建設：\n\n建立開發者社群\n創建貢獻指南和標準\n實現社群驅動的發展模式\n\n2. 商業化探索\n企業級功能：\n\n增加企業級安全和權限管理\n提供企業級部署和支援服務\n建立技術諮詢和客製化服務\n\n服務模式創新：\n\n探索SaaS服務模式\n建立訂閱和授權體系\n發展技術培訓和認證服務\n\n總結與價值評估\n專案核心價值總結\n1. 技術驗證價值\n成功驗證：\n\nGradio在快速工具開發中的實用性 ✅\n本地AI模型的整合可行性 ✅\nDocker容器化部署的便利性 ✅\n混合智能計算模式的有效性 ✅\n\n發現限制：\n\nGradio在商業應用中的局限性 ⚠️\n小型LLM在複雜任務中的不穩定性 ⚠️\n單體架構在功能擴展中的限制 ⚠️\n\n2. 學習與成長價值\n技術能力提升：\n\n掌握了Gradio快速原型開發技術\n建立了本地AI整合的技術能力\n提升了容器化部署的實戰經驗\n發展了全棧思維和產品意識\n\n方法論建立：\n\n建立了技術實驗的標準流程\n發展了風險控制的實踐方法\n創建了知識管理的有效模式\n\n3. 可重用資產價值\n技術模組：\n\nGradio-Ollama整合組件\nDocker部署配置模板\n工具開發標準架構\n\n知識資產：\n\n技術選型決策框架\n開發流程最佳實踐\n風險評估和控制方法\n\n對selfpagesource體系的貢獻\n1. 專案模板貢獻\n本專案為selfpagesource提供了實驗型技術專案的標準化分析模板：\n\n技術驗證型專案的分析框架\n開發歷程的系統化梳理方法\n技術債務和限制的識別模式\n\n2. 可重用元件貢獻\n提取的技術組件可直接應用於後續專案：\n\nAI整合標準模式\n容器化部署模板\n快速原型開發流程\n\n3. 知識體系貢獻\n為技術知識庫增加了重要的實踐案例：\n\n現代Web工具開發的技術路線選擇\n本地AI應用的實踐經驗和限制\n技術實驗到產品化的轉換思路\n\n專案成熟度評估\n技術成熟度：⭐⭐⭐⭐ (實驗驗證成功)\n\n核心功能穩定可用\n技術架構經過驗證\n部署流程標準化\n文檔和知識完備\n\n商業價值：⭐⭐⭐ (概念驗證階段)\n\n具有實用工具價值\n技術模式可複製\n需要進一步商業化探索\n\n可維護性：⭐⭐⭐⭐ (良好的代碼組織)\n\n模組化設計清晰\n文檔覆蓋完整\n技術債務控制良好\n\n擴展性：⭐⭐⭐ (架構支援有限擴展)\n\n功能模組可獨立開發\n部署配置可複製\n需要架構升級支援大規模擴展\n\n\n維護時間軸\n2025-07-05 最新維護記錄\n\n專案檢查：確認專案當前狀態，所有功能正常運作\n授權補充：已添加 PEKORA-LICENSE 到專案根目錄\n文檔更新：更新專案文檔，確保資訊同步\n技術確認：驗證 Gradio 5.11.0 + Ollama 整合架構穩定性\n\n\n專案評級：⭐⭐⭐⭐ 成功的技術驗證專案，為後續開發提供了寶貴的實踐經驗和可重用資產\n推薦等級：高度推薦作為技術實驗和快速原型開發的參考案例\n維護建議：持續跟進技術發展，適時進行架構升級和功能擴展\n專案負責人：PekoraTech SA Team\n技術審查狀態：✅ 已完成系統分析\n文檔狀態：✅ 已完成專案文檔化\n授權狀態：✅ 已添加 PEKORA-LICENSE\n下一階段：提取可重用組件，建立技術標準\n專案映射\n\n開發資料夾：/Volumes/Code/Calu-app\nGitHub倉庫：未設定（本地實驗專案）\n相關專案：與其他 AI 工具整合專案相關\n"},"projects/index":{"slug":"projects/index","filePath":"projects/index.md","title":"專案建置與分析","links":["projects/mcp-git-analyzer-project","doc/guides/mcp-development-guide","component/mcp-development-framework"],"tags":["專案分析","架構設計","技術整合","系統分析"],"content":"專案建置與分析\n\n透過系統分析師視角，將分散的專案經驗整合為系統性的技術洞察\n\n核心定位\n專案理解與轉換\n作為SA(系統分析師)，本模組專注於將技術專案進行深度理解與分析，並轉換為標準化的開發歷程文件。每篇分析都結合多個實際專案的經驗，從第一性原理出發，探討架構設計、技術選型和工程實踐。\n保密與分享的平衡\n技術方法論：完整分享 → 促進技術交流\n架構設計思維：標準展示 → 展現專業能力  \n實作技術細節：選擇性公開 → 保護競爭優勢\n核心商業邏輯：嚴格保密 → 維護創新價值\n\n分析架構體系\n第一性原理分析框架\n問題本質識別 → 需求分析 → 技術選型 → 架構設計 → 實現策略 → 效果驗證 → 經驗萃取\n\n核心分析原則\n\n高內聚低耦合：清晰的職責邊界與模組化設計\nKISS原則實踐：選擇合適工具，避免過度工程\n漸進式改進：從MVP到完整系統的演進路徑\n可測試性優先：架構設計考慮測試與維護成本\n\n專案分析概覽\nAI技術生態系統\nMCP Git分析器專案 🆕\n專案背景：基於Model Context Protocol的Git專案理解工具，實現系統分析師工作流程自動化\n架構分析要點：\n\nMCP協議整合：AI助手與專業工具的標準化整合模式\n多維度分析：時間軸、階段、洞察、狀態的全方位分析框架\n安全設計：唯讀操作、路徑驗證、內容過濾的多層防護\n可擴展架構：模組化設計、插件化支援、標準化介面\n\n技術選型決策：\n\nNode.js + MCP SDK：AI生態系統的原生整合\nsimple-git庫：無原生依賴的穩定選擇\nnpx部署：無需安裝的便捷啟動\nTypeScript支援：類型安全與開發體驗平衡\n\n核心成果：\n\n實現5個核心MCP工具，覆蓋完整的專案分析流程\n專案理解時間從4小時縮短至30分鐘（87.5%效率提升）\n建立可重用的MCP工具開發框架與最佳實踐\n通過Claude Desktop測試，驗證AI助手整合的實用性\n\n相關連結：\n\n專案文件：MCP Git分析器專案\n技術指南：MCP開發指南\n可重用元件：MCP開發框架\n\n智能服務架構演進\n專案背景：從test-ai-benchmark + test-ai-memory演進的綜合AI服務平台\n架構分析要點：\n\n微服務分離：AI推理、檔案處理、快取管理的清晰邊界\n效能優化策略：異步批次處理實現30%吞吐量提升\n可擴展設計：插件化架構支援多種AI模型整合\n監控體系：實時效能分析與自動調優機制\n\n技術選型決策：\n\nPython + FastAPI：快速開發與高效能平衡\nOllama整合：本地AI推理的標準化接入\nRedis快取：減少重複計算的智能快取策略\nDocker容器化：環境一致性與部署標準化\n\n關鍵學習：\n微服務邊界設計 = 業務職責 + 技術限制 + 維護成本\n效能優化 = 瓶頸識別 + 漸進改進 + 量化驗證\n可擴展性 = 抽象介面 + 配置外部化 + 監控可觀測性\n\n瀏覽器擴展生態建構\n跨域通信解決方案\n專案背景：test-baba-chrome-extension-tools + AI微服務的深度整合\n架構演進軌跡：\n單一功能擴展 → 功能模組化 → AI能力整合 → 生態系統協作\n\n核心技術挑戰與解決：\n\n跨域限制：微服務代理層解決瀏覽器安全策略限制\n狀態同步：Service Worker + IndexedDB實現可靠的狀態持久化\nUI一致性：React組件庫確保多擴展間的視覺統一\n測試策略：Mock驅動開發 + 端到端整合測試\n\n技術決策分析：\n\nManifest V3遷移：平衡新API限制與功能需求\n通信架構設計：WebExtension API + 微服務代理的混合模式\n狀態管理策略：本地存儲 + 雲端同步的多層次方案\n\n系統架構模式庫\n微服務架構實踐\n設計原則總結：\n服務拆分策略:\n  - 按業務能力劃分職責邊界\n  - 確保資料獨立性與一致性\n  - 平衡服務粒度與通信成本\n \n通信模式選擇:\n  - RESTful API：同步操作的標準化介面\n  - Message Queue：異步處理的可靠性保證\n  - gRPC：高效能內部服務通信\n \n治理與監控:\n  - 服務發現與註冊中心\n  - 負載均衡與容錯處理\n  - 分散式追蹤與監控告警\n事件驅動架構\n應用場景與效果：\n\n系統解耦：減少服務間直接依賴\n可擴展性：支援水平擴展與動態調整\n容錯性：故障隔離與自動恢復機制\n\n領域驅動設計(DDD)實踐\n分層架構應用：\n領域層：核心業務邏輯與規則\n應用層：用例協調與流程控制  \n基礎設施層：外部服務與資料存取\n介面層：API設計與用戶互動\n\n技術決策框架\n技術選型決策樹\n專案需求分析 → 規模評估 → 架構模式選擇 → 技術棧確定 → 實作策略制定\n\n決策考量因素\n\n功能需求：核心功能與擴展需求的平衡\n非功能需求：效能、安全、可維護性要求\n團隊能力：技術棧熟悉度與學習成本\n專案約束：時間、資源、合規要求\n\n架構決策記錄(ADR)範例\n## 決策：選擇微服務架構模式\n \n### 背景\n單體應用在業務快速發展下出現擴展瓶頸\n \n### 考慮方案\n1. 分層架構優化：低成本，但擴展性有限\n2. 模組化重構：中等成本，部分解決問題\n3. 微服務拆分：高成本，徹底解決擴展問題\n \n### 決策結果\n選擇微服務架構，分階段漸進式遷移\n \n### 影響與後果\n正面：獨立部署、技術棧靈活、團隊自主性\n負面：複雜度增加、運維成本上升、一致性挑戰\n效能優化實踐\n系統效能提升記錄\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n優化項目優化前優化後提升幅度核心策略AI推理延遲145ms98ms32.4%異步批次處理擴展載入時間2.3s1.1s52.2%代碼分割優化API吞吐量68 req/s102 req/s50.0%連接池優化\n效能優化方法論\n瓶頸識別 → 根因分析 → 方案設計 → 漸進實施 → 效果驗證 → 監控維護\n\n通用優化策略：\n\n前端優化：程式碼分割、CDN加速、快取策略\n後端優化：資料庫查詢優化、API壓縮、負載均衡\n系統優化：資源池管理、異步處理、監控告警\n\n實驗性技術探索\nAI原生開發模式\n探索方向：\n\nAI輔助的程式碼生成與優化\n自適應系統的智能調優\n邊緣運算與分散式AI推理\n\n新興技術整合\n技術評估框架：\n\n技術成熟度評估\n業務價值分析\n整合成本估算\n風險評估與緩解\n\n專案管理與交付\n敏捷開發實踐\n\n迭代式開發與持續交付\n跨功能團隊協作模式\n客戶回饋驅動的產品改進\n\n品質保證體系\n單元測試 → 整合測試 → 系統測試 → 用戶驗收測試\n    ↓           ↓           ↓            ↓\n代碼品質    模組協作    系統穩定性    用戶滿意度\n\n風險管理策略\n\n技術風險：技術可行性驗證、備用方案準備\n進度風險：里程碑追蹤、資源調配優化\n品質風險：自動化測試、代碼審查機制\n\n學習與成長軌跡\n技術能力發展\n基礎技能掌握 → 架構思維建立 → 系統設計能力 → 技術領導力\n\n知識管理策略\n\n經驗萃取：從專案實踐中總結可重用模式\n知識分享：透過文檔與分享促進團隊學習\n持續學習：跟進技術趨勢與最佳實踐\n\n職業發展規劃\n\n技術專精：在特定領域建立深度專業能力\n架構設計：發展系統性的架構設計思維\n團隊領導：培養技術團隊的領導與協作能力\n\n專案路線圖\n短期計劃（1-3個月）\n\n完善現有專案的文檔體系\n建立標準化的專案分析模板\n強化效能監控與優化流程\n\n中期目標（3-6個月）\n\n建立跨專案的技術元件庫\n發展AI驅動的開發輔助工具\n建立技術決策的量化評估機制\n\n長期願景（6-12個月）\n\n形成可複製的專案交付模式\n建立技術影響力與行業認知\n發展創新技術的商業化應用\n\n\n核心價值：透過系統化的專案分析，將技術經驗轉化為可重複利用的知識資產，在保護核心競爭優勢的同時，展現專業的技術分析能力。\n方法論總結：第一性原理思考 + KISS原則實踐 + 高內聚低耦合設計 = 可持續的技術專案成功模式\n維護責任：PekoraTech SA Team - Project Analysis\n更新策略：每完成一個專案milestone後進行深度分析與總結\n最後更新：2025-07-05"},"projects/project-index":{"slug":"projects/project-index","filePath":"projects/project-index.md","title":"專案清單","links":["tags/ProjectManagement","tags/AutoGenerated","tags/DeveloperTools","tags/TechStack","tags/CodeAnalysis"],"tags":["專案管理","自動生成","開發總覽","ProjectManagement","AutoGenerated","DeveloperTools","TechStack","CodeAnalysis"],"content":"🚀 專案清單\n\n最後更新：2025年6月28日 14:30:22\n本頁面由專案掃描器自動生成，展示 E:\\PD_DEV 下所有 Git 專案\n\n📊 專案統計\n\n總專案數量：12\n活躍專案：8\n技術棧分佈：AI/ML, Game Development, Browser Extensions, Flutter, Python, JavaScript, Node.js\n總程式碼行數：約 50,000+ 行\n最近活躍期：2025-06-28\n\npie title 專案類型分佈\n    &quot;AI/ML工具&quot; : 25\n    &quot;遊戲開發&quot; : 30\n    &quot;瀏覽器擴展&quot; : 20\n    &quot;移動開發&quot; : 15\n    &quot;開發工具&quot; : 10\n\n\n📁 專案列表\n🤖 test-ai-benchmark\n路徑：E:\\PD_DEV\\test-ai-benchmark\n技術棧：Python, AI/ML, Performance Testing\n最後提交：a7f3b2e - 優化批次處理效能，提升30%吞吐量 (2025-06-28)\n提交數量：47\n簡介：Python 基準測試工具，專注於 AI 模型效能評估。支援多種模型並發測試、記憶體使用監控、詳細效能分析報告生成。主要用於評估不同 AI 模型在生產環境下的表現…\n亮點功能：\n\n🚀 異步批次處理，提升 30% 效能\n📊 實時效能監控儀表板\n🔧 可配置的測試套件\n📈 詳細的分析報告生成\n\n\n🧠 test-ai-memory\n路徑：E:\\PD_DEV\\test-ai-memory\n技術棧：JavaScript, Chrome Extension, Node.js, AI/ML, Microservices\n最後提交：d2c8f9a - 新增檔案分析API，支援PDF/Word處理 (2025-06-27)\n提交數量：63\n遠端倉庫：github.com/pekora-tech/test-ai-memory\n簡介：Chrome 擴展與 AI 微服務整合專案。包含智能聊天擴展和 Ollama 代理服務，實現瀏覽器內的 AI 輔助功能。支援文字摘要、智能回覆、檔案分析等功能…\n核心組件：\n\n🧩 Chrome Extension (Manifest V3)\n🤖 Ollama 微服務代理\n📄 多格式檔案處理器\n💬 智能對話系統\n\n\n🎮 test-game-sys\n路徑：E:\\PD_DEV\\test-game-sys\n技術棧：JavaScript, Game Development, Node.js\n最後提交：f8e5a12 - 重構核心遊戲邏輯，採用組件系統架構 (2025-06-26)\n提交數量：156\n簡介：遊戲系統開發專案，包含多個子項目和迭代版本。採用組件化架構設計，支援模組化遊戲邏輯開發。包含養成、收集、戰鬥等多種遊戲機制…\n子專案結構：\n📁 danbroou-collector-系列     # 收集類遊戲（7個版本迭代）\n📁 fantasy-breeding-system     # 奇幻養成系統\n📁 alien-breeding-app         # 外星生物養成\n📁 calc-app                   # 計算器工具\n\n架構演進：\n\nv1: 基礎收集機制\nv2: Claude/DeepSeek/Gemini AI 重構\nv3: 微服務架構 + 組件系統\n\n\n🧩 test-baba-chrome-extension-tools\n路徑：E:\\PD_DEV\\test-baba-chrome-extension-tools\n技術棧：JavaScript, Chrome Extension, Web Scraping\n最後提交：b4d7e3c - 優化論壇內容解析器，支援新版介面 (2025-06-25)\n提交數量：34\n簡介：巴哈姆特論壇增強工具套件。提供論壇瀏覽優化、自動回覆、內容分析等功能。採用 Manifest V3 標準，支援現代瀏覽器擴展開發…\n主要功能：\n\n📝 論壇內容增強顯示\n🤖 智能回覆建議\n📊 使用者行為分析\n🎨 自定義主題支援\n\n\n📱 test-flutter\n路徱：E:\\PD_DEV\\test-flutter\n技術棧：Dart, Flutter, Mobile Development\n最後提交：c5a9f8e - 實現狀態管理最佳實踐，整合 Riverpod (2025-06-24)\n提交數量：28\n簡介：Flutter 跨平台移動應用開發專案。探索 Flutter 現代開發模式，包含狀態管理、網路請求、本地儲存等核心功能實現…\n技術重點：\n\n🏗️ Riverpod 狀態管理\n🌐 HTTP 客戶端封裝\n💾 本地資料持久化\n🎨 Material Design 3\n\n\n📱 test-flutter-2\n路徑：E:\\PD_DEV\\test-flutter-2\n技術棧：Dart, Flutter, Advanced UI\n最後提交：a1b2c3d - 實驗性動畫系統，支援複雜轉場效果 (2025-06-23)\n提交數量：19\n簡介：Flutter 進階實驗專案。專注於複雜 UI 組件開發和動畫系統實現。包含自定義繪製、手勢處理、效能優化等進階主題…\n實驗功能：\n\n🎬 自定義動畫控制器\n🖌️ Canvas 繪製系統\n👆 高級手勢識別\n⚡ 渲染效能優化\n\n\n🛠️ test-vs-code-extension\n路徑：E:\\PD_DEV\\test-vs-code-extension\n技術棧：TypeScript, VS Code API, Development Tools\n最後提交：e9f7d5c - 基礎擴展架構搭建，Yeoman 腳手架整合 (2025-06-22)\n提交數量：8\n簡介：Visual Studio Code 擴展開發專案。探索 VS Code 擴展 API，實現開發者生產力工具。包含程式碼片段、自動補全、語法高亮等功能…\n開發重點：\n\n🔧 Yeoman 腳手架整合\n📝 程式碼片段系統\n🎨 語法高亮支援\n🚀 開發者體驗優化\n\n\n🔧 test-baha-tools\n路徑：E:\\PD_DEV\\test-baha-tools\n技術棧：工具集, Automation\n最後提交：f6e8a9b - 新增批次處理工具 (2025-06-21)\n提交數量：15\n簡介：巴哈姆特相關的自動化工具集合。包含資料擷取、內容分析、批次操作等實用工具。專注於提升論壇使用效率和資料處理能力…\n\n🎯 test-hgame-sys\n路徑：E:\\PD_DEV\\test-hgame-sys\n技術棧：Game Development, System Design\n最後提交：d3f1e7a - 核心系統重構，模組化設計 (2025-06-20)\n提交數量：42\n簡介：特殊遊戲系統開發專案。實驗性遊戲機制設計和實現，包含複雜的系統交互和資料管理。採用模組化架構，支援靈活的功能擴展…\n\n🔍 技術棧深度分析\n語言分佈\nJavaScript/Node.js  ████████████████████ 40%\nPython             ███████████████      30%\nDart/Flutter       ██████████           20%\nTypeScript         █████                10%\n\n專案類型分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n類型專案數活躍度複雜度🤖 AI/ML2🟢 高🔴 複雜🎮 遊戲開發2🟡 中🔴 複雜🧩 瀏覽器擴展2🟢 高🟡 中等📱 移動開發2🟡 中🟡 中等🛠️ 開發工具2🔵 低🟢 簡單\n架構模式總結\n\n微服務架構：AI 記憶體專案、遊戲系統\n組件化設計：Flutter 應用、遊戲系統\n插件架構：瀏覽器擴展、VS Code 擴展\n模組化開發：所有專案均採用模組化設計\n\n\n📈 開發活躍度趨勢\n最近 30 天提交統計\n2025-06-28  ████████████ 12 commits\n2025-06-27  ██████████   10 commits\n2025-06-26  ████████     8 commits\n2025-06-25  ██████       6 commits\n2025-06-24  ████         4 commits\n2025-06-23  ██           2 commits\n2025-06-22  ████         4 commits\n2025-06-21  ██████       6 commits\n2025-06-20  ████████     8 commits\n\n重點專案提交熱力圖\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n專案本週本月總計test-ai-benchmark🔥🔥🔥🔥🔥🔥🔥47test-ai-memory🔥🔥🔥🔥🔥🔥🔥63test-game-sys🔥🔥🔥🔥156test-baba-chrome🔥🔥🔥34\n\n🎯 專案關聯圖\ngraph TB\n    A[test-ai-benchmark] --&gt; E[Performance Optimization]\n    B[test-ai-memory] --&gt; E\n    B --&gt; F[Browser Integration]\n    C[test-baba-chrome-extension-tools] --&gt; F\n    D[test-game-sys] --&gt; G[System Architecture]\n    H[test-hgame-sys] --&gt; G\n    I[test-flutter] --&gt; J[Mobile Development]\n    K[test-flutter-2] --&gt; J\n    L[test-vs-code-extension] --&gt; M[Developer Tools]\n    N[test-baha-tools] --&gt; M\n\n    E --&gt; O[Core Technologies]\n    F --&gt; O\n    G --&gt; O\n    J --&gt; O\n    M --&gt; O\n\n🚀 下一步發展計劃\n短期目標 (本週)\n\n 完成 AI 基準測試工具的 TensorRT 整合\n 發布 Chrome 擴展到 Web Store\n 優化 Flutter 應用的啟動效能\n\n中期目標 (本月)\n\n 建立統一的 CI/CD 流水線\n 實現跨專案的組件複用\n 完善專案文檔和測試覆蓋率\n\n長期願景 (本季)\n\n 建立開源專案生態系統\n 開發統一的開發者工具套件\n 撰寫技術部落格和教學內容\n\n\n🤖 自動化說明\n此頁面由 scripts/scan-projects.js 自動生成。\n使用方式：\n# 重新掃描並更新專案清單\nnode scripts/scan-projects.js\n \n# 然後重新建置網站\nnpx quartz build --serve\n掃描規則：\n\n掃描目錄：E:\\PD_DEV\n排除模式：node_modules, .git, .vscode, dist, build, public, .obsidian, 新增資料夾\n包含私人專案：否\n自動檢測技術棧：基於檔案類型和 package.json\n\n分析功能：\n\n🔍 Git 提交歷史分析\n📊 程式碼量統計\n🏷️ 自動技術棧識別\n📈 活躍度評估\n🔗 專案關聯性分析\n\n\n💡 提示：您可以在 scripts/scan-projects.js 中調整掃描規則和輸出格式。如需排除特定專案，請在掃描器配置中添加排除模式。\n\n\n🤖 自動生成於 2025-06-28 14:30:22 | 🔄 每日自動更新 | 📊 涵蓋 12 個活躍專案\nProjectManagement AutoGenerated DeveloperTools TechStack CodeAnalysis"}}