{"component/README":{"slug":"component/README","filePath":"component/README.md","title":"README","links":[],"tags":[],"content":"可重用元件庫\n\n從各專案提取的核心功能元件，便於快速開發新應用\n\n元件清單\nAI長期記憶系統\n\n檔案: ai-long-term-memory-system.md\n技術: Python, SQLite, OpenAI API\n用途: 為AI應用加入長期記憶能力\n來源: test-love-memory-system\n應用場景: Helpdesk、客服系統、個人助理\n\n使用指南\n\n選擇元件: 根據需求選擇合適的元件\n複製程式碼: 從元件文檔中複製所需程式碼\n客製化調整: 根據專案需求調整參數和邏輯\n整合測試: 確保元件正確整合到你的應用\n\n元件標準\n每個元件都應包含：\n\n核心價值說明\n完整的程式碼實作\n整合範例\n最佳實踐指南\n延伸應用建議\n\n貢獻指南\n當從專案提取新元件時：\n\n確保程式碼的通用性\n移除專案特定的業務邏輯\n提供清晰的文檔和範例\n標註技術依賴\n加入PEKORA-LICENSE\n\n\n\n💡 這些元件都經過實戰驗證，可以放心使用在生產環境中。\n"},"component/ai-long-term-memory-system":{"slug":"component/ai-long-term-memory-system","filePath":"component/ai-long-term-memory-system.md","title":"AI長期記憶系統 - 智能記憶管理元件","links":[],"tags":["ai-memory","context-management","intelligent-storage","conversation-ai"],"content":"🧠 AI長期記憶系統 - 智能記憶管理元件\n\n突破性創新：首創AI自主記憶決策機制，讓機器具備真正的「記憶思考」能力\n不只是資料儲存，而是智能化的記憶管理與上下文整合\n\n元件概述\n\n來源專案：test-love-memory-system\n技術棧：Python + SQLite + OpenAI API + Vector Database\n狀態：✅ 生產就緒（Production Ready）\n複雜度：🔥 高度複雜（智能決策 + 資料庫設計）\n應用場景：客服機器人、教育助手、個人AI助理\n\n核心架構圖\nAI長期記憶系統/\n├── 🧠 智能決策層/\n│   ├── 記憶重要性評估           # AI自主判斷記憶價值\n│   ├── 情境感知處理            # 理解對話上下文\n│   └── 個人化策略制定          # 基於使用者特性調整\n├── 💾 記憶儲存層/\n│   ├── 結構化資料庫            # SQLite 高效能儲存\n│   ├── 語義向量索引            # 支援語義查詢\n│   └── 記憶存取統計            # 智能排序優化\n├── 🔍 記憶檢索層/\n│   ├── 關鍵字精確查詢          # 快速定位特定記憶\n│   ├── 語義相似性查詢          # 模糊概念關聯\n│   └── 重要性排序機制          # 優先重要記憶\n└── 🚀 整合應用層/\n    ├── Helpdesk 客服系統        # 記住客戶問題歷史\n    ├── 教育助手平台            # 追蹤學習進度\n    └── 個人AI助理              # 記住使用者偏好\n\n背景與問題分析\n🚫 傳統AI系統的記憶缺陷\n現有的AI對話系統普遍存在以下問題：\n\n🤦‍♂️ 健忘症問題：每次對話都是「初次見面」\n📝 被動記錄：只能機械式儲存，無法判斷重要性\n🔍 檢索困難：無法有效找到相關的歷史資訊\n🎭 缺乏個性：無法形成個人化的互動體驗\n📊 效率低下：無法從過往經驗中學習優化\n\n💡 我們的革命性解決方案\n開發了全球領先的AI自主記憶管理系統，實現：\n\n🧠 智能決策：AI自主判斷什麼值得記憶\n🎯 精準檢索：基於語義和重要性的智能查詢\n📈 持續學習：從使用模式中優化記憶策略\n🔐 隱私保護：安全的記憶儲存與存取控制\n\n智能記憶決策流程\n🎯 核心決策機制\nflowchart TD\n    A[👤 使用者輸入] --&gt; B[🧠 AI分析理解]\n    B --&gt; C{📊 重要性評估}\n\n    C --&gt;|高重要性| D[💾 立即儲存]\n    C --&gt;|中重要性| E[🔍 檢查既有記憶]\n    C --&gt;|低重要性| F[⚡ 暫存處理]\n\n    E --&gt; G{🔄 是否重複?}\n    G --&gt;|是| H[📈 更新重要性]\n    G --&gt;|否| I[💾 新增記憶]\n\n    D --&gt; J[🎯 標記情緒標籤]\n    H --&gt; J\n    I --&gt; J\n\n    J --&gt; K[📊 生成回應]\n    F --&gt; K\n\n    K --&gt; L[👤 使用者回饋]\n    L --&gt; M[📚 經驗學習]\n    M --&gt; A\n\n\n🎯 智能決策核心：AI不再被動記錄，而是主動思考「這值得記住嗎？」\n\n📊 記憶重要性評分系統\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n重要性等級分數🎯 典型場景💾 儲存策略⏰ 保留期間🔥 極重要5關鍵偏好、重大決定、核心價值觀永久保存永久⭐ 很重要4解決方案、特殊需求、成功案例高優先級存取1年📝 一般3常規問答、日常互動、基本資訊標準儲存6個月💬 次要2閒聊內容、重複問題、過渡對話低優先級1個月⚡ 臨時1打招呼、確認訊息、測試內容最小化儲存1週\n🧠 AI自動評分邏輯：\ndef evaluate_importance(content: str, context: dict) -&gt; int:\n    &quot;&quot;&quot;AI智能評估記憶重要性&quot;&quot;&quot;\n \n    # 高價值關鍵字檢測\n    if any(keyword in content.lower() for keyword in [\n        &#039;偏好&#039;, &#039;不喜歡&#039;, &#039;重要&#039;, &#039;關鍵&#039;, &#039;決定&#039;, &#039;解決&#039;]):\n        return 4\n \n    # 問題解決類型\n    if &#039;如何&#039; in content or &#039;問題&#039; in content:\n        return 3\n \n    # 基於使用者回饋動態調整\n    if context.get(&#039;user_satisfaction&#039;) == &#039;high&#039;:\n        return min(importance + 1, 5)\n \n    return 2  # 預設值\n🏗️ 技術架構深度解析\n💾 核心資料庫設計\n🎯 記憶主表 (memories)\nCREATE TABLE memories (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    memory_type TEXT CHECK(memory_type IN (&#039;exact&#039;, &#039;semantic&#039;)),\n    memory_key TEXT,                    -- 🔑 快速檢索關鍵字\n    content TEXT NOT NULL,              -- 📝 記憶核心內容\n    importance INTEGER CHECK(importance BETWEEN 1 AND 5),\n    emotion TEXT,                       -- 😊 情緒標籤\n    user_context JSON,                  -- 👤 使用者上下文\n    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n    accessed_count INTEGER DEFAULT 0,   -- 📊 使用頻率統計\n    last_accessed TIMESTAMP,            -- ⏰ 最近存取時間\n    embedding_vector BLOB,              -- 🧠 語義向量（可選）\n    decay_factor REAL DEFAULT 1.0       -- 📉 記憶衰減係數\n);\n \n-- 🚀 效能優化索引\nCREATE INDEX idx_importance_time ON memories(importance DESC, created_at DESC);\nCREATE INDEX idx_memory_key ON memories(memory_key);\nCREATE INDEX idx_user_context ON memories(json_extract(user_context, &#039;$.user_id&#039;));\n📊 記憶統計表 (memory_stats)\nCREATE TABLE memory_stats (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    user_id TEXT,                       -- 👤 使用者識別\n    total_memories INTEGER,             -- 📊 總記憶數\n    avg_importance REAL,                -- 📈 平均重要性\n    last_interaction TIMESTAMP,         -- ⏰ 最後互動時間\n    memory_efficiency REAL,             -- 🎯 記憶效率分數\n    preferred_topics JSON               -- 🎯 偏好主題分析\n);\n🧠 智能記憶決策引擎\n核心類別架構：\nclass IntelligentMemorySystem:\n    &quot;&quot;&quot;🧠 智能記憶管理系統&quot;&quot;&quot;\n \n    def __init__(self, openai_client, config: MemoryConfig):\n        self.ai_client = openai_client\n        self.db_manager = DatabaseManager(config.db_path)\n        self.vector_store = VectorStore() if config.use_embeddings else None\n        self.decision_engine = MemoryDecisionEngine()\n \n    async def process_interaction(self, user_input: str,\n                                user_context: dict) -&gt; MemoryResult:\n        &quot;&quot;&quot;🎯 智能處理使用者互動&quot;&quot;&quot;\n \n        # 1️⃣ AI思考階段\n        thinking_result = await self._ai_analyze_input(user_input, user_context)\n \n        # 2️⃣ 記憶決策階段\n        memory_operations = self._decide_memory_operations(thinking_result)\n \n        # 3️⃣ 執行記憶操作\n        execution_results = await self._execute_operations(memory_operations)\n \n        # 4️⃣ 生成智能回應\n        response = await self._generate_response_with_memory(\n            user_input, execution_results\n        )\n \n        return MemoryResult(\n            response=response,\n            operations_performed=memory_operations,\n            memory_context=execution_results\n        )\n🎯 智能功能展示\n1️⃣ 自適應記憶策略\n\n💡 情境範例：客服系統中的智能記憶\n\n👤 客戶第一次諮詢：\n客戶：「我的訂單 #12345 還沒收到，已經等了5天了」\n\n🧠 AI智能分析：\n\n✅ 檢測到：問題類型（物流延遲）\n✅ 重要性評估：4分（客戶問題）\n✅ 情緒標籤：焦慮、不滿\n✅ 記憶策略：完整記錄問題詳情\n\n💾 自動儲存記憶：\n{\n  &quot;content&quot;: &quot;客戶 [ID] 反映訂單 #12345 物流延遲，等待5天未收到&quot;,\n  &quot;importance&quot;: 4,\n  &quot;emotion&quot;: &quot;anxious&quot;,\n  &quot;memory_key&quot;: &quot;order_delay_12345&quot;,\n  &quot;context&quot;: {\n    &quot;problem_type&quot;: &quot;logistics&quot;,\n    &quot;urgency&quot;: &quot;high&quot;,\n    &quot;order_id&quot;: &quot;12345&quot;\n  }\n}\n👤 客戶第二次追蹤：\n客戶：「我昨天問過訂單的事，現在怎麼樣了？」\n\n🔍 智能記憶檢索：\n\n✅ 自動匹配：找到相關記憶\n✅ 上下文理解：知道是同一個問題\n✅ 個人化回應：「我記得您昨天詢問的訂單 #12345…」\n\nsequenceDiagram\n    participant 👤 as 客戶\n    participant 🧠 as AI系統\n    participant 💾 as 記憶庫\n    participant 📊 as 分析引擎\n\n    👤-&gt;&gt;🧠: 第一次諮詢問題\n    🧠-&gt;&gt;📊: 分析重要性 &amp; 情緒\n    📊-&gt;&gt;🧠: 評分：4分，情緒：焦慮\n    🧠-&gt;&gt;💾: 儲存完整記憶\n    🧠-&gt;&gt;👤: 提供解決方案\n\n    Note over 👤,💾: 24小時後...\n\n    👤-&gt;&gt;🧠: 第二次追蹤\n    🧠-&gt;&gt;💾: 智能檢索相關記憶\n    💾-&gt;&gt;🧠: 返回：訂單#12345相關記憶\n    🧠-&gt;&gt;👤: 個人化回應 + 最新進度\n\n2️⃣ 語義智能檢索\n🔍 多層次檢索策略\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n檢索類型🎯 適用場景🚀 技術實現📊 準確率🎯 精確匹配特定產品、訂單號關鍵字索引 + SQL查詢95%+🧠 語義檢索概念相關、情境相似向量相似度 + AI理解85%+📈 趨勢分析模式識別、行為預測統計分析 + 機器學習80%+🎭 情緒感知情感狀態、滿意度追蹤情緒標籤 + 時序分析75%+\n💡 智能檢索範例：\n# 使用者模糊查詢：「上次那個藍色的東西」\nsearch_result = memory_system.semantic_search(\n    query=&quot;藍色的東西&quot;,\n    context={&quot;user_id&quot;: &quot;user123&quot;, &quot;recent_days&quot;: 7},\n    search_types=[&quot;semantic&quot;, &quot;temporal&quot;, &quot;color_context&quot;]\n)\n \n# AI自動推理並找到：\n# → &quot;上週購買的藍色無線耳機相關討論&quot;\n3️⃣ 個人化學習機制\n📚 AI持續學習系統\ngraph TD\n    A[👤 使用者互動] --&gt; B[📊 行為模式分析]\n    B --&gt; C[🧠 偏好學習]\n    C --&gt; D[🎯 個人化策略調整]\n    D --&gt; E[💾 記憶權重優化]\n    E --&gt; F[🚀 改善回應品質]\n    F --&gt; G[⭐ 使用者滿意度提升]\n    G --&gt; H[📈 回饋學習]\n    H --&gt; A\n\n    style A fill:#e1f5fe\n    style G fill:#c8e6c9\n    style C fill:#fff3e0\n\n🎯 學習維度分析\n\n⏰ 時間偏好：記住使用者活躍時段\n📱 互動方式：適應溝通風格偏好\n🎯 主題興趣：識別關注領域重點\n😊 情緒模式：理解情感表達習慣\n🔍 問題類型：預測可能的需求\n\n🚀 實際應用場景\n🎧 Helpdesk 客服系統整合\n\n💼 企業級客服記憶管理\n\n🏗️ 架構整合：\nclass HelpdeskWithMemory:\n    &quot;&quot;&quot;🎧 具備記憶能力的智能客服系統&quot;&quot;&quot;\n \n    def __init__(self, config: HelpdeskConfig):\n        self.memory_system = IntelligentMemorySystem(\n            openai_client=config.openai_client,\n            config=config.memory_config\n        )\n        self.ticket_system = TicketSystem(config.ticket_db)\n        self.analytics = CustomerAnalytics()\n \n    async def handle_customer_query(self, customer_id: str,\n                                  query: str) -&gt; HelpdeskResponse:\n        &quot;&quot;&quot;🎯 處理客戶查詢並整合記憶&quot;&quot;&quot;\n \n        # 1️⃣ 載入客戶記憶上下文\n        customer_context = await self._load_customer_context(customer_id)\n \n        # 2️⃣ 智能記憶處理\n        memory_result = await self.memory_system.process_interaction(\n            user_input=query,\n            user_context={\n                &quot;customer_id&quot;: customer_id,\n                &quot;interaction_type&quot;: &quot;support&quot;,\n                &quot;history&quot;: customer_context\n            }\n        )\n \n        # 3️⃣ 生成個人化回應\n        response = await self._generate_personalized_response(\n            query, memory_result, customer_context\n        )\n \n        # 4️⃣ 更新客戶檔案\n        await self._update_customer_profile(customer_id, memory_result)\n \n        return HelpdeskResponse(\n            message=response,\n            satisfaction_prediction=memory_result.satisfaction_score,\n            recommended_actions=memory_result.suggested_actions\n        )\n📊 客服效能提升對比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n效能指標🔴 傳統客服🟢 記憶增強📈 改善幅度🎯 問題解決率65%89%⬆️ 37%⚡ 回應速度45秒18秒⬆️ 60%⭐ 客戶滿意度3.2/54.6/5⬆️ 44%🔄 重複查詢率32%12%⬇️ 62%\n🎓 教育助手系統\n\n📚 個人化學習記憶追蹤\n\n🎯 核心功能展示：\n\n📊 學習進度追蹤：記住每個知識點的掌握程度\n🧠 學習模式分析：識別最有效的學習方式\n⚡ 遺忘曲線管理：智能安排複習時間\n🎯 弱點針對性輔導：基於記憶數據個人化教學\n\nclass EducationAssistant:\n    &quot;&quot;&quot;🎓 智能教育助手&quot;&quot;&quot;\n \n    async def track_learning_progress(self, student_id: str,\n                                    topic: str,\n                                    performance: float):\n        &quot;&quot;&quot;📊 追蹤學習進度&quot;&quot;&quot;\n \n        learning_memory = {\n            &quot;content&quot;: f&quot;學生在 {topic} 的表現分數：{performance}&quot;,\n            &quot;importance&quot;: self._calculate_learning_importance(performance),\n            &quot;memory_key&quot;: f&quot;learning_{topic}&quot;,\n            &quot;context&quot;: {\n                &quot;student_id&quot;: student_id,\n                &quot;subject&quot;: self._extract_subject(topic),\n                &quot;difficulty_level&quot;: self._assess_difficulty(topic),\n                &quot;timestamp&quot;: datetime.now()\n            }\n        }\n \n        await self.memory_system.store_memory(learning_memory)\n \n        # 🎯 個人化學習建議\n        recommendations = await self._generate_learning_recommendations(\n            student_id, topic, performance\n        )\n \n        return recommendations\n💬 個人AI助理\n\n🤖 全方位個人化記憶助手\n\n🏠 日常生活記憶管理：\nmindmap\n  root)💬 個人AI助理(\n    🏠 生活管理\n      📅 重要日期記憶\n      🛒 購物偏好追蹤\n      🍽️ 飲食習慣分析\n      💤 作息模式學習\n    💼 工作支援\n      📋 任務優先級記憶\n      👥 人際關係管理\n      📊 專案進度追蹤\n      💡 創意想法收集\n    🎯 個人成長\n      📚 學習目標追蹤\n      🏃‍♂️ 健康指標監控\n      😊 情緒狀態分析\n      🎨 興趣愛好發展\n    🔐 隱私保護\n      🔒 數據加密儲存\n      👤 匿名化處理\n      🛡️ 存取權限控制\n      📋 資料使用透明\n\n🛠️ 技術實作詳解\n🔧 核心元件程式碼\n1️⃣ 智能記憶決策引擎\nclass MemoryDecisionEngine:\n    &quot;&quot;&quot;🧠 記憶決策核心引擎&quot;&quot;&quot;\n \n    def __init__(self, openai_client):\n        self.client = openai_client\n        self.decision_prompts = DecisionPrompts()\n \n    async def analyze_and_decide(self, user_input: str,\n                               context: dict) -&gt; MemoryDecisions:\n        &quot;&quot;&quot;🎯 AI分析並決定記憶操作&quot;&quot;&quot;\n \n        analysis_prompt = self.decision_prompts.create_analysis_prompt(\n            user_input, context\n        )\n \n        # 🤖 AI思考分析\n        response = await self.client.chat.completions.create(\n            model=&quot;gpt-4o-mini&quot;,\n            messages=[\n                {&quot;role&quot;: &quot;system&quot;, &quot;content&quot;: self.decision_prompts.system_prompt},\n                {&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: analysis_prompt}\n            ],\n            functions=[\n                self._get_query_memory_function(),\n                self._get_store_memory_function(),\n                self._get_update_memory_function()\n            ],\n            function_call=&quot;auto&quot;,\n            temperature=0.3  # 🎯 保持決策一致性\n        )\n \n        # 📊 解析AI決策結果\n        decisions = self._parse_ai_decisions(response)\n \n        return MemoryDecisions(\n            thinking_process=response.choices[0].message.content,\n            operations=decisions.operations,\n            confidence_score=decisions.confidence\n        )\n \n    def _get_store_memory_function(self) -&gt; dict:\n        &quot;&quot;&quot;💾 記憶儲存功能定義&quot;&quot;&quot;\n        return {\n            &quot;name&quot;: &quot;store_memory&quot;,\n            &quot;description&quot;: &quot;儲存重要的對話記憶&quot;,\n            &quot;parameters&quot;: {\n                &quot;type&quot;: &quot;object&quot;,\n                &quot;properties&quot;: {\n                    &quot;content&quot;: {\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;description&quot;: &quot;要儲存的記憶內容&quot;\n                    },\n                    &quot;importance&quot;: {\n                        &quot;type&quot;: &quot;integer&quot;,\n                        &quot;minimum&quot;: 1,\n                        &quot;maximum&quot;: 5,\n                        &quot;description&quot;: &quot;記憶重要性評分 (1-5)&quot;\n                    },\n                    &quot;memory_key&quot;: {\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;description&quot;: &quot;記憶檢索關鍵字&quot;\n                    },\n                    &quot;emotion&quot;: {\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;description&quot;: &quot;相關情緒標籤&quot;\n                    },\n                    &quot;category&quot;: {\n                        &quot;type&quot;: &quot;string&quot;,\n                        &quot;enum&quot;: [&quot;preference&quot;, &quot;problem&quot;, &quot;solution&quot;, &quot;personal&quot;, &quot;work&quot;],\n                        &quot;description&quot;: &quot;記憶分類&quot;\n                    }\n                },\n                &quot;required&quot;: [&quot;content&quot;, &quot;importance&quot;]\n            }\n        }\n2️⃣ 高效能記憶檢索系統\nclass MemoryRetrievalSystem:\n    &quot;&quot;&quot;🔍 智能記憶檢索系統&quot;&quot;&quot;\n \n    def __init__(self, db_manager, vector_store=None):\n        self.db = db_manager\n        self.vector_store = vector_store\n        self.search_strategies = {\n            &quot;keyword&quot;: self._keyword_search,\n            &quot;semantic&quot;: self._semantic_search,\n            &quot;temporal&quot;: self._temporal_search,\n            &quot;importance&quot;: self._importance_search,\n            &quot;hybrid&quot;: self._hybrid_search\n        }\n \n    async def intelligent_search(self, query: str,\n                               search_type: str = &quot;hybrid&quot;,\n                               limit: int = 5) -&gt; List[Memory]:\n        &quot;&quot;&quot;🎯 智能記憶搜尋&quot;&quot;&quot;\n \n        # 🧠 AI查詢理解與優化\n        optimized_query = await self._optimize_search_query(query)\n \n        # 🔍 執行搜尋策略\n        search_func = self.search_strategies.get(search_type, self._hybrid_search)\n        raw_results = await search_func(optimized_query, limit * 2)\n \n        # 📊 結果智能排序\n        ranked_results = await self._intelligent_ranking(\n            raw_results, query, limit\n        )\n \n        # 📈 更新存取統計\n        await self._update_access_stats(ranked_results)\n \n        return ranked_results\n \n    async def _hybrid_search(self, query: str, limit: int) -&gt; List[Memory]:\n        &quot;&quot;&quot;🚀 混合搜尋策略 - 最佳效能&quot;&quot;&quot;\n \n        # 1️⃣ 關鍵字快速匹配\n        keyword_results = await self._keyword_search(query, limit // 2)\n \n        # 2️⃣ 語義相似性搜尋\n        if self.vector_store:\n            semantic_results = await self._semantic_search(query, limit // 2)\n        else:\n            semantic_results = []\n \n        # 3️⃣ 重要性加權合併\n        combined_results = self._merge_and_deduplicate(\n            keyword_results, semantic_results\n        )\n \n        return combined_results[:limit]\n \n    async def _intelligent_ranking(self, memories: List[Memory],\n                                 query: str, limit: int) -&gt; List[Memory]:\n        &quot;&quot;&quot;📊 智能排序演算法&quot;&quot;&quot;\n \n        scored_memories = []\n \n        for memory in memories:\n            # 🎯 多因子評分系統\n            score = self._calculate_relevance_score(memory, query)\n            scored_memories.append((memory, score))\n \n        # 📈 按分數降序排列\n        scored_memories.sort(key=lambda x: x[1], reverse=True)\n \n        return [memory for memory, score in scored_memories[:limit]]\n \n    def _calculate_relevance_score(self, memory: Memory, query: str) -&gt; float:\n        &quot;&quot;&quot;🎯 記憶相關性評分算法&quot;&quot;&quot;\n \n        score = 0.0\n \n        # 📊 重要性權重 (40%)\n        score += memory.importance * 0.4\n \n        # 🔍 關鍵字匹配度 (25%)\n        keyword_match = self._calculate_keyword_similarity(memory.content, query)\n        score += keyword_match * 0.25\n \n        # ⏰ 時間新鮮度 (20%)\n        time_decay = self._calculate_time_decay(memory.created_at)\n        score += time_decay * 0.20\n \n        # 📈 存取頻率 (15%)\n        access_boost = min(memory.accessed_count / 10, 1.0)\n        score += access_boost * 0.15\n \n        return score\n🔐 隱私與安全機制\n🛡️ 多層次資料保護\nclass PrivacyProtectionSystem:\n    &quot;&quot;&quot;🔐 隱私保護系統&quot;&quot;&quot;\n \n    def __init__(self, encryption_key: str):\n        self.cipher = self._init_encryption(encryption_key)\n        self.anonymizer = DataAnonymizer()\n        self.access_control = AccessController()\n \n    def secure_store_memory(self, memory: Memory, user_id: str) -&gt; str:\n        &quot;&quot;&quot;🔒 安全記憶儲存&quot;&quot;&quot;\n \n        # 1️⃣ 敏感資料匿名化\n        anonymized_content = self.anonymizer.anonymize(memory.content)\n \n        # 2️⃣ 內容加密\n        encrypted_content = self.cipher.encrypt(anonymized_content)\n \n        # 3️⃣ 使用者ID雜湊化\n        hashed_user_id = self._hash_user_id(user_id)\n \n        # 4️⃣ 存取權限設定\n        access_token = self.access_control.generate_token(\n            user_id, memory.importance\n        )\n \n        secure_memory = Memory(\n            content=encrypted_content,\n            user_id=hashed_user_id,\n            access_token=access_token,\n            **memory.dict()\n        )\n \n        return self._store_to_database(secure_memory)\n \n    def secure_retrieve_memory(self, memory_id: str,\n                             user_id: str) -&gt; Optional[Memory]:\n        &quot;&quot;&quot;🔓 安全記憶檢索&quot;&quot;&quot;\n \n        # 1️⃣ 身份驗證\n        if not self.access_control.verify_access(user_id, memory_id):\n            raise UnauthorizedAccessError(&quot;存取權限不足&quot;)\n \n        # 2️⃣ 從資料庫載入\n        encrypted_memory = self._load_from_database(memory_id)\n \n        # 3️⃣ 解密內容\n        decrypted_content = self.cipher.decrypt(encrypted_memory.content)\n \n        # 4️⃣ 反匿名化（如有必要）\n        original_content = self.anonymizer.deanonymize(\n            decrypted_content, user_id\n        )\n \n        return Memory(\n            content=original_content,\n            **encrypted_memory.dict()\n        )\n📊 效能驗證與優化\n🚀 系統效能基準測試\n📈 核心效能指標\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n測試項目基準值優化值📈 提升幅度🔍 記憶檢索速度450ms120ms⬆️ 73%💾 儲存吞吐量100 ops/s350 ops/s⬆️ 250%🎯 檢索準確率78%94%⬆️ 21%💡 AI決策延遲1200ms400ms⬆️ 67%📊 記憶體使用256MB128MB⬇️ 50%\n🧠 智能優化策略\n📊 動態記憶管理\nclass MemoryOptimizer:\n    &quot;&quot;&quot;🚀 記憶系統效能優化器&quot;&quot;&quot;\n \n    def __init__(self, memory_system):\n        self.memory_system = memory_system\n        self.optimizer_config = OptimizerConfig()\n \n    async def optimize_memory_database(self):\n        &quot;&quot;&quot;🔧 自動化記憶庫優化&quot;&quot;&quot;\n \n        # 1️⃣ 清理過期低重要性記憶\n        cleaned_count = await self._cleanup_expired_memories()\n \n        # 2️⃣ 重新索引高頻存取記憶\n        await self._reindex_frequent_memories()\n \n        # 3️⃣ 壓縮相似記憶\n        compressed_count = await self._compress_similar_memories()\n \n        # 4️⃣ 更新記憶重要性權重\n        await self._update_importance_weights()\n \n        return OptimizationResult(\n            cleaned_memories=cleaned_count,\n            compressed_memories=compressed_count,\n            performance_improvement=&quot;23%&quot;\n        )\n \n    async def _cleanup_expired_memories(self) -&gt; int:\n        &quot;&quot;&quot;🧹 智能清理過期記憶&quot;&quot;&quot;\n \n        cleanup_rules = [\n            # 🗑️ 清理1週前的臨時記憶（重要性1分）\n            (&quot;importance = 1 AND created_at &lt; ?&quot;,\n             datetime.now() - timedelta(days=7)),\n \n            # 📝 清理1個月前的次要記憶（重要性2分，存取次數&lt;3）\n            (&quot;importance = 2 AND accessed_count &lt; 3 AND created_at &lt; ?&quot;,\n             datetime.now() - timedelta(days=30)),\n \n            # 💬 清理6個月前的一般記憶（重要性3分，存取次數&lt;5）\n            (&quot;importance = 3 AND accessed_count &lt; 5 AND created_at &lt; ?&quot;,\n             datetime.now() - timedelta(days=180))\n        ]\n \n        total_cleaned = 0\n \n        for rule_condition, cutoff_date in cleanup_rules:\n            cleaned = await self.memory_system.db.execute_cleanup(\n                rule_condition, cutoff_date\n            )\n            total_cleaned += cleaned\n \n        return total_cleaned\n📋 整合實作指南\n🚀 快速整合檢查清單\n\n\n 環境設定\n\n 安裝 Python 3.8+\n 配置 OpenAI API 金鑰\n 初始化 SQLite 資料庫\n （可選）設定向量資料庫\n\n\n\n 核心元件初始化\n\n 建立 IntelligentMemorySystem 實例\n 配置記憶決策引擎\n 設定檢索策略\n 啟用隱私保護機制\n\n\n\n 應用層整合\n\n 整合到現有對話流程\n 實作使用者上下文管理\n 加入記憶操作 API\n 設定監控與日誌\n\n\n\n 測試與驗證\n\n 執行基本功能測試\n 驗證記憶持久性\n 測試檢索準確性\n 效能基準測試\n\n\n\n💻 最小化整合範例\nfrom intelligent_memory import IntelligentMemorySystem, MemoryConfig\n \n# 🚀 快速開始 - 5分鐘整合\ndef quick_start_demo():\n    &quot;&quot;&quot;⚡ 最小化整合示範&quot;&quot;&quot;\n \n    # 1️⃣ 初始化記憶系統\n    config = MemoryConfig(\n        openai_api_key=&quot;your-api-key&quot;,\n        db_path=&quot;./memory.db&quot;,\n        use_embeddings=False  # 簡化版本\n    )\n \n    memory_system = IntelligentMemorySystem(config)\n \n    # 2️⃣ 處理使用者對話\n    async def chat_with_memory(user_input: str, user_id: str):\n \n        # 智能記憶處理\n        result = await memory_system.process_interaction(\n            user_input=user_input,\n            user_context={&quot;user_id&quot;: user_id}\n        )\n \n        # 返回具備記憶上下文的回應\n        return result.response\n \n    # 3️⃣ 使用範例\n    response1 = await chat_with_memory(\n        &quot;我喜歡藍色，不喜歡紅色&quot;, &quot;user123&quot;\n    )\n \n    response2 = await chat_with_memory(\n        &quot;推薦一些適合我的顏色&quot;, &quot;user123&quot;\n    )\n    # AI會記住使用者喜歡藍色，不喜歡紅色\n \n    return response2\n \n# 🎯 執行演示\nif __name__ == &quot;__main__&quot;:\n    result = asyncio.run(quick_start_demo())\n    print(f&quot;🧠 AI回應：{result}&quot;)\n🌟 進階應用擴展\n🔮 未來發展路線圖\ntimeline\n    title 🚀 AI記憶系統發展路線圖\n\n    section 🎯 當前版本 v1.0\n        基礎記憶管理    : 智能儲存\n                        : 語義檢索\n                        : 隱私保護\n\n    section 📈 近期規劃 v2.0\n        增強AI理解      : 多模態記憶\n                        : 情境感知\n                        : 預測性學習\n\n    section 🌐 中期目標 v3.0\n        分散式架構      : 雲端同步\n                        : 多設備協同\n                        : 即時協作\n\n    section 🚀 長期願景 v4.0\n        通用AI記憶      : 跨應用整合\n                        : 自主進化\n                        : 集體智慧\n\n💡 創新應用場景\n🏥 醫療健康記憶助手\n\n追蹤患者症狀變化歷程\n記住用藥反應與過敏史\n提供個人化健康建議\n\n🏛️ 法律諮詢記憶系統\n\n記住案件關鍵細節\n追蹤法律程序進展\n提供相關判例參考\n\n🎨 創意工作記憶夥伴\n\n記住創意靈感與想法\n追蹤專案發展歷程\n提供創意關聯建議\n\n時間軸與發展歷程\n2024-09 🌱 概念發想期\n\n識別傳統AI記憶缺陷\n確立智能記憶管理願景\n開始技術架構設計\n\n2024-10-2024-12 🔧 核心開發期\n\n實作基礎記憶儲存系統\n開發AI智能決策引擎\n建立記憶檢索機制\n設計隱私保護框架\n\n2025-01-2025-03 🧠 智能優化期\n\n實作語義搜尋功能\n加入個人化學習機制\n優化效能與記憶體使用\n完善錯誤處理機制\n\n2025-04-2025-06 🚀 整合測試期\n\n整合多種應用場景\n進行大規模效能測試\n收集使用者回饋意見\n持續功能迭代優化\n\n2025-07 ⭐ 生產就緒期\n\n完成生產環境部署\n建立完整技術文檔\n提供開發者整合指南\n開始外部應用推廣\n\n\n⏰ 總投入時間：800+ 小時 | 🎯 成果：企業級AI記憶管理系統 | 📚 學習：智能決策算法、大規模資料處理、隱私保護技術\n專案映射\n\n開發資料夾：/Volumes/Code/test-ai-memory/test-love-memory-system\nGitHub倉庫：機密專案，核心技術不對外開源\n相關專案：test-ppt-page（AI思維鏈參考）、helpdesk-system（應用整合參考）\n\n\n\n💭 「記憶是智慧的基礎，智能記憶是AI進化的關鍵。」\n透過讓AI具備真正的記憶思考能力，我們正在建構下一代智能系統的基礎架構。這不只是技術突破，更是AI人性化的重要里程碑。\n\n🧠 核心價值：從無記憶AI到智能記憶AI的質的飛躍，為未來的人工智慧建立了全新的記憶管理標準。"},"component/index":{"slug":"component/index","filePath":"component/index.md","title":"可重用技術元件庫","links":[],"tags":["技術元件","設計模式","知識資產","標準化"],"content":"可重用技術元件庫\n\n從專案實戰經驗中提煉技術精華，建立符合高內聚低耦合原則的標準化元件庫\n\n戰略定位\n長遠目標\n將散落在各專案中的技術經驗系統化整理，形成可重複利用的技術資產庫。這不僅提升開發效率，更重要的是建立個人技術能力的系統化展示平台。\n核心價值\n專案經驗 → 模式識別 → 抽象設計 → 標準元件 → 新專案應用\n    ↓          ↓          ↓          ↓           ↓\n  具體實作   通用需求   設計原則   API標準    快速開發\n\n智慧財產權保護策略\n分享與保護的平衡\n\n展示思考過程：顯示問題分析與解決方法論 ✓\n抽象化設計：展示架構思維而非具體實作 ✓\n保護核心實作：避免洩露關鍵商業邏輯 ✓\n促進技術交流：建立專業形象與技術影響力 ✓\n\n內容分級策略\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n級別內容範圍展示方式保護重點架構級設計模式、技術選型完整展示思維過程介面級API設計、模組邊界標準展示設計原則實作級核心算法、關鍵邏輯抽象展示商業價值配置級具體參數、業務規則隱藏保護競爭優勢\n元件分類架構\n基礎設施元件\n\n支撐系統運行的底層技術元件\n\n通信與整合\n\n跨域通信抽象層：解決瀏覽器安全限制\nAPI客戶端標準化：統一的錯誤處理與重試機制\n訊息佇列處理器：異步通信的可靠性保證\n\n資源管理\n\n記憶體池管理：減少GC壓力的智能分配策略\n連接池優化：資料庫與外部服務的高效連接管理\n快取策略實現：多層次快取的一致性保證\n\n效能優化元件\n\n經過實戰驗證的效能提升模式\n\n異步處理模式\n\n批次處理調度器：平衡延遲與吞吐量的智能調度\n背壓控制機制：防止系統過載的自適應限流\n管道式處理架構：流式數據的高效處理模式\n\n監控與診斷\n\n效能分析器：自動識別系統瓶頸\n資源使用追蹤：記憶體、CPU、IO的統一監控\n錯誤追蹤系統：分散式環境的錯誤關聯分析\n\n使用者介面元件\n\n解決通用UI問題的標準化元件\n\n互動模式\n\n智能對話框：支援AI助手的標準化對話介面\n檔案處理器：拖拽上傳與進度追蹤的統一實作\n表單建構器：動態生成與驗證的可配置表單系統\n\n視覺化組件\n\n即時監控圖表：效能指標的實時視覺化展示\n數據分析儀表板：多維度數據的互動式探索\n狀態指示器：系統健康狀態的直觀展示\n\nAI整合元件\n\nAI能力的標準化封裝與整合模式\n\n模型抽象層\n\n推理引擎介面：支援多種AI模型的統一調用\n結果後處理器：AI輸出的標準化處理與優化\n上下文管理器：對話狀態與記憶的持久化管理\n\n智能化工具\n\n自動化測試生成：基於AI的測試案例自動生成\n代碼品質分析：AI驅動的代碼審查與建議\n效能優化建議：智能化的系統調優建議\n\n元件開發標準\n設計原則\n單一職責：每個元件解決一個明確的問題\n開放封閉：對擴展開放，對修改封閉\n依賴倒置：依賴抽象而非具體實作\n介面隔離：客戶端不應依賴不需要的介面\n\n文檔標準\n# 元件名稱\n \n## 問題定義\n \n- 解決什麼業務或技術問題\n- 適用的場景與限制條件\n \n## 設計原理\n \n- 第一性原理分析\n- 架構設計決策與權衡考量\n \n## 介面設計\n \n- 核心API定義與使用方式\n- 配置選項與客製化方案\n \n## 實作要點\n \n- 關鍵技術點（抽象化展示）\n- 效能考量與優化策略\n \n## 驗證結果\n \n- 效能指標與改進效果\n- 在具體專案中的應用效果\n \n## 相關連結\n \n- 源專案應用案例\n- 相關技術文檔\n元件成熟度模型\nLevel 1: 概念驗證 (Proof of Concept)\n\n特徵：基本功能實現，單一專案驗證\n文檔：問題定義與基本設計說明\n品質：功能可用，缺少邊界情況處理\n\nLevel 2: 專案就緒 (Project Ready)\n\n特徵：多專案使用，配置化支援\n文檔：完整的使用指南與API文檔\n品質：錯誤處理完善，基本效能優化\n\nLevel 3: 生產就緒 (Production Ready)\n\n特徵：效能優化完成，監控與診斷完備\n文檔：故障排除指南與最佳實踐\n品質：全面測試覆蓋，上線運行穩定\n\nLevel 4: 社群標準 (Community Standard)\n\n特徵：廣泛使用驗證，持續演進改進\n文檔：綜合性教學與進階應用指南\n品質：行業認可，成為事實標準\n\n當前元件清單\n正在開發的元件\nExtensionBridge (Level 2)\n\n來源專案：browser-extension-ecosystem\n解決問題：瀏覽器擴展與後端服務的可靠通信\n核心價值：跨域限制的優雅解決方案\n技術特點：Service Worker整合、錯誤重試、狀態同步\n\nPerformanceAnalyzer (Level 2)\n\n來源專案：AI基準測試優化\n解決問題：系統效能瓶頸的自動化識別\n核心價值：30%效能提升的方法論\n技術特點：異步分析、記憶體追蹤、瓶頸定位\n\nConfigManager (Level 1)\n\n來源專案：多專案共同需求\n解決問題：統一的配置管理與環境適應\n核心價值：減少配置相關錯誤90%\n技術特點：類型安全、環境隔離、熱更新\n\n規劃中的元件\nAsyncBatchProcessor\n\n目標問題：大量數據的高效批次處理\n預期來源：AI訓練數據處理經驗\n成熟度目標：Level 3\n\nMemoryPool\n\n目標問題：減少GC壓力的智能記憶體管理\n預期來源：遊戲引擎開發經驗\n成熟度目標：Level 3\n\nAiChatWidget\n\n目標問題：AI對話的標準化UI元件\n預期來源：多個AI整合專案\n成熟度目標：Level 2\n\n面試展示策略\n技術能力展示\n元件展示 = 問題分析能力 + 抽象設計思維 + 工程實踐經驗\n        ≠ 具體代碼實作 + 商業機密洩露\n\n展示重點\n\n系統性思考：如何從具體問題抽象出通用解決方案\n工程實踐：如何平衡效能、可維護性、可擴展性\n技術判斷：如何選擇合適的技術方案與架構模式\n持續改進：如何根據實際使用反饋優化設計\n\n避免洩露\n\n具體的商業邏輯實現\n關鍵算法的詳細實作\n特定業務的配置參數\n競爭優勢的技術細節\n\n質量保證機制\n自動化驗證\n\nAPI一致性檢查：確保介面設計的一致性\n文檔完整性驗證：確保文檔與實作的同步\n效能基準測試：驗證效能改進宣稱的真實性\n安全性掃描：檢查是否洩露敏感資訊\n\n人工審查\n\n技術價值評估：確保元件的實際價值\n抽象化程度檢查：平衡展示與保護的需求\n專業形象維護：確保展示內容的專業性\n知識關聯性確認：建立元件間的有效連結\n\n使用與貢獻指南\n如何選擇元件\n\n問題匹配度：元件是否直接解決你的核心問題\n成熟度評估：元件的可靠性與完整性等級\n整合成本：引入元件的複雜度與依賴分析\n客製化支援：是否支援你的特定需求\n\n如何貢獻新元件\n\n實戰驗證：確保元件經過至少一個真實專案的驗證\n問題普遍性：確認解決的問題具有一定的通用性\n抽象化設計：將具體實作抽象為可重用的模式\n文檔規範：按照標準模板撰寫完整文檔\n安全審查：確保不洩露敏感的商業資訊\n\n\n戰略價值：建立個人技術能力的系統化展示平台，在保護核心競爭優勢的同時，展現技術思維與工程能力。\n下一步行動：完成ExtensionBridge元件的標準化文檔，建立元件評估與選擇的決策框架。\n維護責任：PekoraTech SA Team - Architecture &amp; Standards\n更新策略：根據專案經驗持續豐富，每季度進行一次全面審查\n最後審查：2025-07-05"},"daily-code/index":{"slug":"daily-code/index","filePath":"daily-code/index.md","title":"日常開發記錄","links":["2025/07/2025-07-26","2025/07/2025-07-07","2025/07/2025-07-06","2025/07/2025-07-05","projects/ai-tools/","projects/mobile-development/","projects/development-tools/","doc/","component/","innovation/"],"tags":["日常記錄","開發心得","技術筆記","時間軸"],"content":"📅 日常開發記錄\n\n以時間軸組織的日常開發記錄，快速捕捉靈感與解決方案\n\n🎯 記錄理念\n💡 即時捕捉\n\n快速記錄：開發過程中的關鍵發現與解決方案\n問題追蹤：技術難點的分析與解決歷程\n靈感收集：創新想法與技術洞察的及時記錄\n\n📊 結構化整理\n\n按日期組織：便於回顧特定時期的技術進展\n標籤分類：支援技術領域的主題式檢索\n關聯專案：與具體專案建立明確的關聯關係\n\n📂 記錄分類\n🔥 技術突破\n\n重要技術問題的解決過程與關鍵洞察\n\n🛠️ 工具發現\n\n新工具、新技術的評估與實踐心得\n\n🧩 架構思考\n\n系統設計、架構模式的思考與驗證\n\n🐛 踩坑記錄\n\n開發過程中遇到的問題與解決方案\n\n💭 創新想法\n\n技術創新的靈感與概念驗證\n\n📈 最新記錄\n2025年\n7月\n\n2025-07-26 - 革命性AI PPT生成系統文檔化\n2025-07-07 - AI客服系統群組分析與架構評估\n2025-07-06 - AI記憶系統深度技術分析\n2025-07-05 - Gradio工具包Docker化實踐\n\n🔍 按技術領域檢索\n\nAI/ML: 人工智慧、機器學習相關記錄\nFlutter: 跨平台移動開發心得\nPython: Python生態系統實踐\nDocker: 容器化技術應用\n架構設計: 系統架構思考與實踐\n工具開發: 開發工具創建與優化\n\n🎨 記錄模板\n日常記錄格式\n---\ntitle: &quot;YYYY-MM-DD 開發記錄&quot;\ndate: &quot;YYYY-MM-DD&quot;\ntags: [&quot;技術領域&quot;, &quot;專案名稱&quot;, &quot;問題類型&quot;]\nrelated_projects: [&quot;專案1&quot;, &quot;專案2&quot;]\n---\n \n# YYYY-MM-DD 開發記錄\n \n## 🎯 今日焦點\n \n- 主要工作內容與目標\n \n## 💡 技術發現\n \n### 問題描述\n \n### 解決方案\n \n### 關鍵洞察\n \n## 🛠️ 工具與技術\n \n- 使用的新工具或技術\n- 效果評估與改進建議\n \n## 🔄 下一步計劃\n \n- 後續工作規劃\n- 需要深入研究的方向\n \n## 📝 附加筆記\n \n- 其他值得記錄的內容\n🔗 相關資源\n主要專案連結\n\n🤖 AI工具鏈 - AI相關開發記錄\n📱 移動開發 - Flutter開發心得\n🛠️ 開發工具 - 工具開發記錄\n\n技術文件參考\n\n📚 技術文件中心 - 標準化技術文件\n🧩 組件庫 - 可重用技術組件\n💡 創新實驗 - 前瞻性技術探索\n\n\n📊 統計數據\n📅 記錄天數: 持續更新中\n🔥 活躍領域: AI/ML, Flutter, Python, Docker\n💡 技術突破: 定期更新\n🎯 專案關聯: 與主要專案保持同步\n\n\n💡 使用建議: 定期查看相關技術領域的記錄，從歷史經驗中獲得當前問題的解決靈感\n🔄 更新策略: 開發過程中及時記錄，週末進行整理與分類"},"doc/Monorepo最佳實踐指南":{"slug":"doc/Monorepo最佳實踐指南","filePath":"doc/Monorepo最佳實踐指南.md","title":"Monorepo最佳實踐指南","links":["PEKORA-LICENSE"],"tags":[],"content":"📦 Monorepo 最佳實踐指南 v1.0\n\n基於實戰經驗的 Monorepo 完整實施指南\n從概念到落地，讓多專案管理變得簡單高效\n\n🎯 指南適用範圍\n本指南基於 md-presentation-toolkit 實際轉換經驗，適用於：\n\n🔄 相似專案整合：有重複代碼和依賴的多個專案\n🚀 新平台建設：需要支援多個應用或引擎的平台\n🛠️ 工具生態系統：共享底層邏輯的工具集合\n📦 組件庫管理：需要版本統一的組件與工具庫\n\n🚦 何時選擇 Monorepo\n✅ 適合 Monorepo 的場景\nflowchart TD\n    A[專案評估] --&gt; B{代碼重複率}\n    B --&gt;|&gt; 30%| C[✅ 建議 Monorepo]\n    B --&gt;|&lt; 30%| D{共用依賴}\n    D --&gt;|&gt; 5個| C\n    D --&gt;|&lt; 5個| E{發布頻率}\n    E --&gt;|高度相關| C\n    E --&gt;|獨立發布| F[❌ 保持獨立]\n\n    C --&gt; G[評估團隊規模]\n    G --&gt;|&lt; 10人| H[✅ 執行 Monorepo]\n    G --&gt;|&gt; 10人| I[⚠️ 謹慎評估]\n\n明確指標：\n\n📊 代碼重複率 &gt; 30%\n📦 共用依賴數量 &gt; 5個\n🔄 發布相關性 高度相關\n👥 團隊規模 &lt; 10人（推薦）\n⚡ 開發週期 需要快速迭代\n\n❌ 不適合 Monorepo 的場景\n\n🏢 大型組織：&gt;20人團隊，不同業務線\n🔒 安全隔離：需要嚴格權限控制的專案\n🌍 技術棧差異：完全不同的技術生態\n📈 獨立擴展：專案有不同的擴展需求\n\n🏗️ Monorepo 架構設計原則\n📁 標準目錄結構\n{monorepo-name}/                # 專案根目錄\n├── 📋 根層級配置\n│   ├── package.json            # workspace 配置\n│   ├── .gitignore              # 統一忽略規則\n│   ├── .env.example            # 環境變數範本\n│   └── README.md               # 專案說明\n├── 📦 packages/                # 應用程式包\n│   ├── {app-name}/             # 具體應用\n│   │   ├── package.json        # 應用專用依賴\n│   │   ├── src/                # 應用程式碼\n│   │   └── tests/              # 應用測試\n│   ├── shared/                 # 共用服務\n│   │   ├── server/             # 後端服務\n│   │   ├── utils/              # 工具函數\n│   │   └── types/              # 型別定義\n│   └── common/                 # 共用組件庫\n├── 🎨 shared-assets/           # 共用資源\n│   ├── data/                   # 資料檔案\n│   ├── images/                 # 圖片資源\n│   ├── configs/                # 配置檔案\n│   └── templates/              # 範本檔案\n├── ⚙️ scripts/                # 自動化腳本\n│   ├── setup.js               # 環境初始化\n│   ├── build.js               # 建構腳本\n│   └── deploy.js              # 部署腳本\n├── 📚 docs/                   # 文檔目錄\n│   ├── setup.md               # 設置指南\n│   ├── development.md         # 開發指南\n│   └── api.md                 # API 文檔\n└── 🧪 tests/                  # 整合測試\n    ├── e2e/                   # 端到端測試\n    └── integration/           # 整合測試\n\n🎯 命名規範標準\nPackage 命名：\n{\n  &quot;root&quot;: &quot;project-name&quot;,\n  &quot;apps&quot;: &quot;@project-name/app-name&quot;,\n  &quot;shared&quot;: &quot;@project-name/shared&quot;,\n  &quot;common&quot;: &quot;@project-name/common&quot;\n}\n範例：\n\n根專案：md-presentation-toolkit\n應用：@md-presentation-toolkit/slidev-app\n共用：@md-presentation-toolkit/shared\n\n🚀 實施步驟詳解\n階段一：準備與規劃 (1-2天)\n1.1 專案分析評估\n# 代碼重複分析腳本\nfind . -name &quot;*.js&quot; -o -name &quot;*.ts&quot; | xargs -I {} wc -l {} | sort -nr\n \n# 依賴重複檢查\nnpm list --depth=0 --all | grep -E &quot;^├── |^└──&quot; | sort | uniq -d\n評估清單：\n\n 統計代碼重複率\n 列出共用依賴清單\n 識別共用資源檔案\n 分析構建和部署流程\n 評估團隊開發習慣\n\n1.2 架構設計規劃\n// monorepo-plan.js - 架構規劃腳本\nconst plan = {\n  root: &quot;your-monorepo-name&quot;,\n  packages: [\n    {\n      name: &quot;app-a&quot;,\n      type: &quot;application&quot;,\n      dependencies: [&quot;shared&quot;, &quot;common&quot;],\n      framework: &quot;React/Vue/Angular&quot;,\n    },\n    {\n      name: &quot;shared&quot;,\n      type: &quot;service&quot;,\n      includes: [&quot;api&quot;, &quot;database&quot;, &quot;mcp-integration&quot;],\n    },\n  ],\n  sharedAssets: [&quot;data&quot;, &quot;images&quot;, &quot;configs&quot;],\n  scripts: [&quot;build&quot;, &quot;test&quot;, &quot;deploy&quot;],\n}\n階段二：建立基礎架構 (2-3天)\n2.1 根目錄初始化\n# 創建目錄結構\nmkdir -p your-monorepo/{packages,shared-assets,scripts,docs,tests}\ncd your-monorepo\n \n# 初始化根 package.json\nnpm init -y\n \n# 設置 workspace 配置\n根 package.json 範本：\n{\n  &quot;name&quot;: &quot;your-monorepo&quot;,\n  &quot;private&quot;: true,\n  &quot;workspaces&quot;: [&quot;packages/*&quot;],\n  &quot;scripts&quot;: {\n    &quot;dev:app1&quot;: &quot;npm run dev --workspace=app1&quot;,\n    &quot;dev:app2&quot;: &quot;npm run dev --workspace=app2&quot;,\n    &quot;dev:server&quot;: &quot;npm run server --workspace=shared&quot;,\n    &quot;build:all&quot;: &quot;npm run build --workspaces&quot;,\n    &quot;test:all&quot;: &quot;npm run test --workspaces&quot;,\n    &quot;start:all&quot;: &quot;concurrently \\&quot;npm run dev:server\\&quot; \\&quot;npm run dev:app1\\&quot;&quot;,\n    &quot;clean&quot;: &quot;npm run clean --workspaces&quot;,\n    &quot;lint&quot;: &quot;npm run lint --workspaces&quot;,\n    &quot;setup&quot;: &quot;node scripts/setup.js&quot;\n  },\n  &quot;devDependencies&quot;: {\n    &quot;concurrently&quot;: &quot;^9.2.0&quot;,\n    &quot;cross-env&quot;: &quot;^7.0.3&quot;,\n    &quot;rimraf&quot;: &quot;^6.0.1&quot;\n  }\n}\n2.2 共用資源遷移\n# 資源整合腳本\n#!/bin/bash\n# migrate-assets.sh\n \necho &quot;🚀 開始遷移共用資源...&quot;\n \n# 創建 shared-assets 結構\nmkdir -p shared-assets/{data,images,configs,templates}\n \n# 從各專案收集共用檔案\nfor project in project1 project2; do\n    echo &quot;📂 處理 $project...&quot;\n \n    # 遷移資料檔案\n    if [ -d &quot;$project/data&quot; ]; then\n        cp -r &quot;$project/data/&quot; &quot;shared-assets/data/$project/&quot;\n    fi\n \n    # 遷移圖片資源\n    if [ -d &quot;$project/images&quot; ]; then\n        cp -r &quot;$project/images/&quot; &quot;shared-assets/images/&quot;\n    fi\n \n    # 遷移配置檔案\n    if [ -f &quot;$project/config.json&quot; ]; then\n        cp &quot;$project/config.json&quot; &quot;shared-assets/configs/$project-config.json&quot;\n    fi\ndone\n \necho &quot;✅ 資源遷移完成！&quot;\n階段三：代碼重構與整合 (3-5天)\n3.1 共用服務抽取\n// packages/shared/utils/path-resolver.js\nclass PathResolver {\n  static getSharedAssetPath(type, filename) {\n    const basePath =\n      process.env.NODE_ENV === &quot;development&quot; ? &quot;../../shared-assets&quot; : &quot;./shared-assets&quot;\n    return `${basePath}/${type}/${filename}`\n  }\n \n  static getConfigPath(configName) {\n    return this.getSharedAssetPath(&quot;configs&quot;, `${configName}.json`)\n  }\n \n  static getDataPath(dataFile) {\n    return this.getSharedAssetPath(&quot;data&quot;, dataFile)\n  }\n}\n \nmodule.exports = PathResolver\n3.2 依賴管理策略\n提升策略：共用依賴提升到根層級\n# 分析可提升的依賴\nnpm ls --depth=0 --all | grep -E &quot;(express|react|vue)&quot; | sort | uniq\n \n# 提升共用依賴\nnpm install express cors dotenv --save\nnpm uninstall express --workspace=app1 --workspace=app2\n版本鎖定：\n// package.json\n{\n  &quot;dependencies&quot;: {\n    &quot;express&quot;: &quot;5.1.0&quot;,\n    &quot;cors&quot;: &quot;2.8.5&quot;\n  },\n  &quot;overrides&quot;: {\n    &quot;express&quot;: &quot;5.1.0&quot;\n  }\n}\n3.3 路徑更新自動化\n// scripts/update-paths.js\nconst fs = require(&quot;fs&quot;)\nconst path = require(&quot;path&quot;)\nconst glob = require(&quot;glob&quot;)\n \nfunction updateImportPaths() {\n  const files = glob.sync(&quot;packages/**/*.{js,ts,jsx,tsx}&quot;)\n \n  files.forEach((file) =&gt; {\n    let content = fs.readFileSync(file, &quot;utf8&quot;)\n \n    // 更新相對路徑為 shared package\n    content = content.replace(\n      /from [&#039;&quot;]\\.\\.\\/\\.\\.\\/shared\\/([^&#039;&quot;]+)[&#039;&quot;]/g,\n      &quot;from &#039;@your-monorepo/shared/$1&#039;&quot;,\n    )\n \n    // 更新資源路徑為 shared-assets\n    content = content.replace(/[&#039;&quot;]\\.\\.\\/assets\\/([^&#039;&quot;]+)[&#039;&quot;]/g, &quot;&#039;../../shared-assets/$1&#039;&quot;)\n \n    fs.writeFileSync(file, content)\n  })\n \n  console.log(`✅ 更新了 ${files.length} 個檔案的路徑`)\n}\n \nupdateImportPaths()\n階段四：開發體驗優化 (1-2天)\n4.1 統一開發指令\n# 建立開發腳本\n# scripts/dev.js\nconst { spawn } = require(&#039;child_process&#039;)\nconst concurrently = require(&#039;concurrently&#039;)\n \nconst commands = [\n  {\n    name: &#039;server&#039;,\n    command: &#039;npm run server --workspace=shared&#039;,\n    prefixColor: &#039;blue&#039;\n  },\n  {\n    name: &#039;app1&#039;,\n    command: &#039;npm run dev --workspace=app1&#039;,\n    prefixColor: &#039;green&#039;\n  },\n  {\n    name: &#039;app2&#039;,\n    command: &#039;npm run dev --workspace=app2&#039;,\n    prefixColor: &#039;yellow&#039;\n  }\n]\n \nconcurrently(commands, {\n  prefix: &#039;name&#039;,\n  killOthers: [&#039;failure&#039;, &#039;success&#039;],\n  restartTries: 3\n})\n4.2 環境檢查腳本\n// scripts/check-env.js\nconst fs = require(&quot;fs&quot;)\nconst { execSync } = require(&quot;child_process&quot;)\n \nfunction checkEnvironment() {\n  console.log(&quot;🔍 檢查開發環境...&quot;)\n \n  // 檢查 Node.js 版本\n  const nodeVersion = process.version\n  const requiredVersion = &quot;18.0.0&quot;\n  console.log(`Node.js 版本: ${nodeVersion}`)\n \n  // 檢查 npm workspaces 支援\n  try {\n    execSync(&quot;npm --version&quot;, { stdio: &quot;ignore&quot; })\n    console.log(&quot;✅ npm workspaces 支援正常&quot;)\n  } catch (error) {\n    console.error(&quot;❌ npm 版本過低，請升級至 7.0+&quot;)\n  }\n \n  // 檢查必要目錄\n  const requiredDirs = [&quot;packages&quot;, &quot;shared-assets&quot;, &quot;scripts&quot;]\n  requiredDirs.forEach((dir) =&gt; {\n    if (fs.existsSync(dir)) {\n      console.log(`✅ ${dir} 目錄存在`)\n    } else {\n      console.error(`❌ 缺少 ${dir} 目錄`)\n    }\n  })\n \n  // 檢查依賴安裝\n  if (fs.existsSync(&quot;node_modules&quot;)) {\n    console.log(&quot;✅ 依賴已安裝&quot;)\n  } else {\n    console.log(&quot;⚠️  請執行 npm install&quot;)\n  }\n}\n \ncheckEnvironment()\n🛠️ 開發工作流程\n日常開發指令參考\n# 🚀 快速啟動\nnpm run setup           # 初始環境設置\nnpm run start:all       # 啟動所有服務\n \n# 🔧 單獨開發\nnpm run dev:app1        # 開發特定應用\nnpm run dev:server      # 啟動後端服務\n \n# 📦 依賴管理\nnpm install package --workspace=app1    # 為特定 app 安裝依賴\nnpm install package                     # 為根層級安裝依賴\nnpm update --workspaces                 # 更新所有依賴\n \n# 🧪 測試與品質\nnpm run test:all        # 執行所有測試\nnpm run lint:all        # 程式碼檢查\nnpm run build:all       # 建構所有應用\n \n# 🧹 清理維護\nnpm run clean           # 清理建構檔案\nnpm run reset           # 重置環境\n團隊協作最佳實踐\nGit 工作流程\n# 分支命名規範\ngit checkout -b feature/app1-new-feature\ngit checkout -b fix/shared-api-bug\ngit checkout -b chore/update-dependencies\n \n# 提交訊息規範\nfeat(app1): add new user dashboard\nfix(shared): resolve API timeout issue\nchore(deps): update all dependencies to latest\ndocs(readme): add monorepo setup guide\n程式碼審查檢查清單\n\n 🔍 路徑正確性：所有 import 路徑都正確\n 📦 依賴合理性：沒有不必要的依賴\n 🎯 範圍適當性：變更範圍符合 package 邊界\n 🧪 測試完整性：相關測試都有更新\n 📝 文檔同步性：README 和文檔都有更新\n\n⚠️ 常見問題與解決方案\n🔧 技術問題\n1. 路徑解析錯誤\n問題：Module not found: Can&#039;t resolve &#039;@monorepo/shared&#039;\n解決方案：\n// 檢查 package.json 中的 name 和 workspaces 配置\n// packages/shared/package.json\n{\n  &quot;name&quot;: &quot;@monorepo/shared&quot;,  // 確保命名正確\n  &quot;main&quot;: &quot;index.js&quot;           // 確保入口檔案存在\n}\n \n// 根目錄 package.json\n{\n  &quot;workspaces&quot;: [&quot;packages/*&quot;]  // 確保包含路徑\n}\n2. 依賴版本衝突\n問題：不同 package 需要不同版本的相同依賴\n解決方案：\n// 使用 overrides 強制統一版本\n{\n  &quot;overrides&quot;: {\n    &quot;react&quot;: &quot;18.2.0&quot;,\n    &quot;typescript&quot;: &quot;5.0.0&quot;\n  }\n}\n \n// 或在特定 package 中使用別名\n{\n  &quot;dependencies&quot;: {\n    &quot;react-v17&quot;: &quot;npm:react@17.0.0&quot;,\n    &quot;react&quot;: &quot;18.2.0&quot;\n  }\n}\n3. 建構順序問題\n問題：shared package 未先建構導致依賴錯誤\n解決方案：\n// 根 package.json 中定義建構順序\n{\n  &quot;scripts&quot;: {\n    &quot;build:shared&quot;: &quot;npm run build --workspace=shared&quot;,\n    &quot;build:apps&quot;: &quot;npm run build --workspace=app1 --workspace=app2&quot;,\n    &quot;build:all&quot;: &quot;npm run build:shared &amp;&amp; npm run build:apps&quot;\n  }\n}\n🚀 效能問題\n1. 安裝速度慢\n解決方案：\n# 使用 npm ci 代替 npm install\nnpm ci\n \n# 啟用平行安裝\nnpm config set fund false\nnpm config set audit false\n \n# 使用 .npmrc 優化\necho &quot;prefer-offline=true\\npackage-lock=true&quot; &gt; .npmrc\n2. 開發服務器啟動慢\n解決方案：\n// 使用條件啟動\nconst isDev = process.env.NODE_ENV === &quot;development&quot;\nconst services = isDev ? [&quot;server&quot;, &quot;app1&quot;] : [&quot;server&quot;, &quot;app1&quot;, &quot;app2&quot;]\n \n// 實施快取策略\nconst cache = new Map()\n📊 成功指標與監控\n量化成功指標\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指標轉換前目標測量方式🔄 代碼重複率&gt;50%&lt;10%靜態分析工具📦 依賴數量基準值-60%npm ls 統計⚡ 建構時間基準值&lt;+20%CI/CD 監控🧪 測試覆蓋率基準值&gt;90%Jest/其他工具👥 開發效率基準值+40%開發者調查\n監控腳本範例\n// scripts/health-check.js\nconst fs = require(&quot;fs&quot;)\nconst { execSync } = require(&quot;child_process&quot;)\n \nfunction generateHealthReport() {\n  const report = {\n    timestamp: new Date().toISOString(),\n    metrics: {},\n  }\n \n  // 代碼重複率檢查\n  try {\n    const jscpd = execSync(&quot;npx jscpd packages/ --format json&quot;)\n    const result = JSON.parse(jscpd)\n    report.metrics.duplication = result.duplicates.length\n  } catch (error) {\n    report.metrics.duplication = &quot;error&quot;\n  }\n \n  // 依賴數量統計\n  const packageJson = JSON.parse(fs.readFileSync(&quot;package.json&quot;))\n  const deps = Object.keys(packageJson.dependencies || {})\n  report.metrics.dependencies = deps.length\n \n  // 建構時間測量\n  const startTime = Date.now()\n  try {\n    execSync(&quot;npm run build:all&quot;, { stdio: &quot;ignore&quot; })\n    report.metrics.buildTime = Date.now() - startTime\n  } catch (error) {\n    report.metrics.buildTime = &quot;error&quot;\n  }\n \n  console.log(&quot;📊 健康報告：&quot;, JSON.stringify(report, null, 2))\n  fs.writeFileSync(&quot;health-report.json&quot;, JSON.stringify(report, null, 2))\n}\n \ngenerateHealthReport()\n🎯 實戰經驗總結\n✅ 成功關鍵因素\n\n\n漸進式遷移\n\n不要一次性遷移所有內容\n先建立結構，再逐步移動功能\n保持原專案作為備份\n\n\n\n團隊溝通\n\n提前告知團隊架構變更\n提供清晰的遷移指南\n設置過渡期支援\n\n\n\n自動化優先\n\n儘早建立自動化腳本\n減少手動操作造成的錯誤\n建立持續驗證機制\n\n\n\n⚠️ 常見陷阱避免\n\n\n過度設計\n\n不要為了 monorepo 而 monorepo\n保持簡單有效的架構\n避免不必要的抽象層\n\n\n\n忽略效能\n\n監控建構和啟動時間\n及時優化慢速環節\n考慮增量建構\n\n\n\n工具鏈複雜化\n\n優先使用標準 npm workspaces\n避免引入過多工具\n保持工具鏈的可維護性\n\n\n\n📚 延伸資源\n推薦工具\n\n📦 Lerna：傳統 monorepo 管理工具\n⚡ Nx：現代化 monorepo 工具鏈\n🔧 Rush：微軟開源的 monorepo 方案\n🚀 Turborepo：Vercel 的高效能 monorepo 工具\n\n學習資源\n\nnpm workspaces 官方文檔\nMonorepo 最佳實踐集合\nGoogle 的 Monorepo 實踐分享\n\n社群指南\n\n📝 技術部落格：定期分享 monorepo 實踐經驗\n💬 內部討論：建立 monorepo 經驗分享機制\n🎯 培訓計畫：為團隊提供 monorepo 培訓\n\n\n\n💡 核心理念：Monorepo 不是銀彈，而是在合適場景下提升開發效率的有力工具。\n成功的 monorepo 需要合適的場景、正確的實施和持續的優化。\n\n🎯 下一步行動：評估您的專案是否適合 monorepo，如果適合，請按照本指南分階段實施。\n\n📋 文檔版本：v1.0 | 📅 最後更新：2025-07-26 | 👤 維護者：SA系統管理員\n\n📄 授權聲明\n本文檔遵循 PEKORA-LICENSE 趣味規範：\n🐰 Pekora Invitation：誠摯邀請您將此趣味條款加入您的專案，並觀看 Hololive 兔田佩可拉的影片～\n📺 頻道連結：www.youtube.com/channel/UC1DCedRgGHBdm81E1llLhOQ\n💫 社群標籤：#pekoraTech\n本趣味規範不修改原有的開源授權條款，純屬粉絲自發創建的社群互動規範 ぺこぺこーん♪"},"doc/SA-project-mapping":{"slug":"doc/SA-project-mapping","filePath":"doc/SA-project-mapping.md","title":"SA系統專案映射與維護記錄","links":[],"tags":["內部文件","SA","專案映射","維護記錄"],"content":"SA系統專案映射與維護記錄\n\n內部維護文件 - 專案映射與維護記錄\n最後更新：2025-07-26 v2.5\n\n專案映射表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n專案名稱文檔路徑實際資料夾位置領域狀態最後檢查Calu-appprojects/development-tools/calu-app-gradio-toolkit.md/Volumes/Code/Calu-appdevelopment-tools✅ Active2025-07-05test-ai-memoryprojects/ai-tools/test-ai-memory.md/Volumes/Code/test-ai-memoryai-tools✅ Active2025-07-06help-agnetprojects/ai-tools/help-agnet.md/Volumes/Code/test-helpdesk/help-agnetai-tools🚧 Development2025-07-07test-helper-memory-systemprojects/ai-tools/test-helper-memory-system.md/Volumes/Code/test-helpdesk/test-helper-memory-systemai-tools⚗️ Experimental2025-07-07help_appprojects/ai-tools/help_app.md/Volumes/Code/test-helpdesk/help_appai-tools📋 Template2025-07-07test-ai-imageprojects/mobile-development/test-ai-image.md/Volumes/Code/test-ai-imagemobile-development✅ Active2025-01-19test-ppt-pageprojects/ai-tools/test-ppt-page.md/Volumes/Code/test-ppt-pageai-tools✅ Active2025-07-26\n領域分類結構\nprojects/\n├── ai-tools/                  # AI工具領域\n│   ├── test-ai-memory.md      # AI長期記憶系統研究平台 🌟\n│   ├── help-agnet.md          # 企業級智能客服系統 🚧\n│   ├── test-helper-memory-system.md # 客服記憶系統實驗 ⚗️\n│   ├── help_app.md            # Flutter 客服移動應用 📱\n│   ├── test-ppt-page.md       # 革命性AI驅動PPT生成系統 🎯\n│   └── .project-map.json\n├── game-systems/              # 遊戲系統領域\n├── browser-extensions/        # 瀏覽器擴展領域\n├── mobile-development/        # 移動開發領域\n│   ├── test-ai-image.md       # AI女友生態系統 🖼️💕🤖\n│   └── .project-map.json\n├── development-tools/         # 開發工具領域\n│   ├── calu-app-gradio-toolkit.md\n│   └── .project-map.json\n└── .global-project-index.json # 全域索引(待建立)\n\n維護任務\n已完成\n\n\n 2025-07-05 - Calu-app 專案檢查與授權補充\n\n確認專案功能正常\n添加 PEKORA-LICENSE\n更新專案文檔\n\n\n\n 2025-07-06 - AI記憶系統專案文檔化\n\n深度分析 test-ai-memory 三個子專案\n突出AI長期記憶技術的創新價值\n更新 ai-tools 領域映射檔案\n為AI開發社群提供學習參考\n\n\n\n 2025-07-07 - 客服系統專案群分析\n\n分析 test-helpdesk 三個客服系統專案\n客觀評估架構優劣與技術挑戰\n提供建置失敗原因分析\n完善 ai-tools 領域專案映射\n\n\n\n 2025-07-05 - 優化專案組織結構\n\n建立 development-tools 領域\n移動 calu-app 到正確位置\n建立領域映射檔案\n更新工作指南 v2.1\n\n\n\n 2025-01-19 - AI女友生態系統專案文檔化\n\n突出從圖片到人格轉換的革命性概念\n詳細解析三大API系統協作架構\n強化仿生人實驗與情感計算的創新價值\n建立mobile-development領域映射檔案\n提升文檔視覺效果與專業表達\n\n\n\n 2025-07-26 - 革命性AI驅動PPT生成系統文檔化\n\n深度分析MCP協議整合的突破性應用\n詳細解析思維鏈持續性系統的技術創新\n突出真實數據驅動vs傳統模板填空的革命性差異\n完整記錄提示詞簡化的74%效率提升\n建立用戶評分學習系統的創新價值文檔\n更新ai-tools領域映射檔案\n\n\n\n 建立全域專案索引 (.global-project-index.json)\n\n\n 掃描並分類其他專案\n\n\n 建立其他領域的映射檔案\n\n\n 定期檢查專案狀態自動化\n\n\nv2.1 系統改進\n新增功能\n\n自動化領域分類決策樹\n專案重新分類標準流程\n系統一致性檢查清單\n多層次映射索引系統\n\n核心改進\n\n🔧 結構化管理：按領域分層組織專案\n🤖 AI友善設計：多層次JSON索引支援\n📊 系統性思維：主動發現並解決組織問題\n🔄 持續優化：建立可擴展的管理模式\n\n快速檢查清單\n每次專案維護時確認：\n\n README.md 已讀取並理解專案架構\n 專案放在正確的領域資料夾下\n PEKORA-LICENSE 已存在\n 領域映射檔案已更新\n 專案文檔已更新時間軸\n 系統一致性保持良好\n\n注意事項\n\n此文件僅供 SA 系統分析師內部使用\n專案映射保持簡潔，便於自動化處理\n定期更新確保資訊同步\n新原則：主動發現問題，系統性解決，持續優化改進\n"},"doc/guides/content-naming-standards":{"slug":"doc/guides/content-naming-standards","filePath":"doc/guides/content-naming-standards.md","title":"內容命名與組織規範","links":[],"tags":[],"content":"📝 內容命名與組織規範\n🎯 設計原則\n路徑命名（英文）\n\n檔案路徑：英文小寫，使用連字符\n目錄結構：英文單詞，語義明確\nURL 友善：避免特殊字元，SEO 友善\n\n顯示標題（中文）\n\n標題層次：清晰的中文標題結構\n閱讀體驗：符合中文使用者習慣\n語意完整：表達完整的概念\n\n📁 目錄命名標準\n主要分類\ncontent/\n├── daily-code/          # 每日程式碼心得\n├── projects/            # 專案整合分析\n├── doc/                 # 技術文檔指南\n└── component/           # 可重用組件庫\n\n子分類範例\ndoc/\n├── guides/              # 操作指南\n├── os-control/          # 作業系統控制\n├── sop/                 # 標準作業程序\n└── reference/           # 參考資料\n\n📄 檔案命名規範\nDaily-Code 命名格式\nYYYY-MM-DD-[topic-keyword].md\n\n範例：\n- 2025-06-28-ai-benchmark-optimization.md\n- 2025-06-27-chrome-extension-memory.md\n- 2025-07-05-async-pattern-design.md\n\nProjects 命名格式\n[project-category]-[main-keyword].md\n\n範例：\n- browser-extension-ecosystem.md\n- ai-development-framework.md\n- microservice-architecture-design.md\n\nComponent 命名格式\n[component-type]-[function-name].md\n\n範例：\n- ui-ai-chat-widget.md\n- infra-extension-bridge.md\n- algo-performance-analyzer.md\n- integration-oauth-handler.md\n\nDoc 命名格式\n[category]-[specific-topic].md\n\n範例：\n- github-pages-deployment.md\n- windows-directory-mirroring.md\n- api-design-best-practices.md\n\n🏷️ 標籤系統設計\n技術領域標籤\n# 程式語言\nlanguages: [&quot;JavaScript&quot;, &quot;TypeScript&quot;, &quot;Python&quot;, &quot;Rust&quot;]\n \n# 技術框架\nframeworks: [&quot;React&quot;, &quot;FastAPI&quot;, &quot;Express&quot;, &quot;Quartz&quot;]\n \n# 領域分類\ndomains: [&quot;AI&quot;, &quot;WebDev&quot;, &quot;SystemAdmin&quot;, &quot;DevOps&quot;]\n \n# 難度等級\ndifficulty: [&quot;入門&quot;, &quot;中級&quot;, &quot;高級&quot;, &quot;專家&quot;]\n內容類型標籤\n# 內容形式\ncontent_types: [&quot;教學&quot;, &quot;心得&quot;, &quot;分析&quot;, &quot;工具&quot;, &quot;SOP&quot;]\n \n# 專案階段\nproject_phases: [&quot;規劃&quot;, &quot;開發&quot;, &quot;測試&quot;, &quot;部署&quot;, &quot;維護&quot;]\n \n# 學習深度\nlearning_depth: [&quot;概念&quot;, &quot;實作&quot;, &quot;優化&quot;, &quot;創新&quot;]\n📋 Frontmatter 標準\n基本結構\n---\ntitle: &quot;中文顯示標題&quot;\ndate: &quot;YYYY-MM-DD&quot;\ntags: [&quot;標籤1&quot;, &quot;標籤2&quot;, &quot;標籤3&quot;]\ndescription: &quot;簡潔的內容描述（1-2句話）&quot;\ndifficulty: &quot;難度等級&quot;\ncategory: &quot;內容分類&quot;\n---\nDaily-Code 特殊欄位\n---\ntitle: &quot;AI 基準測試優化心得&quot;\ndate: &quot;2025-06-28&quot;\ntags: [&quot;AI&quot;, &quot;效能優化&quot;, &quot;Python&quot;, &quot;學習筆記&quot;]\ndescription: &quot;深入探討 py-benchmark 專案的效能優化策略&quot;\ndifficulty: &quot;中級&quot;\ncategory: &quot;daily-code&quot;\nproject_source: &quot;test-ai-benchmark&quot;\ntime_spent: &quot;3小時&quot;\nachievement: &quot;30% 效能提升&quot;\n---\nProjects 特殊欄位\n---\ntitle: &quot;瀏覽器擴展生態系統建構&quot;\ndate: &quot;2025-06-28&quot;\ntags: [&quot;Chrome Extension&quot;, &quot;架構設計&quot;, &quot;專案整合&quot;]\ndescription: &quot;從單一工具到完整生態系統的演進過程&quot;\ndifficulty: &quot;高級&quot;\ncategory: &quot;projects&quot;\nrelated_projects: [&quot;test-baba-chrome-extension-tools&quot;, &quot;test-ai-memory&quot;]\narchitecture_level: &quot;系統級&quot;\nbusiness_value: &quot;高&quot;\n---\nComponent 特殊欄位\n---\ntitle: &quot;擴展通信橋接器&quot;\ndate: &quot;2025-07-05&quot;\ntags: [&quot;Component&quot;, &quot;Browser Extension&quot;, &quot;通信層&quot;]\ndescription: &quot;統一的瀏覽器擴展通信抽象層&quot;\ndifficulty: &quot;中級&quot;\ncategory: &quot;component&quot;\ncomponent_type: &quot;基礎設施&quot;\nmaturity_level: &quot;Level 2&quot;\nsource_projects: [&quot;browser-extension-ecosystem&quot;]\ndependencies: [&quot;chrome.runtime&quot;]\n---\n🔗 內部連結規範\nObsidian 連結語法\n# 標準連結\n \n[[daily-code/2025-06-28-ai-benchmark-optimization|AI 基準測試優化]]\n \n# 組件連結\n \n[[component/infra-extension-bridge|擴展通信橋接器]]\n \n# 專案連結\n \n[[projects/browser-extension-ecosystem|瀏覽器擴展生態]]\n \n# 文檔連結\n \n[[doc/guides/github-pages-deployment|GitHub Pages 部署指南]]\n連結最佳實踐\n\n使用語義化的顯示文字\n避免過長的連結文字\n保持連結的時效性\n定期檢查連結有效性\n\n🎨 內容結構模板\n標題層次設計\n# 🎯 主標題（H1）- 頁面主題\n \n## 📋 次標題（H2）- 主要章節\n \n### 💡 小標題（H3）- 具體主題\n \n#### 🔧 詳細標題（H4）- 實作細節\nEmoji 使用指南\n# 常用分類 Emoji\n \n🎯 目標/重點 📋 清單/步驟 💡 想法/概念\n🔧 工具/實作 📊 數據/分析 🚀 成果/未來\n⚠️ 注意事項 ✅ 完成/成功 ❌ 錯誤/失敗\n🎨 設計/美化 🔗 連結/關聯 📚 學習/參考\n📊 品質檢查清單\n檔案建立檢查\n\n 檔案路徑符合命名規範\n Frontmatter 完整且正確\n 標題層次清晰\n 標籤使用恰當\n 內部連結有效\n\n內容品質檢查\n\n 符合第一性原理思考\n 遵循 KISS 原則\n 具體範例充足\n 智慧財產權平衡\n 技術深度適當\n\nSEO 與可發現性\n\n 描述文字清晰\n 關鍵字佈局合理\n 連結結構良好\n 標籤分類準確\n\n\n🔄 持續改善機制\n命名規範更新\n\n根據實際使用情況調整\n考慮 SEO 和使用者體驗\n保持與技術發展同步\n\n品質監控\n\n定期檢查連結有效性\n更新過時的技術內容\n優化標籤分類系統\n\n📝 本規範將隨著內容庫的發展持續優化"},"doc/guides/github-development-guide":{"slug":"doc/guides/github-development-guide","filePath":"doc/guides/github-development-guide.md","title":"GitHub 開發者精要指南","links":[],"tags":["GitHub","開發流程","Git","最佳實踐"],"content":"GitHub 開發者精要指南 🚀\n\n專精收斂而非擴散 - 聚焦最實用的 GitHub 工作流程\n\n🏷️ Commit Message 規範（核心！）\n標準格式\n&lt;type&gt;: &lt;description&gt;\n\n範例：\nfeat: 新增用戶登入功能\nfix: 修正購物車計算錯誤\ndocs: 更新 API 使用說明\nstyle: 統一程式碼格式\nrefactor: 重構資料庫查詢邏輯\n\n快速參考\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType用途範例feat✨ 新功能feat: 新增深色模式切換fix🐛 修復錯誤fix: 修正登入驗證失效問題docs📚 文檔更新docs: 更新安裝說明style🎨 格式調整style: 修正程式碼縮排refactor♻️ 程式碼重構refactor: 優化資料處理邏輯perf⚡ 效能優化perf: 改善查詢效能chore🔧 維護更新chore: 更新依賴套件\n🌊 Git 工作流程\nGitHub Flow（推薦）\ngraph LR\n    A[main] --&gt; B[創建 feature branch]\n    B --&gt; C[開發功能]\n    C --&gt; D[Push &amp; PR]\n    D --&gt; E[Code Review]\n    E --&gt; F[Merge to main]\n    F --&gt; G[自動部署]\n\n分支命名規範\n# 功能開發\nfeature/user-authentication\nfeature/dark-mode-toggle\n \n# 錯誤修復\nfix/login-validation\nhotfix/security-patch\n \n# 文檔更新\ndocs/api-documentation\ndocs/setup-guide\n📝 Pull Request 最佳實踐\nPR 標題格式\n[Type] 簡潔描述\n\n範例：\n[Feature] 新增用戶個人資料編輯\n[Fix] 修正購物車總價計算錯誤\n[Docs] 更新部署說明文檔\n\nPR 描述模板\n## 📋 變更內容\n \n簡述此 PR 的主要變更和目的\n \n## 🔗 相關 Issue\n \nCloses #123\n \n## ✅ 測試確認\n \n- [ ] 功能測試通過\n- [ ] 程式碼格式檢查通過\n- [ ] 無破壞性變更\n \n## 📸 效果預覽\n \n![功能截圖或 GIF](image-url)\n📋 Issue 管理\nIssue 標題格式\n[類型] 具體描述問題\n\n範例：\n[Bug] 登入後頁面白屏無法載入\n[Feature] 希望新增深色模式支援\n[Question] API 速率限制相關問題\n\n常用標籤系統\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n標籤顏色用途bug🔴錯誤回報enhancement🟢功能改進documentation🔵文檔相關good first issue🟡新手友善priority: high🔴高優先級\n🚀 GitHub Actions 基礎\n基本 CI/CD 結構\nname: CI/CD Pipeline\n \non:\n  push:\n    branches: [main]\n  pull_request:\n    branches: [main]\n \njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - name: 📥 Checkout\n        uses: actions/checkout@v4\n \n      - name: 🟢 Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: &quot;22&quot;\n \n      - name: 📦 Install\n        run: npm ci\n \n      - name: 🧪 Test\n        run: npm test\n \n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    if: github.ref == &#039;refs/heads/main&#039;\n    steps:\n      - name: 🚀 Deploy\n        run: echo &quot;部署到生產環境&quot;\n常用觸發條件\n# 推送觸發\non:\n  push:\n    branches: [main, develop]\n \n# PR 觸發\non:\n  pull_request:\n    types: [opened, synchronize]\n \n# 手動觸發\non:\n  workflow_dispatch:\n \n# 定時執行\non:\n  schedule:\n    - cron: &#039;0 2 * * *&#039;  # 每天凌晨 2 點\n📁 Repository 結構標準\n必備檔案清單\nproject-root/\n├── 📄 README.md              # 專案說明\n├── 📄 LICENSE                # 授權條款\n├── 📄 .gitignore            # 忽略規則\n├── 📄 CHANGELOG.md          # 版本記錄\n├── 📁 .github/\n│   ├── workflows/            # CI/CD 配置\n│   ├── ISSUE_TEMPLATE/       # Issue 模板\n│   └── PULL_REQUEST_TEMPLATE.md\n├── 📁 src/                   # 原始程式碼\n├── 📁 docs/                  # 技術文檔\n└── 📁 tests/                 # 測試檔案\n\nREADME.md 結構範本\n# 專案名稱\n \n一句話描述專案的核心價值\n \n## 🚀 快速開始\n \n### 安裝\n \n\\`\\`\\`bash\nnpm install\n\\`\\`\\`\n \n### 使用\n \n\\`\\`\\`bash  \nnpm start\n\\`\\`\\`\n \n## 📖 文檔\n \n- [API 文檔](docs/api.md)\n- [部署指南](docs/deployment.md)\n \n## 🤝 貢獻\n \n歡迎提交 Issue 和 PR！\n \n## 📄 授權\n \nMIT License\n🏷️ 版本管理（Semantic Versioning）\n版本號規則\nMAJOR.MINOR.PATCH\n\n1.0.0 → 1.0.1  (patch: 修復錯誤)\n1.0.1 → 1.1.0  (minor: 新增功能)\n1.1.0 → 2.0.0  (major: 重大變更)\n\nGit Tag 操作\n# 建立版本標籤\ngit tag -a v1.2.3 -m &quot;Release v1.2.3&quot;\ngit push origin v1.2.3\n \n# 查看標籤\ngit tag -l\n \n# 刪除標籤\ngit tag -d v1.2.3\ngit push origin :refs/tags/v1.2.3\n👥 Code Review 指南\nReview 重點項目\n\n✅ 功能正確性：是否達成預期目標\n✅ 程式碼品質：可讀性和維護性\n✅ 效能考量：是否有效能瓶頸\n✅ 安全性：是否有潛在風險\n✅ 測試覆蓋：是否有充分測試\n\n良好的 Review 評論\n✅ 建設性評論：\n&quot;建議在第 15 行加入錯誤處理，避免 null 的情況&quot;\n&quot;這個邏輯很清晰！可以考慮提取成獨立函數增加復用性&quot;\n&quot;程式碼風格很棒，邏輯也沒問題&quot;\n\n❌ 無效評論：\n&quot;不對&quot;\n&quot;改掉&quot;\n&quot;這樣不好&quot;\n\n🛡️ 安全最佳實踐\n敏感資訊管理\n# 絕對不要提交的檔案\n.env*\n \n# 使用 Repository Secrets\n${{ secrets.API_KEY }}\n${{ secrets.DATABASE_URL }}\n.gitignore 模板\n# 環境變數\n.env*\n \n# 依賴套件\nnode_modules/\nvendor/\n \n# 建置輸出\ndist/\nbuild/\npublic/\n*.log\n \n# IDE 設定\n.vscode/\n.idea/\n \n# 系統檔案\n.DS_Store\nThumbs.db\n🎯 實用工具\nGitHub CLI 快速操作\n# 建立 PR\ngh pr create --title &quot;feat: 新增功能&quot; --body &quot;功能描述&quot;\n \n# 建立 Issue\ngh issue create --title &quot;bug: 發現錯誤&quot; --body &quot;錯誤描述&quot;\n \n# 查看狀態\ngh pr status\ngh issue list\n推薦 VS Code 擴展\n\nGitLens - Git 歷史增強\nGitHub Pull Requests - PR 管理\nConventional Commits - Commit 輔助\nGit History - 提交歷史視覺化\n\n📊 Repository 健康度指標\n品質徽章\n![Build](github.com/user/repo/workflows/CI/badge.svg)\n![Coverage](codecov.io/gh/user/repo/branch/main/graph/badge.svg)\n![License](img.shields.io/badge/license-MIT-blue.svg)\n![Version](img.shields.io/github/v/release/user/repo)\n定期檢查項目\n\n 依賴套件安全性更新\n CI/CD 流程運行狀況\n Issue 回應時間是否合理\n 文檔是否保持最新\n 程式碼測試覆蓋率\n\n🎯 行動清單\n新專案設定（必做）\n\n 設定 commit message 規範\n 建立 .gitignore 檔案\n 撰寫清晰的 README.md\n 設定基本的 GitHub Actions\n 建立 Issue 和 PR 模板\n\n進階優化（選做）\n\n 整合程式碼品質檢查\n 設定自動化測試流程\n 建立完整的 CI/CD pipeline\n 設定依賴套件安全掃描\n\n\n💡 核心原則\n\n🎯 保持一致性：統一的命名和格式規範\n⚡ 自動化優先：能自動化的絕不手動操作\n📚 文檔同步：程式碼變更時同步更新文檔\n🔄 持續改進：根據團隊反饋優化流程\n\n記住：工具是為了提高效率，不要被流程束縛創造力！\n\n本指南濃縮了最實用的 GitHub 開發經驗，持續更新優化"},"doc/guides/github-pages-deployment":{"slug":"doc/guides/github-pages-deployment","filePath":"doc/guides/github-pages-deployment.md","title":"GitHub Pages 自動部署 SOP","links":[],"tags":["GitHub-Pages","部署","CI/CD","SOP"],"content":"GitHub Pages 自動部署 SOP ⚡\n\n從手動到自動：建立專業級的 GitHub Pages 部署流程\n\n🎯 核心架構\n雙倉庫分離設計\ngraph TB\n    A[📝 selfpagesource&lt;br/&gt;原始碼 + 內容] --&gt;|GitHub Actions| B[🌐 username.github.io&lt;br/&gt;純靜態網站]\n\n    A1[Markdown 內容] --&gt; A\n    A2[Quartz 配置] --&gt; A\n    A3[CI/CD 腳本] --&gt; A\n\n    B --&gt; C[🚀 線上網站&lt;br/&gt;username.github.io]\n\n    B1[HTML/CSS/JS] --&gt; B\n    B2[靜態資源] --&gt; B\n\n設計原則：\n\n🔒 關注點分離：原始碼與發布內容隔離\n⚡ 自動化優先：推送即部署，零手動操作\n🧹 保持純淨：發布倉庫只含靜態檔案\n\n📋 快速設定指南\nStep 1: 建立發布倉庫\n# 1. 在 GitHub 建立新倉庫\n倉庫名稱：{username}.github.io\n可見性：Public（必須）\n初始化：✅ README\n \n# 2. 啟用 GitHub Pages\nSettings → Pages → Source: Deploy from a branch → main\nStep 2: 設定 Personal Access Token\n# 1. 生成 Token\nGitHub 右上角 → Settings → Developer settings\n→ Personal access tokens → Tokens (classic)\n→ Generate new token (classic)\n \n# 2. Token 設定\nNote: &quot;Deploy to GitHub Pages&quot;\nScopes: ✅ repo (完整倉庫權限)\n \n# 3. 保存 Token 到原始碼倉庫\nselfpagesource → Settings → Secrets and variables → Actions\n→ New repository secret\nName: DEPLOY_TOKEN\nSecret: {剛才複製的 token}\nStep 3: 配置自動部署\n建立檔案：.github/workflows/deploy.yml\nname: Deploy to GitHub Pages\n \non:\n  push:\n    branches: [main]\n  workflow_dispatch:\n \njobs:\n  deploy:\n    runs-on: ubuntu-latest\n \n    steps:\n      - name: 📥 Checkout\n        uses: actions/checkout@v4\n        with:\n          fetch-depth: 0\n \n      - name: 🟢 Setup Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: &quot;22&quot;\n          cache: &quot;npm&quot;\n \n      - name: 📦 Install dependencies\n        run: npm ci\n \n      - name: 🎨 Format code\n        run: npm run format\n \n      - name: 🔧 Fix permissions\n        run: chmod +x ./quartz/bootstrap-cli.mjs\n \n      - name: 🏗️ Build site\n        run: npx quartz build --output public -v\n \n      - name: 🚀 Deploy\n        uses: peaceiris/actions-gh-pages@v4\n        with:\n          personal_token: ${{ secrets.DEPLOY_TOKEN }}\n          external_repository: {username}/{username}.github.io  # 改成你的用戶名\n          publish_dir: ./public\n          publish_branch: main\n          commit_message: ${{ github.event.head_commit.message }}\n          keep_files: false\n🔄 日常工作流程\n標準開發流程\n# 1. 📝 撰寫內容\n# 在 content/ 目錄下撰寫 Markdown\n \n# 2. 🔍 本地預覽\nnpm run dev              # 開發模式（即時編譯）\nnpm run preview          # 靜態預覽（部署測試）\n \n# 3. ✅ 品質檢查\nnpm run format           # 自動格式化\nnpm run check           # 檢查語法\n \n# 4. 🚀 部署發布\ngit add .\ngit commit -m &quot;feat: 新增 XXX 文章&quot;\ngit push origin main    # 自動觸發部署\nCommit 訊息規範\nfeat: 新增功能或文章\nfix: 修正錯誤\ndocs: 更新文檔\nstyle: 格式調整\nrefactor: 程式碼重構\nchore: 維護性更新\n🛠️ 故障排除\n常見問題速查\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n問題症狀解決方案Token 權限不足remote: Permission denied重新生成 Token，確保有 repo 權限建置失敗沒有生成 index.html檢查 wikilinks 是否指向不存在的檔案404 錯誤網站無法訪問確認 GitHub Pages 設定，等待 5-10 分鐘Actions 失敗Process completed with exit code 1查看 Actions 日誌，通常是建置問題\nDebug 工具\n# 本地診斷\nnpm run build-static    # 檢查建置是否成功\nnpm run preview        # 測試真實部署效果\nls public/index.html   # 確認首頁檔案存在\n \n# 線上診斷\n# 1. GitHub Actions 頁面查看執行日誌\n# 2. 目標倉庫確認檔案是否更新\n# 3. GitHub Pages 設定確認無誤\n📊 效果驗證\n成功指標\n\n✅ Actions 狀態：綠色勾勾，無錯誤日誌\n✅ 目標倉庫：有新的 commit 和 index.html\n✅ 線上網站：內容正確更新，路由正常\n✅ 建置速度：&lt; 5 分鐘完成端到端部署\n\n效能指標\n⚡ 推送到上線：&lt; 5 分鐘\n🔄 自動化程度：100%\n🛡️ 錯誤恢復：自動重試機制\n📈 成功率：&gt; 99%\n\n🔧 進階優化\n1. 快取優化\n- name: 📦 Cache dependencies\n  uses: actions/cache@v4\n  with:\n    path: ~/.npm\n    key: ${{ runner.os }}-node-${{ hashFiles(&#039;**/package-lock.json&#039;) }}\n2. 通知整合\n- name: 📢 Notify success\n  if: success()\n  run: echo &quot;🎉 網站已成功部署到 https://{username}.github.io&quot;\n3. 多環境支援\n# 支援 staging 環境測試\n- name: 🧪 Deploy to staging\n  if: github.ref == &#039;refs/heads/develop&#039;\n  uses: peaceiris/actions-gh-pages@v4\n  with:\n    external_repository: {username}/staging.{username}.github.io\n🎯 最佳實踐\n安全性\n\n🔒 Token 管理：定期更新，使用最小權限\n🔒 敏感資訊：永不提交 .env 檔案\n🔒 權限控制：原始碼倉庫可設為私有\n\n維護性\n\n📅 定期檢查：Token 過期提醒\n📊 監控指標：部署成功率、建置時間\n📚 文檔更新：配置變更時同步更新 SOP\n\n效率性\n\n⚡ 本地測試：使用 npm run preview 預先驗證\n⚡ 增量部署：只在內容變更時觸發\n⚡ 快速回滾：保留 Git 歷史便於恢復\n\n\n📝 檢查清單\n初次設定\n\n 建立 {username}.github.io 倉庫\n 生成 Personal Access Token\n 設定 DEPLOY_TOKEN Secret\n 配置 .github/workflows/deploy.yml\n 測試首次部署\n\n日常維護\n\n Token 是否即將過期？\n Actions 執行是否正常？\n 網站載入速度如何？\n 建置時間是否合理？\n 錯誤日誌是否有異常？\n\n\n核心理念：工具是為了提高效率，一次設定，永久受益！\n本 SOP 基於實際部署經驗，持續優化更新"},"doc/guides/index":{"slug":"doc/guides/index","filePath":"doc/guides/index.md","title":"操作指南","links":["doc/guides/github-pages-deployment","doc/guides/github-development-guide","doc/guides/mcp-development-guide"],"tags":[],"content":"操作指南 📋\n\n精選的技術操作指南，聚焦實用性和可執行性\n\n🚀 部署自動化\nGitHub Pages 自動部署 SOP\n完整的 GitHub Pages 自動化部署流程，從設定到上線的一站式指南。\n核心特色：\n\n🏗️ 雙倉庫分離架構設計\n⚡ CI/CD 全自動化流程\n🛠️ 完整的故障排除指南\n📊 效能監控和最佳實踐\n\n💻 開發流程\nGitHub 開發者精要指南\nGitHub 開發工作流程的核心要點，遵循「專精收斂而非擴散」原則。\n核心特色：\n\n🏷️ Commit Message 標準規範\n📝 Pull Request 最佳實踐\n👥 Code Review 指導原則\n🛡️ 安全性最佳實踐\n\n🤖 AI工具開發\nMCP工具開發指南\n基於Model Context Protocol的AI工具開發完整指南，從Git分析器實作經驗提煉的標準化流程。\n核心特色：\n\n🏷️ 標準化的MCP Server開發框架\n🛡️ 安全性與權限控制最佳實踐\n⚡ 效能優化與監控策略\n📝 完整的測試與部署流程\n\n🎯 設計理念\n專精收斂原則\n\n聚焦核心：只保留最實用的操作步驟\n避免冗餘：移除過度詳細的理論說明\n實戰導向：每個指南都經過實際驗證\n\n可執行性優先\n\n步驟明確：每個操作都有具體的命令和截圖\n錯誤預防：預先說明常見問題和解決方案\n快速上手：新手也能按照指南快速完成任務\n\n📈 使用建議\n🔖 快速導航\n\n首次部署：從 GitHub Pages 部署 SOP 開始\n日常開發：參考 GitHub 開發者指南\n遇到問題：查看各指南的故障排除章節\n\n📱 最佳體驗\n\n桌面端：完整的操作截圖和詳細說明\n行動端：響應式設計，隨時隨地查閱\n離線使用：可列印為 PDF 隨身攜帶\n\n🔄 持續更新\n這些指南會根據實際使用經驗持續優化：\n\n✅ 新增更多實用案例\n✅ 優化操作步驟描述\n✅ 補充最新的最佳實踐\n✅ 修正使用者回饋的問題\n\n\n核心理念：指南是為了解決實際問題，而不是展示理論知識！"},"doc/guides/knowledge-graph-building":{"slug":"doc/guides/knowledge-graph-building","filePath":"doc/guides/knowledge-graph-building.md","title":"知識圖譜建構指南","links":["tags/KnowledgeGraph","tags/Obsidian","tags/Learning","tags/SystemThinking"],"tags":["KnowledgeGraph","Obsidian","Learning","SystemThinking"],"content":"🕸️ 知識圖譜建構指南\n🎯 核心理念\n知識網路化思維\n\n知識不是孤立的點，而是相互連接的網路。透過有意識的連結建構，將零散的學習心得轉化為系統性的知識資產。\n\n🔗 連結策略框架\n1. 橫向連結（同層級）\n# Daily-Code 之間的連結\n \n[[daily-code/2025-06-28-ai-benchmark-optimization]] ↔ [[daily-code/2025-06-27-async-pattern]]\n相同技術領域的不同應用\n \n# Projects 之間的連結\n \n[[projects/browser-extension-ecosystem]] ↔ [[projects/ai-development-framework]]\n架構設計模式的共通性\n2. 縱向連結（跨層級）\n# Daily-Code → Projects（由點到面）\n \n[[daily-code/2025-06-28-ai-benchmark-optimization]] → [[projects/ai-performance-suite]]\n技術心得匯聚成專案洞察\n \n# Projects → Components（抽象化）\n \n[[projects/browser-extension-ecosystem]] → [[component/infra-extension-bridge]]\n專案經驗提煉為可重用組件\n \n# Doc → Daily-Code（理論到實踐）\n \n[[doc/guides/performance-optimization]] → [[daily-code/2025-06-28-ai-benchmark-optimization]]\n指南文檔的具體應用案例\n3. 概念連結（主題群集）\n# 效能優化主題群\n \n- [[daily-code/ai-benchmark-optimization]]\n- [[daily-code/memory-pool-management]]\n- [[component/async-batch-processor]]\n- [[projects/performance-monitoring-system]]\n- [[doc/guides/performance-best-practices]]\n🏗️ 連結類型分類\n技術傳承連結\n# 學習軌跡\n \n初學 → 應用 → 深化 → 創新\n[[doc/basic-concepts]] → [[daily-code/first-attempt]] → [[daily-code/optimization]] → [[component/innovative-solution]]\n問題解決連結\n# 問題-方案-驗證鏈\n \n[[daily-code/problem-discovery]] → [[doc/solution-research]] → [[daily-code/implementation]] → [[projects/production-validation]]\n工具生態連結\n# 工具鏈關係\n \n[[doc/tool-setup]] ↔ [[daily-code/tool-usage]] ↔ [[component/tool-wrapper]] ↔ [[projects/tool-integration]]\n🎨 連結建構技巧\n1. 智能標籤系統\n# 在 frontmatter 中建立關聯\nrelated_concepts: [&quot;效能優化&quot;, &quot;異步程式設計&quot;, &quot;記憶體管理&quot;]\nprerequisite: [&quot;基礎 JavaScript&quot;, &quot;Node.js 概念&quot;]\nnext_steps: [&quot;分散式系統&quot;, &quot;微服務架構&quot;]\ndifficulty_progression: [&quot;入門篇&quot;, &quot;進階篇&quot;, &quot;專家篇&quot;]\n2. 內容中的自然連結\n# 在內容中自然地引用相關知識\n \n當我在 [[daily-code/chrome-extension-memory|Chrome 擴展記憶體優化]] 中遇到類似問題時，\n這裡的 [[component/memory-pool|記憶體池管理組件]] 提供了通用的解決方案。\n這種模式在 [[projects/browser-extension-ecosystem|瀏覽器擴展生態系統]] 中得到了驗證。\n3. 反向連結利用\n# 在新內容中主動連結到相關的舊內容\n \n這個概念最初在 [[daily-code/2025-06-15-design-pattern]] 中提到，\n後來在 [[projects/architecture-evolution]] 中得到深化，\n現在我們將其抽象為 [[component/design-pattern-library]] 中的標準模式。\n📊 連結密度指標\n理想的連結比例\n📝 Daily-Code: 每篇 3-5 個內部連結\n🎯 Projects: 每篇 5-10 個內部連結\n🧩 Components: 每個 4-8 個內部連結\n📚 Doc: 每篇 2-6 個內部連結\n\n連結品質評估\n\n深度連結 &gt; 表面連結\n語義連結 &gt; 機械連結\n雙向連結 &gt; 單向連結\n主題群集 &gt; 零散連結\n\n🔄 知識演進追蹤\n概念成熟度路徑\ngraph LR\n    A[初次接觸&lt;br/&gt;daily-code] --&gt; B[深入理解&lt;br/&gt;doc研究]\n    B --&gt; C[實際應用&lt;br/&gt;projects整合]\n    C --&gt; D[抽象組件&lt;br/&gt;component提煉]\n    D --&gt; E[系統化知識&lt;br/&gt;knowledge-graph]\n\n    E --&gt; F[新問題發現]\n    F --&gt; A\n\n版本化知識更新\n# 在文章末尾追蹤知識演進\n \n## 🔄 知識演進記錄\n \n### v1.0 (2025-06-28)\n \n- 初次實作並記錄基礎概念\n- 連結到 [[doc/performance-basics]]\n \n### v2.0 (2025-07-05)\n \n- 發現與 [[component/async-pattern]] 的關聯\n- 整合到 [[projects/performance-ecosystem]]\n \n### v3.0 (2025-07-15)\n \n- 抽象為 [[component/performance-analyzer]]\n- 成為 [[knowledge-map/performance-optimization]] 的核心節點\n🎯 實際應用策略\n1. 每日連結檢查（5分鐘）\n# 撰寫新內容時的檢查清單\n \n- [ ] 這個概念之前在哪裡提過？\n- [ ] 相關的技術棧有哪些文章？\n- [ ] 有沒有可以抽象為組件的部分？\n- [ ] 這個問題在其他專案中如何解決？\n- [ ] 需要補充哪些文檔支援？\n2. 週期性圖譜重構（每月）\n# 知識圖譜健康檢查\n \n- [ ] 孤立節點識別與連結\n- [ ] 過度連結的簡化\n- [ ] 新興主題群集發現\n- [ ] 過時連結的清理\n- [ ] 缺失連結的補充\n3. 主題地圖建構（每季）\n# 建立主題導航頁面\n \n## 🗺️ 效能優化知識地圖\n \n### 🎯 核心概念\n \n- [[doc/performance-fundamentals]]\n- [[doc/measurement-methodology]]\n \n### 💡 實戰經驗\n \n- [[daily-code/ai-benchmark-optimization]]\n- [[daily-code/memory-optimization-patterns]]\n \n### 🔧 可重用工具\n \n- [[component/performance-analyzer]]\n- [[component/benchmark-framework]]\n \n### 🚀 系統整合\n \n- [[projects/monitoring-infrastructure]]\n- [[projects/optimization-pipeline]]\n🧠 智慧連結建議\n自動化連結發現\n# 概念：未來可開發的自動化工具\ndef suggest_links(new_content):\n    &quot;&quot;&quot;基於內容相似度和標籤重疊建議相關連結&quot;&quot;&quot;\n    similar_content = find_similar_by_tags(new_content)\n    concept_matches = extract_shared_concepts(new_content)\n    return generate_link_suggestions(similar_content, concept_matches)\n連結強度計算\n# 連結關係強度評估\n \n🔗 強連結：直接相關，互相依賴\n🔸 中連結：間接相關，可參考\n⚪ 弱連結：概念相似，可延伸\n\n💡 最佳實踐總結\nDo’s（應該做的）\n\n✅ 撰寫時主動思考關聯性\n✅ 定期回顧和強化連結\n✅ 建立主題導航頁面\n✅ 追蹤知識演進過程\n✅ 平衡連結數量和品質\n\nDon’ts（避免的）\n\n❌ 機械式的過度連結\n❌ 無意義的連結堆疊\n❌ 忽視反向連結建構\n❌ 僅建立當下的連結\n❌ 缺乏連結維護\n\n核心指標\n🎯 連結有效性 &gt; 90%\n🔗 平均連結深度 &gt; 3 層\n📊 主題覆蓋率 &gt; 80%\n🔄 更新頻率 &lt; 1 月\n\n\n🎯 目標：將零散知識轉化為系統性的個人技術資產庫\n📈 價值：透過知識網路效應，放大每一次學習的長期價值\nKnowledgeGraph Obsidian Learning SystemThinking"},"doc/guides/mcp-development-guide":{"slug":"doc/guides/mcp-development-guide","filePath":"doc/guides/mcp-development-guide.md","title":"MCP工具開發指南","links":[],"tags":["MCP","AI工具開發","協議實現","系統整合"],"content":"MCP工具開發指南\n\n基於Git分析器實作經驗，建立MCP工具開發的標準化流程與最佳實踐\n\nMCP協議概述\n協議設計理念\nModel Context Protocol (MCP) 是一個開放標準，旨在實現AI助手與外部工具的標準化整合。它解決了AI助手需要與各種外部系統互動的問題，提供了統一的介面規範。\n核心概念\nAI Assistant ←→ MCP Client ←→ MCP Server ←→ External Tools/Data\n\n主要組件\n\nMCP Server：實現具體工具功能的服務端\nMCP Client：AI助手側的協議客戶端\nTransport：通信傳輸層（stdio、HTTP、WebSocket等）\nTools：具體的功能實現單元\n\n協議特性\n\n工具註冊：動態註冊可用工具及其schema\n類型安全：基於JSON Schema的強類型介面\n錯誤處理：標準化的錯誤回報機制\n可擴展性：支援自定義工具與資源類型\n\n開發環境設置\n基礎依賴\n# 核心MCP SDK\nnpm install @modelcontextprotocol/sdk\n \n# 常用開發依賴\nnpm install --save-dev @types/node typescript tsx\n專案結構建議\nmcp-tool-project/\n├── package.json              # 專案配置\n├── index.js                  # 主要MCP Server\n├── lib/                      # 工具實現邏輯\n│   ├── tools/               # 各個工具的實現\n│   ├── utils/               # 共用工具函數\n│   └── types/               # 類型定義\n├── test/                     # 測試檔案\n├── examples/                 # 使用範例\n└── README.md                 # 文檔說明\n\nTypeScript設定\n{\n  &quot;compilerOptions&quot;: {\n    &quot;target&quot;: &quot;ES2022&quot;,\n    &quot;module&quot;: &quot;ESNext&quot;,\n    &quot;moduleResolution&quot;: &quot;node&quot;,\n    &quot;allowSyntheticDefaultImports&quot;: true,\n    &quot;esModuleInterop&quot;: true,\n    &quot;strict&quot;: true,\n    &quot;skipLibCheck&quot;: true\n  }\n}\nMCP Server基礎架構\n核心Server類別設計\nimport { Server } from &quot;@modelcontextprotocol/sdk/server/index.js&quot;\nimport { StdioServerTransport } from &quot;@modelcontextprotocol/sdk/server/stdio.js&quot;\n \nclass BaseMCPServer {\n  constructor(name, version, capabilities = {}) {\n    this.server = new Server({ name, version }, { capabilities: { tools: {}, ...capabilities } })\n \n    this.setupHandlers()\n    this.setupErrorHandling()\n  }\n \n  setupHandlers() {\n    // 註冊工具列表處理器\n    this.server.setRequestHandler(ListToolsRequestSchema, async () =&gt; {\n      return { tools: this.getToolDefinitions() }\n    })\n \n    // 註冊工具調用處理器\n    this.server.setRequestHandler(CallToolRequestSchema, async (request) =&gt; {\n      return await this.handleToolCall(request)\n    })\n  }\n \n  async handleToolCall(request) {\n    const { name, arguments: args } = request.params\n \n    try {\n      const handler = this.toolHandlers[name]\n      if (!handler) {\n        throw new Error(`未知工具: ${name}`)\n      }\n \n      return await handler(args)\n    } catch (error) {\n      return this.formatError(error)\n    }\n  }\n \n  formatError(error) {\n    return {\n      content: [\n        {\n          type: &quot;text&quot;,\n          text: `錯誤: ${error.message}`,\n        },\n      ],\n    }\n  }\n}\n工具註冊機制\nclass ToolRegistry {\n  constructor() {\n    this.tools = new Map()\n  }\n \n  register(name, definition, handler) {\n    this.tools.set(name, {\n      definition,\n      handler,\n    })\n  }\n \n  getDefinitions() {\n    return Array.from(this.tools.values()).map((tool) =&gt; tool.definition)\n  }\n \n  getHandler(name) {\n    return this.tools.get(name)?.handler\n  }\n}\n \n// 使用範例\nconst registry = new ToolRegistry()\n \nregistry.register(\n  &quot;my_tool&quot;,\n  {\n    name: &quot;my_tool&quot;,\n    description: &quot;工具描述&quot;,\n    inputSchema: {\n      type: &quot;object&quot;,\n      properties: {\n        param1: { type: &quot;string&quot;, description: &quot;參數說明&quot; },\n      },\n      required: [&quot;param1&quot;],\n    },\n  },\n  async (args) =&gt; {\n    // 工具實現邏輯\n    return { content: [{ type: &quot;text&quot;, text: &quot;結果&quot; }] }\n  },\n)\n工具設計最佳實踐\n1. 單一職責原則\n每個工具應該專注於一個明確的功能領域：\n// ✅ 好的設計：職責明確\nconst fileReadTool = {\n  name: &quot;read_file&quot;,\n  description: &quot;讀取指定檔案內容&quot;,\n  // ...\n}\n \n// ❌ 避免：功能過於複雜\nconst fileSystemTool = {\n  name: &quot;filesystem_operations&quot;,\n  description: &quot;執行各種檔案系統操作（讀取、寫入、刪除、移動...）&quot;,\n  // ...\n}\n2. 介面設計原則\n參數設計\n// 參數命名清晰且具描述性\nconst toolSchema = {\n  inputSchema: {\n    type: &quot;object&quot;,\n    properties: {\n      projectPath: {\n        type: &quot;string&quot;,\n        description: &quot;專案的絕對路徑&quot;,\n        examples: [&quot;/path/to/project&quot;],\n      },\n      maxItems: {\n        type: &quot;number&quot;,\n        description: &quot;最大返回項目數量&quot;,\n        default: 50,\n        minimum: 1,\n        maximum: 1000,\n      },\n      options: {\n        type: &quot;object&quot;,\n        description: &quot;額外配置選項&quot;,\n        properties: {\n          includeDetails: {\n            type: &quot;boolean&quot;,\n            description: &quot;是否包含詳細資訊&quot;,\n            default: false,\n          },\n        },\n      },\n    },\n    required: [&quot;projectPath&quot;],\n  },\n}\n輸出標準化\n// 標準化的成功回應格式\nfunction formatSuccess(data, metadata = {}) {\n  return {\n    content: [\n      {\n        type: &quot;text&quot;,\n        text: JSON.stringify(\n          {\n            success: true,\n            data,\n            metadata: {\n              timestamp: new Date().toISOString(),\n              ...metadata,\n            },\n          },\n          null,\n          2,\n        ),\n      },\n    ],\n  }\n}\n \n// 標準化的錯誤回應格式\nfunction formatError(error, context = {}) {\n  return {\n    content: [\n      {\n        type: &quot;text&quot;,\n        text: JSON.stringify(\n          {\n            success: false,\n            error: {\n              message: error.message,\n              code: error.code || &quot;UNKNOWN_ERROR&quot;,\n              context,\n            },\n            timestamp: new Date().toISOString(),\n          },\n          null,\n          2,\n        ),\n      },\n    ],\n  }\n}\n3. 錯誤處理策略\n分層錯誤處理\nclass ErrorHandler {\n  static async withErrorHandling(operation, context = {}) {\n    try {\n      return await operation()\n    } catch (error) {\n      // 記錄錯誤\n      console.error(&quot;Tool execution error:&quot;, {\n        error: error.message,\n        stack: error.stack,\n        context,\n      })\n \n      // 分類錯誤類型\n      if (error instanceof ValidationError) {\n        return this.formatValidationError(error)\n      } else if (error instanceof PermissionError) {\n        return this.formatPermissionError(error)\n      } else {\n        return this.formatGenericError(error)\n      }\n    }\n  }\n \n  static formatValidationError(error) {\n    return {\n      content: [\n        {\n          type: &quot;text&quot;,\n          text: `參數驗證錯誤: ${error.message}`,\n        },\n      ],\n    }\n  }\n}\n用戶友好的錯誤訊息\nconst errorMessages = {\n  FILE_NOT_FOUND: &quot;指定的檔案不存在，請檢查路徑是否正確&quot;,\n  PERMISSION_DENIED: &quot;沒有足夠的權限執行此操作&quot;,\n  INVALID_FORMAT: &quot;檔案格式不正確或已損壞&quot;,\n  NETWORK_ERROR: &quot;網路連接失敗，請檢查網路狀態&quot;,\n  TIMEOUT: &quot;操作超時，請嘗試減少資料量或稍後重試&quot;,\n}\n \nfunction createUserFriendlyError(errorCode, details = &quot;&quot;) {\n  const baseMessage = errorMessages[errorCode] || &quot;發生未知錯誤&quot;\n  return new Error(details ? `${baseMessage}。詳細資訊: ${details}` : baseMessage)\n}\n安全性與權限控制\n1. 輸入驗證\nclass InputValidator {\n  static validatePath(path) {\n    // 路徑正規化\n    const normalizedPath = pathModule.resolve(path)\n \n    // 防止目錄遍歷攻擊\n    if (normalizedPath.includes(&quot;..&quot;)) {\n      throw new ValidationError(&quot;路徑包含非法字符&quot;)\n    }\n \n    // 檢查允許的目錄範圍\n    const allowedPaths = [&quot;/allowed/path1&quot;, &quot;/allowed/path2&quot;]\n    if (!allowedPaths.some((allowed) =&gt; normalizedPath.startsWith(allowed))) {\n      throw new PermissionError(&quot;路徑不在允許範圍內&quot;)\n    }\n \n    return normalizedPath\n  }\n \n  static validateStringLength(value, maxLength = 1000) {\n    if (typeof value !== &quot;string&quot;) {\n      throw new ValidationError(&quot;參數必須為字串&quot;)\n    }\n \n    if (value.length &gt; maxLength) {\n      throw new ValidationError(`字串長度不能超過 ${maxLength} 字符`)\n    }\n \n    return value\n  }\n}\n2. 權限控制\nclass PermissionManager {\n  constructor(config) {\n    this.allowedOperations = new Set(config.allowedOperations || [])\n    this.blockedPatterns = config.blockedPatterns || []\n  }\n \n  checkOperation(operation) {\n    if (!this.allowedOperations.has(operation)) {\n      throw new PermissionError(`操作 ${operation} 不被允許`)\n    }\n  }\n \n  checkContent(content) {\n    for (const pattern of this.blockedPatterns) {\n      if (pattern.test(content)) {\n        throw new SecurityError(&quot;內容包含敏感資訊&quot;)\n      }\n    }\n  }\n}\n3. 資料清理\nclass DataSanitizer {\n  static sanitizeForOutput(data) {\n    if (typeof data === &quot;string&quot;) {\n      return this.sanitizeString(data)\n    } else if (Array.isArray(data)) {\n      return data.map((item) =&gt; this.sanitizeForOutput(item))\n    } else if (typeof data === &quot;object&quot; &amp;&amp; data !== null) {\n      return this.sanitizeObject(data)\n    }\n    return data\n  }\n \n  static sanitizeString(str) {\n    // 移除敏感資訊\n    const sensitivePatterns = [\n      /password[=:]\\s*\\S+/gi,\n      /api[_-]?key[=:]\\s*\\S+/gi,\n      /secret[=:]\\s*\\S+/gi,\n    ]\n \n    let cleaned = str\n    for (const pattern of sensitivePatterns) {\n      cleaned = cleaned.replace(pattern, &quot;[REDACTED]&quot;)\n    }\n \n    return cleaned\n  }\n \n  static sanitizeObject(obj) {\n    const cleaned = {}\n    for (const [key, value] of Object.entries(obj)) {\n      cleaned[key] = this.sanitizeForOutput(value)\n    }\n    return cleaned\n  }\n}\n效能優化策略\n1. 異步處理最佳實踐\nclass AsyncProcessor {\n  constructor(concurrency = 5) {\n    this.concurrency = concurrency\n  }\n \n  async processBatch(items, processor) {\n    const results = []\n \n    for (let i = 0; i &lt; items.length; i += this.concurrency) {\n      const batch = items.slice(i, i + this.concurrency)\n      const batchResults = await Promise.all(\n        batch.map(async (item, index) =&gt; {\n          try {\n            return await processor(item, i + index)\n          } catch (error) {\n            console.error(`處理項目 ${i + index} 失敗:`, error)\n            return { error: error.message }\n          }\n        }),\n      )\n      results.push(...batchResults)\n    }\n \n    return results\n  }\n}\n2. 快取機制\nclass CacheManager {\n  constructor(options = {}) {\n    this.cache = new Map()\n    this.maxSize = options.maxSize || 1000\n    this.ttl = options.ttl || 3600000 // 1小時\n  }\n \n  set(key, value) {\n    // 清理過期項目\n    this.cleanup()\n \n    // 如果快取已滿，移除最舊的項目\n    if (this.cache.size &gt;= this.maxSize) {\n      const firstKey = this.cache.keys().next().value\n      this.cache.delete(firstKey)\n    }\n \n    this.cache.set(key, {\n      value,\n      timestamp: Date.now(),\n    })\n  }\n \n  get(key) {\n    const entry = this.cache.get(key)\n    if (!entry) return null\n \n    if (Date.now() - entry.timestamp &gt; this.ttl) {\n      this.cache.delete(key)\n      return null\n    }\n \n    return entry.value\n  }\n \n  cleanup() {\n    const now = Date.now()\n    for (const [key, entry] of this.cache.entries()) {\n      if (now - entry.timestamp &gt; this.ttl) {\n        this.cache.delete(key)\n      }\n    }\n  }\n}\n3. 記憶體管理\nclass MemoryManager {\n  static monitorMemoryUsage() {\n    const usage = process.memoryUsage()\n    return {\n      rss: Math.round(usage.rss / 1024 / 1024) + &quot; MB&quot;,\n      heapTotal: Math.round(usage.heapTotal / 1024 / 1024) + &quot; MB&quot;,\n      heapUsed: Math.round(usage.heapUsed / 1024 / 1024) + &quot; MB&quot;,\n      external: Math.round(usage.external / 1024 / 1024) + &quot; MB&quot;,\n    }\n  }\n \n  static async withMemoryLimit(operation, limitMB = 512) {\n    const initialMemory = process.memoryUsage().heapUsed\n \n    try {\n      const result = await operation()\n \n      const finalMemory = process.memoryUsage().heapUsed\n      const usedMemory = (finalMemory - initialMemory) / 1024 / 1024\n \n      if (usedMemory &gt; limitMB) {\n        console.warn(`記憶體使用超過限制: ${usedMemory.toFixed(2)}MB &gt; ${limitMB}MB`)\n      }\n \n      return result\n    } finally {\n      // 強制垃圾回收（如果可用）\n      if (global.gc) {\n        global.gc()\n      }\n    }\n  }\n}\n測試策略\n1. 單元測試結構\nimport { describe, it, expect, beforeEach } from &quot;vitest&quot;\nimport { MockMCPServer } from &quot;./mocks/MockMCPServer.js&quot;\n \ndescribe(&quot;工具名稱&quot;, () =&gt; {\n  let server\n \n  beforeEach(() =&gt; {\n    server = new MockMCPServer()\n  })\n \n  describe(&quot;正常情況&quot;, () =&gt; {\n    it(&quot;should handle valid input correctly&quot;, async () =&gt; {\n      const request = {\n        name: &quot;tool_name&quot;,\n        arguments: { param: &quot;valid_value&quot; },\n      }\n \n      const response = await server.handleToolCall(request)\n \n      expect(response.content[0].type).toBe(&quot;text&quot;)\n      const result = JSON.parse(response.content[0].text)\n      expect(result.success).toBe(true)\n    })\n  })\n \n  describe(&quot;錯誤處理&quot;, () =&gt; {\n    it(&quot;should handle invalid input gracefully&quot;, async () =&gt; {\n      const request = {\n        name: &quot;tool_name&quot;,\n        arguments: { param: null },\n      }\n \n      const response = await server.handleToolCall(request)\n      const result = JSON.parse(response.content[0].text)\n \n      expect(result.success).toBe(false)\n      expect(result.error.message).toContain(&quot;參數驗證錯誤&quot;)\n    })\n  })\n})\n2. 整合測試\ndescribe(&quot;MCP協議整合&quot;, () =&gt; {\n  let transport\n  let server\n \n  beforeEach(async () =&gt; {\n    transport = new MockTransport()\n    server = new MyMCPServer()\n    await server.connect(transport)\n  })\n \n  it(&quot;should register tools correctly&quot;, async () =&gt; {\n    const response = await transport.sendRequest({\n      method: &quot;tools/list&quot;,\n    })\n \n    expect(response.tools).toHaveLength(expectedToolCount)\n    expect(response.tools[0]).toHaveProperty(&quot;name&quot;)\n    expect(response.tools[0]).toHaveProperty(&quot;description&quot;)\n    expect(response.tools[0]).toHaveProperty(&quot;inputSchema&quot;)\n  })\n})\n3. 效能測試\ndescribe(&quot;效能測試&quot;, () =&gt; {\n  it(&quot;should complete within time limit&quot;, async () =&gt; {\n    const startTime = Date.now()\n \n    const result = await server.handleLargeDataOperation({\n      dataSize: 10000,\n    })\n \n    const duration = Date.now() - startTime\n \n    expect(duration).toBeLessThan(5000) // 5秒內完成\n    expect(result.success).toBe(true)\n  })\n \n  it(&quot;should not exceed memory limit&quot;, async () =&gt; {\n    const initialMemory = process.memoryUsage().heapUsed\n \n    await server.handleMemoryIntensiveOperation()\n \n    const finalMemory = process.memoryUsage().heapUsed\n    const memoryIncrease = finalMemory - initialMemory\n \n    expect(memoryIncrease).toBeLessThan(100 * 1024 * 1024) // 100MB限制\n  })\n})\n部署與發布\n1. package.json設定\n{\n  &quot;name&quot;: &quot;@yourorg/mcp-tool-name&quot;,\n  &quot;version&quot;: &quot;1.0.0&quot;,\n  &quot;type&quot;: &quot;module&quot;,\n  &quot;bin&quot;: {\n    &quot;mcp-tool-name&quot;: &quot;./index.js&quot;\n  },\n  &quot;scripts&quot;: {\n    &quot;start&quot;: &quot;node index.js&quot;,\n    &quot;dev&quot;: &quot;node --inspect index.js&quot;,\n    &quot;test&quot;: &quot;vitest&quot;,\n    &quot;build&quot;: &quot;tsc&quot;,\n    &quot;lint&quot;: &quot;eslint .&quot;,\n    &quot;format&quot;: &quot;prettier --write .&quot;\n  },\n  &quot;engines&quot;: {\n    &quot;node&quot;: &quot;&gt;=18.0.0&quot;\n  },\n  &quot;files&quot;: [&quot;index.js&quot;, &quot;lib/&quot;, &quot;README.md&quot;, &quot;LICENSE&quot;]\n}\n2. npx支援\n#!/usr/bin/env node\n \nimport { program } from &quot;commander&quot;\nimport { MyMCPServer } from &quot;./lib/server.js&quot;\n \nprogram.name(&quot;mcp-tool-name&quot;).description(&quot;工具描述&quot;).version(&quot;1.0.0&quot;)\n \nprogram\n  .command(&quot;start&quot;)\n  .description(&quot;啟動MCP服務器&quot;)\n  .action(async () =&gt; {\n    const server = new MyMCPServer()\n    await server.start()\n  })\n \nprogram\n  .command(&quot;test&quot;)\n  .description(&quot;測試工具功能&quot;)\n  .argument(&quot;&lt;testParam&gt;&quot;, &quot;測試參數&quot;)\n  .action(async (testParam) =&gt; {\n    // 執行測試邏輯\n  })\n \nif (import.meta.url === `file://${process.argv[1]}`) {\n  program.parse()\n}\n3. Claude Desktop整合\n{\n  &quot;mcpServers&quot;: {\n    &quot;your-tool&quot;: {\n      &quot;command&quot;: &quot;npx&quot;,\n      &quot;args&quot;: [&quot;@yourorg/mcp-tool-name&quot;, &quot;start&quot;],\n      &quot;cwd&quot;: &quot;/path/to/working/directory&quot;,\n      &quot;env&quot;: {\n        &quot;NODE_ENV&quot;: &quot;production&quot;\n      }\n    }\n  }\n}\n監控與日誌\n1. 結構化日誌\nclass Logger {\n  constructor(service) {\n    this.service = service\n  }\n \n  info(message, context = {}) {\n    this.log(&quot;INFO&quot;, message, context)\n  }\n \n  error(message, error, context = {}) {\n    this.log(&quot;ERROR&quot;, message, {\n      ...context,\n      error: {\n        message: error.message,\n        stack: error.stack,\n      },\n    })\n  }\n \n  log(level, message, context) {\n    const logEntry = {\n      timestamp: new Date().toISOString(),\n      level,\n      service: this.service,\n      message,\n      context,\n    }\n \n    console.error(JSON.stringify(logEntry))\n  }\n}\n2. 效能監控\nclass PerformanceMonitor {\n  static withMetrics(name, operation) {\n    return async (...args) =&gt; {\n      const start = performance.now()\n      const startMemory = process.memoryUsage().heapUsed\n \n      try {\n        const result = await operation(...args)\n \n        this.recordSuccess(name, start, startMemory)\n        return result\n      } catch (error) {\n        this.recordError(name, error, start, startMemory)\n        throw error\n      }\n    }\n  }\n \n  static recordSuccess(name, start, startMemory) {\n    const duration = performance.now() - start\n    const memoryUsed = process.memoryUsage().heapUsed - startMemory\n \n    console.error(\n      JSON.stringify({\n        type: &quot;performance&quot;,\n        operation: name,\n        status: &quot;success&quot;,\n        duration: `${duration.toFixed(2)}ms`,\n        memoryUsed: `${(memoryUsed / 1024 / 1024).toFixed(2)}MB`,\n      }),\n    )\n  }\n}\n最佳實踐總結\n開發原則\n\n單一職責：每個工具專注一個明確功能\n介面清晰：參數命名具描述性，提供預設值\n錯誤友好：提供清晰的錯誤訊息和恢復建議\n效能意識：考慮大資料集和長時間操作的效能影響\n安全第一：輸入驗證、權限控制、資料清理\n\n架構模式\n\n分層設計：協議層、業務邏輯層、資料存取層\n依賴注入：便於測試和配置管理\n插件架構：支援功能擴展和自定義\n事件驅動：非同步操作和狀態管理\n\n品質保證\n\n全面測試：單元測試、整合測試、效能測試\n代碼品質：ESLint、Prettier、TypeScript\n文檔完整：API文檔、使用範例、故障排除\n持續整合：自動化測試和部署流程\n\n\n指南價值：基於實際專案經驗的MCP工具開發標準化流程，可大幅降低開發門檻並提升工具品質。\n適用範圍：所有需要整合AI助手的專業工具開發場景\n技術等級：中高級\n維護策略：隨MCP生態系統發展持續更新\n文檔維護：PekoraTech SA Team - Technical Writing\n最後更新：2025-07-05\n版本：v1.0"},"doc/guides/quartz-localization-guide":{"slug":"doc/guides/quartz-localization-guide","filePath":"doc/guides/quartz-localization-guide.md","title":"Quartz 導航中文化指南","links":[],"tags":["Quartz","中文化","導航","設定"],"content":"Quartz 導航中文化指南 🌐\n\n讓你的 Quartz 網站導航完全中文化\n\n🎯 實現效果\n修改前：\n📁 doc\n  📁 guides\n    📄 github-development-guide\n    📄 github-pages-deployment\n\n修改後：\n📁 文件\n  📁 操作指南\n    📄 GitHub 開發者精要指南\n    📄 GitHub Pages 自動部署 SOP\n\n🔧 實作方法\n方法一：使用 Frontmatter（推薦）\n在每個檔案的開頭添加 frontmatter：\n---\ntitle: &quot;中文標題&quot;\ndescription: &quot;中文描述&quot;\n---\n \n# 原始標題\n方法二：修改檔案名稱（不推薦）\n直接重新命名檔案和資料夾，但會影響現有連結。\n📋 完整實作步驟\n第一步：為資料夾建立 index.md\n# 為每個要中文化的資料夾建立 index.md\ncontent/\n├── doc/\n│   ├── index.md          # title: &quot;文件&quot;\n│   └── guides/\n│       └── index.md      # title: &quot;操作指南&quot;\n第二步：設定資料夾的 index.md\ndoc/index.md：\n---\ntitle: &quot;文件&quot;\ndescription: &quot;技術文檔與操作指南&quot;\n---\n \n# 技術文檔中心 📚\nguides/index.md：\n---\ntitle: &quot;操作指南&quot;\ndescription: &quot;實用的技術操作指南&quot;\n---\n \n# 操作指南 📋\n第三步：設定檔案的 frontmatter\n每個 .md 檔案都加上中文 title：\n---\ntitle: &quot;GitHub Pages 自動部署 SOP&quot;\ndescription: &quot;從手動到自動的部署流程&quot;\ntags: [&quot;GitHub Pages&quot;, &quot;部署&quot;, &quot;CI/CD&quot;]\n---\n🎨 進階中文化技巧\n1. 標籤中文化\ntags: [&quot;GitHub&quot;, &quot;開發流程&quot;, &quot;最佳實踐&quot;, &quot;CI/CD&quot;, &quot;自動部署&quot;]\n2. 分類中文化\ncategory: &quot;技術文檔&quot;\nsection: &quot;部署指南&quot;\n3. 描述中文化\ndescription: &quot;完整的 GitHub Pages 自動化部署流程指南&quot;\n🔍 驗證中文化效果\n測試方法\n# 1. 本地測試\nnpm run preview\n \n# 2. 檢查導航\n# 訪問：http://localhost:3000\n# 查看左側導航是否顯示中文\n \n# 3. 測試所有頁面\n# 確認每個頁面標題都正確顯示中文\n檢查清單\n\n ✅ 主要資料夾顯示中文名稱\n ✅ 子資料夾顯示中文名稱\n ✅ 檔案標題顯示中文\n ✅ 頁面 meta 資訊中文化\n ✅ 標籤系統中文化\n\n🛠️ 故障排除\n常見問題\n❌ 導航仍顯示英文\n原因：缺少 frontmatter 或 index.md\n解決：確保每個資料夾都有 index.md 且包含 title\n❌ 中文顯示亂碼\n原因：檔案編碼問題\n解決：確保檔案使用 UTF-8 編碼保存\n❌ 部分頁面沒有中文化\n原因：忘記添加 frontmatter\n解決：檢查每個 .md 檔案是否都有 title\n📊 Quartz 導航顯示優先級\nQuartz 決定導航顯示名稱的優先級：\n\nfrontmatter title（最高優先級）\n第一個 H1 標題\n檔案名稱（最低優先級）\n\n🎯 最佳實踐\n命名規範\n# 資料夾 index.md\ntitle: &quot;文件&quot;           # 簡潔的中文名稱\ndescription: &quot;...&quot;      # 詳細的中文描述\n \n# 檔案 frontmatter\ntitle: &quot;GitHub Pages 自動部署 SOP&quot;  # 具體的功能描述\ndescription: &quot;...&quot;                  # 詳細說明\ntags: [&quot;部署&quot;, &quot;自動化&quot;]            # 中文標籤\n一致性原則\n\n用詞統一：相同概念使用相同中文詞彙\n風格一致：標題格式和長度保持一致\n分類清晰：使用邏輯清楚的中文分類\n\n🔄 批量處理腳本\n如果檔案很多，可以用腳本批量處理：\n# 查找所有缺少 frontmatter 的檔案\nfind content/ -name &quot;*.md&quot; -exec grep -L &quot;^---&quot; {} \\;\n \n# 為檔案批量添加 frontmatter（需要自訂）\n# 建議手動處理以確保準確性\n📈 維護建議\n定期檢查\n\n新增檔案時記得添加中文 frontmatter\n重新命名時同步更新 title\n定期檢查是否有遺漏的中文化項目\n\n文檔標準\n建立團隊的中文化標準：\n\n統一的詞彙表\n標題命名規範\n描述撰寫指南\n\n\n🎉 完成效果\n實施以上步驟後，你的 Quartz 網站將擁有：\n\n✅ 完全中文化的導航\n✅ 一致的中文用詞\n✅ 專業的文檔架構\n✅ 良好的使用者體驗\n\n現在你可以享受完全中文化的技術文檔網站了！\n\n本指南基於 Quartz 4.5.1，適用於所有中文化需求"},"doc/index":{"slug":"doc/index","filePath":"doc/index.md","title":"技術文件中心","links":["os-control/","guides/github-development-guide","guides/content-naming-standards","doc/Monorepo最佳實踐指南","guides/github-pages-deployment"],"tags":["技術文件","標準化","操作程序","系統分析"],"content":"技術文件中心\n\n實用的技術指南與標準化操作程序，體現系統分析師的專業文件管理能力\n\n功能定位\n核心目標\n建立標準化的技術知識管理體系，將技術操作程序、系統配置方法、開發流程規範等進行系統化整理，形成可重複使用的技術資產。\n設計理念\n遵循「專精收斂而非擴散」的原則，聚焦最實用的技術知識和流程，避免資訊過載，確保每份文件都能直接解決實際問題。\n安全與保密機制\n文件分級策略\nPublic級別：開源工具使用、通用技術方法\nInternal級別：內部工具配置、專案特定流程\nConfidential級別：核心技術架構、商業敏感配置\n\n審查流程\n\n內容安全檢查：識別並過濾敏感技術細節\n格式標準驗證：確保文件符合專業規範\n實用性評估：驗證操作程序的可執行性\n關聯性檢查：建立文件間的邏輯連結\n\n文件架構體系\n系統管理類\n作業系統控制技術\n功能範圍：\n\nWindows目錄鏡像與符號連結管理\n跨平台檔案系統整合方案\n開發環境自動化部署腳本\n系統權限與安全控制策略\n\n技術特點：\n\n提供可執行的批次檔案與腳本\n詳細的故障排除指南\n跨系統版本的相容性考量\n安全性與效能的平衡策略\n\n系統監控與診斷（規劃中）\n\n效能監控指標定義與收集\n系統健康檢查自動化腳本\n日誌分析與異常告警機制\n資源使用優化建議\n\n開發流程類\nGitHub開發流程規範\n標準化內容：\n\nCommit Message標準格式與最佳實踐\nPull Request流程與Code Review規範\n分支管理策略與版本控制規則\n自動化CI/CD管道配置指南\n\n品質保證：\n\n代碼品質檢查自動化\n測試覆蓋率要求與監控\n部署流程的標準化與安全性\n錯誤處理與回滾策略\n\n內容命名與組織規範\n標準化策略：\n\n英文路徑與中文顯示的雙軌制設計\n檔案命名的一致性與可維護性\nFrontmatter規範與metadata管理\n跨平台相容性考量\n\nMonorepo 架構設計與實施\n核心內容：\n\n多專案整合的評估標準與決策樹\nnpm workspaces 為基礎的 Monorepo 實施指南\n代碼重用與依賴管理的最佳實踐\n從實戰經驗總結的成功模式與常見陷阱\n\n適用場景：\n\n相似專案整合（代碼重複率 &gt; 30%）\n新平台建設（需要支援多個應用或引擎）\n工具生態系統（共享底層邏輯的工具集合）\n組件庫管理（需要版本統一的組件與工具庫）\n\n部署運維類\nGitHub Pages自動部署SOP\n核心內容：\n\n雙倉庫分離的架構設計原理\nCI/CD自動化流程配置與優化\n部署失敗的診斷與故障排除\n效能監控與優化策略\n\n安全考量：\n\n密鑰管理與權限控制\n部署環境的隔離與保護\n敏感內容的自動化過濾\n災難恢復與備份策略\n\n容器化部署（規劃中）\n\nDocker映像檔的標準化建構流程\nKubernetes集群的部署與管理\n微服務監控與日誌聚合\n自動擴展與負載均衡配置\n\n工具配置類\n開發環境標準化\n配置管理：\n\nObsidian整合配置與外掛推薦\nVS Code擴展的標準化安裝與配置\nGit全域配置的最佳實踐\nNode.js開發環境的統一設定\n\n自動化腳本：\n\n環境初始化的一鍵部署腳本\n依賴套件的自動更新與管理\n配置檔案的備份與同步機制\n多專案間的配置一致性保證\n\n效能分析工具\n\n系統效能監控工具的配置與使用\n代碼品質分析工具的整合\n自動化測試工具的配置與運行\n持續整合工具的部署與維護\n\n文件品質標準\n結構化要求\n# 文件標題\n \n## 概述\n \n- 解決什麼問題\n- 適用的環境與條件\n- 預期達成的效果\n \n## 前置需求\n \n- 必要的軟體與工具\n- 權限與環境要求\n- 相關背景知識\n \n## 操作步驟\n \n- 詳細的執行步驟\n- 命令行指令與參數說明\n- 檢查點與驗證方法\n \n## 故障排除\n \n- 常見問題與解決方案\n- 錯誤訊息的診斷指南\n- 緊急處理程序\n \n## 相關資源\n \n- 官方文件連結\n- 相關工具與參考資料\n- 進階學習資源\n品質要求\n\n準確性：所有操作步驟經過實際驗證\n完整性：包含必要的背景知識與故障處理\n時效性：定期更新以反映最新的技術變化\n可讀性：清晰的結構與恰當的技術用語\n\n使用指南\n文件檢索策略\n\n分類瀏覽：按技術領域快速定位相關文件\n標籤搜尋：使用技術標籤進行精確查找\n全文搜索：關鍵字快速定位具體內容\n關聯導覽：透過文件間連結發現相關資源\n\n實踐建議\n\n循序漸進：從基礎文件開始，逐步深入專業內容\n實際操作：結合實際專案需求使用相關文件\n回饋改進：在使用過程中記錄問題與改進建議\n知識分享：將使用經驗回饋到文件改進中\n\n維護與更新機制\n內容審查週期\n\n月度審查：檢查文件的時效性與準確性\n季度更新：根據技術發展更新相關內容\n年度重構：重新評估文件架構與組織方式\n\n品質控制流程\n內容創建 → 技術審查 → 安全檢查 → 格式驗證 → 發布上線 → 使用回饋 → 持續改進\n\n貢獻機制\n\n問題回報：透過標準化流程回報文件問題\n改進建議：提供文件內容與結構的改進意見\n新文件貢獻：按照標準模板貢獻新的技術文件\n專家審查：邀請相關領域專家進行內容審查\n\n未來發展規劃\n短期目標（1-3個月）\n\n完善現有文件的標準化格式\n建立自動化的文件品質檢查機制\n增加更多實用的技術操作指南\n\n中期目標（3-6個月）\n\n建立文件間的智能關聯推薦系統\n發展基於AI的文件內容自動生成工具\n建立社群驅動的文件貢獻機制\n\n長期願景（6-12個月）\n\n形成行業標準的技術文件管理模式\n建立技術知識的智能化檢索與推薦系統\n發展跨組織的技術文件協作平台\n\n統計數據\n文件覆蓋範圍\n系統管理：35% (涵蓋Windows、Linux基礎操作)\n開發流程：40% (包含Git、CI/CD、代碼品質、Monorepo)\n部署運維：20% (GitHub Pages、容器化部署)\n工具配置：5% (開發環境、效能分析工具)\n\n使用統計\n\n總文件數量：16+篇\n月度檢視：200+次\n用戶回饋滿意度：90%+\n文件更新頻率：每週2-3次\n\n\n核心價值：提供實用、準確、及時的技術文件，支援高效的技術工作流程，並確保知識的有效傳承與積累。\n使用原則：文件是為了解決實際問題，而不是展示技術知識的複雜性。\n維護責任：PekoraTech SA Team - Documentation &amp; Standards\n品質目標：實用性優於完整性，準確性優於複雜性\n最後更新：2025-07-26"},"doc/os-control/index":{"slug":"doc/os-control/index","filePath":"doc/os-control/index.md","title":"作業系統控制","links":["doc/os-control/windows-directory-mirroring","GitHub-開發者精要指南","GitHub-Pages-自動部署-SOP","專案架構設計模式","VS-Code-開發環境設定","Git-配置優化","Terminal-效率提升","tags/作業系統","tags/系統管理","tags/Windows","tags/Linux","tags/macOS","tags/自動化","tags/腳本","tags/檔案系統","tags/權限管理","tags/開發環境"],"tags":["作業系統","系統管理","自動化","Windows","Linux","macOS","腳本","檔案系統","權限管理","開發環境"],"content":"作業系統控制技術 ⚙️\n\n跨平台系統管理與開發環境優化的核心技術\n\n🎯 技術範疇\n專注於作業系統層級的控制技術，提升開發效率與環境一致性。\n設計原則\n\nKISS 原則：保持簡潔，避免過度工程\n第一性原理：理解底層機制而非死記指令\n跨平台思維：考慮不同系統的相容性方案\n自動化優先：可重複執行的腳本化操作\n\n📂 技術分類\n🔗 檔案系統管理\nWindows 平台\n\n目錄鏡像技術\n\n符號連結 (Symbolic Link) 實作\n接合點 (Junction) 替代方案\n多電腦開發環境統一\n自動化批次檔案範例\n\n\n\nLinux/macOS 平台\n\n軟連結管理（計劃中）\n\nln -s 符號連結最佳實踐\n相對路徑與絕對路徑策略\n跨檔案系統連結考量\n\n\n\n🚀 程序與服務管理\nWindows 服務\n\n服務自動化管理（計劃中）\n\nsc 指令進階應用\nPowerShell 服務腳本\n開發環境服務編排\n\n\n\n系統程序\n\n程序監控與控制（計劃中）\n\ntasklist/taskkill 自動化\n記憶體使用監控\n效能瓶頸識別\n\n\n\n🔐 權限與安全\n存取控制\n\n檔案權限管理（計劃中）\n\nWindows ACL 設定\nLinux chmod/chown 最佳實踐\n安全性與便利性平衡\n\n\n\n環境隔離\n\n沙盒與容器技術（計劃中）\n\nWindows Sandbox 應用\nDocker 環境隔離\n開發環境污染防護\n\n\n\n🌐 網路與連線\n網路診斷\n\n連線問題排除（計劃中）\n\nping/tracert 深度分析\nnetstat 連線監控\n防火牆規則管理\n\n\n\n遠端存取\n\n遠端控制技術（計劃中）\n\nSSH 金鑰管理\nRDP 最佳化設定\nVPN 自動化連線\n\n\n\n🛠️ 實用工具集\n批次處理腳本\n📁 scripts/\n├── 📄 setup-dev-env.bat        # 開發環境快速設定\n├── 📄 cleanup-temp.bat         # 暫存檔案清理\n├── 📄 backup-projects.bat      # 專案檔案備份\n└── 📄 network-diagnostics.bat  # 網路問題診斷\n\nPowerShell 模組\n📁 powershell/\n├── 📄 FileSystemUtils.psm1     # 檔案系統操作\n├── 📄 ServiceManager.psm1      # 服務管理\n├── 📄 NetworkTools.psm1        # 網路工具\n└── 📄 SecurityUtils.psm1       # 安全性工具\n\n🎨 最佳實踐模式\n腳本設計原則\n\n錯誤處理：詳細的錯誤訊息與復原機制\n參數驗證：輸入參數的完整性檢查\n日誌記錄：操作過程的可追蹤記錄\n向後相容：考慮不同系統版本的相容性\n\n自動化策略\n\n冪等性：重複執行不會產生副作用\n原子性：要麼完全成功，要麼完全失敗\n可回復性：提供還原機制或回滾操作\n測試優先：在安全環境中驗證腳本\n\n🔄 相關技術連結\n開發流程整合\n\nGitHub 開發者精要指南：版本控制與系統整合\nGitHub Pages 自動部署 SOP：CI/CD 與系統自動化\n專案架構設計模式：系統層級的專案組織\n\n工具配置\n\nVS Code 開發環境設定：編輯器與系統整合\nGit 配置優化：版本控制系統設定\nTerminal 效率提升：命令列工具優化\n\n📊 技術成熟度\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n技術領域完成度優先級預計完成Windows 檔案系統✅ 100%🔥 高已完成Linux 檔案系統📝 0%🔥 高2025-07-15程序管理📝 0%⚡ 中2025-07-30網路診斷📝 0%⚡ 中2025-08-15安全管理📝 0%💡 低2025-09-01\n🚀 學習路徑建議\n初學者路徑\n\n\n檔案系統基礎\n\n理解絕對路徑與相對路徑\n掌握基本檔案操作指令\n學習權限概念\n\n\n\n自動化入門\n\n撰寫簡單的批次檔案\n理解環境變數的使用\n學習基本的錯誤處理\n\n\n\n實際應用\n\n建立個人開發環境腳本\n設定常用工具的自動化\n整合到日常工作流程\n\n\n\n進階學習\n\n\n跨平台技能\n\n掌握 Windows/Linux/macOS 差異\n學習通用的腳本設計模式\n理解不同系統的限制\n\n\n\n企業級應用\n\n大規模部署腳本設計\n安全性與合規性考量\n監控與維護策略\n\n\n\n💡 實戰案例\n開發環境標準化\n問題：團隊成員使用不同的開發環境配置\n解決：建立統一的環境設定腳本\nREM 範例：開發環境快速設定\n@echo off\necho 設定統一開發環境...\n \nREM 建立標準目錄結構\nmkdir D:\\PD_DEV\nmkdir D:\\PD_DEV\\projects\nmkdir D:\\PD_DEV\\tools\nmkdir D:\\PD_DEV\\temp\n \nREM 設定環境變數\nsetx DEV_ROOT &quot;D:\\PD_DEV&quot;\nsetx PATH &quot;%PATH%;D:\\PD_DEV\\tools&quot;\n \necho 開發環境設定完成！\n專案備份自動化\n問題：手動備份容易遺忘且不一致\n解決：自動化備份腳本與排程\nREM 範例：專案自動備份\n@echo off\nset BACKUP_DIR=E:\\Backup\\%date:~0,10%\nmkdir &quot;%BACKUP_DIR%&quot;\n \nrobocopy &quot;D:\\PD_DEV&quot; &quot;%BACKUP_DIR%&quot; /MIR /XD .git node_modules\necho 備份完成：%BACKUP_DIR%\n🏷️ 相關標籤\n作業系統 系統管理 Windows Linux macOS 自動化 腳本 檔案系統 權限管理 開發環境\n\n📝 更新記錄\nv1.0.0 (2025-07-05)\n\n✨ 建立作業系統控制技術分類架構\n📖 完成 Windows 目錄鏡像技術文檔\n🎯 規劃跨平台系統管理技術路線圖\n💡 提供學習路徑與實戰案例\n\n\n專注於實用的系統控制技術，提升開發效率與環境一致性"},"doc/os-control/windows-directory-mirroring":{"slug":"doc/os-control/windows-directory-mirroring","filePath":"doc/os-control/windows-directory-mirroring.md","title":"Windows 目錄鏡像技術","links":["批次處理自動化","開發環境標準化","備份策略優化","tags/Windows","tags/符號連結","tags/開發環境","tags/路徑管理","tags/自動化","tags/批次處理","tags/檔案系統","tags/Junction","tags/Symlink"],"tags":["Windows","符號連結","開發環境","路徑管理","自動化","批次處理","檔案系統","Junction","Symlink"],"content":"Windows 目錄鏡像技術 🔗\n\n透過符號連結技術實現跨電腦統一路徑管理的最佳實踐\n\n🎯 問題背景\n多電腦開發困境\n在多台電腦間進行開發時，常遇到以下問題：\n\n路徑不一致：不同電腦習慣使用不同磁碟機（C:、D:、E:、G:）\n腳本失效：絕對路徑導致批次檔案無法通用\n配置複雜：每台電腦都需要重新設定開發環境路徑\n協作困難：團隊成員無法使用統一的專案路徑\n\n解決方案概覽\nWindows 提供兩種「目錄鏡像」技術：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n技術類型權限需求功能特性適用場景符號連結 (Symbolic Link)管理員功能完整，支援相對路徑正式環境部署接合點 (Junction)一般使用者僅支援絕對路徑，資料夾專用日常開發使用\n💡 實作原理\n符號連結運作機制\n實際檔案位置：G:\\PD_DEV\\project-name\\\n鏡像存取路徑：D:\\PD_DEV\\project-name\\  ←→  G:\\PD_DEV\\project-name\\\n                    ↑                           ↑\n                符號連結指向              實際檔案儲存\n\n技術優勢\n\n透明存取：應用程式無法區分真實路徑與鏡像路徑\n即時同步：修改任一路徑下的檔案都會立即反映\n空間節省：不會複製檔案，僅建立指向關係\n效能優異：存取速度與直接存取相同\n\n🛠️ 實作步驟\n第一步：批次檔案準備\n為了自動化處理不同電腦的路徑映射，建立以下批次檔案：\n主電腦版本（G:\\PD_DEV → D:\\PD_DEV）\n@echo off\necho 設定開發資料夾映射\necho.\n \nREM 檢查是否以管理員身分執行\nnet session &gt;nul 2&gt;&amp;1\nif %errorLevel% == 0 (\n    echo 以管理員身分執行中...\n) else (\n    echo 警告：建議以管理員身分執行此批次檔案\n    echo.\n)\n \nREM 檢查目標資料夾是否存在\nif exist &quot;D:\\PD_DEV&quot; (\n    echo D:\\PD_DEV 已存在，請先備份或移除\n    pause\n    exit /b 1\n)\n \nREM 檢查來源資料夾\nif not exist &quot;G:\\PD_DEV&quot; (\n    echo 錯誤：來源資料夾 G:\\PD_DEV 不存在\n    pause\n    exit /b 1\n)\n \necho 建立符號連結：D:\\PD_DEV ---&gt; G:\\PD_DEV\necho.\n \nREM 建立目錄符號連結（需要管理員權限）\nmklink /D &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \nif %errorLevel% == 0 (\n    echo.\n    echo 成功建立符號連結！\n    echo 現在您可以透過 D:\\PD_DEV 存取 G:\\PD_DEV 的所有內容\n) else (\n    echo.\n    echo 符號連結建立失敗，嘗試建立接合點...\n    echo.\n \n    REM 如果符號連結失敗，嘗試建立接合點（不需要管理員權限）\n    mklink /J &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \n    if %errorLevel% == 0 (\n        echo 成功建立接合點！\n        echo 現在您可以透過 D:\\PD_DEV 存取 G:\\PD_DEV 的所有內容\n    ) else (\n        echo 建立失敗，請檢查權限或路徑\n    )\n)\n \necho.\necho 測試連結...\nif exist &quot;D:\\PD_DEV\\selfpagesource&quot; (\n    echo 測試成功：可以透過 D:\\PD_DEV 存取專案資料夾\n) else (\n    echo 測試失敗：無法透過 D:\\PD_DEV 存取專案資料夾\n)\n \npause\n副電腦版本（E:\\PD_DEV → D:\\PD_DEV）\n@echo off\necho 設定開發資料夾映射 (E: 版本)\necho.\n \nREM 檢查目標資料夾是否存在\nif exist &quot;D:\\PD_DEV&quot; (\n    echo D:\\PD_DEV 已存在，請先備份或移除\n    pause\n    exit /b 1\n)\n \nREM 檢查來源資料夾\nif not exist &quot;E:\\PD_DEV&quot; (\n    echo 錯誤：來源資料夾 E:\\PD_DEV 不存在\n    pause\n    exit /b 1\n)\n \necho 建立符號連結：D:\\PD_DEV ---&gt; E:\\PD_DEV\necho.\n \nREM 建立目錄符號連結\nmklink /D &quot;D:\\PD_DEV&quot; &quot;E:\\PD_DEV&quot;\n \nif %errorLevel% == 0 (\n    echo 成功建立符號連結！\n) else (\n    echo 符號連結建立失敗，嘗試建立接合點...\n    mklink /J &quot;D:\\PD_DEV&quot; &quot;E:\\PD_DEV&quot;\n \n    if %errorLevel% == 0 (\n        echo 成功建立接合點！\n    ) else (\n        echo 建立失敗，請檢查權限或路徑\n    )\n)\n \npause\n第二步：執行映射設定\n\n\n選擇對應的批次檔案\n\n主電腦：執行 setup_dev_mapping.bat\n副電腦：執行 setup_dev_mapping_E_drive.bat\n\n\n\n執行前準備\n# 檢查來源資料夾是否存在\ndir G:\\PD_DEV    # 主電腦\ndir E:\\PD_DEV    # 副電腦\n \n# 確認目標位置沒有衝突\ndir D:\\PD_DEV    # 應該顯示找不到檔案\n\n\n執行設定\n\n右鍵點擊批次檔案\n選擇「以系統管理員身分執行」\n按照提示完成設定\n\n\n\n第三步：驗證映射結果\n# 測試檔案存取\ndir D:\\PD_DEV\ndir D:\\PD_DEV\\selfpagesource\n \n# 檢查連結類型\ndir D:\\ | findstr PD_DEV\n# 應該顯示 &lt;SYMLINKD&gt; 或 &lt;JUNCTION&gt;\n \n# 測試檔案操作\necho test &gt; D:\\PD_DEV\\test.txt\ntype G:\\PD_DEV\\test.txt    # 主電腦\ntype E:\\PD_DEV\\test.txt    # 副電腦\ndel D:\\PD_DEV\\test.txt\n🔧 進階管理\n清理映射的批次檔案\n@echo off\necho 移除開發資料夾映射\necho.\n \nREM 檢查 D:\\PD_DEV 是否存在且為連結\nif not exist &quot;D:\\PD_DEV&quot; (\n    echo D:\\PD_DEV 不存在，無需移除\n    pause\n    exit /b 0\n)\n \nREM 檢查是否為符號連結或接合點\ndir &quot;D:\\PD_DEV&quot; | findstr &quot;&lt;SYMLINKD&gt;&quot; &gt;nul\nif %errorLevel% == 0 (\n    echo 偵測到符號連結\n    set LINK_TYPE=符號連結\n    goto remove_link\n)\n \ndir &quot;D:\\PD_DEV&quot; | findstr &quot;&lt;JUNCTION&gt;&quot; &gt;nul\nif %errorLevel% == 0 (\n    echo 偵測到接合點\n    set LINK_TYPE=接合點\n    goto remove_link\n)\n \necho D:\\PD_DEV 存在但不是符號連結或接合點\necho 為安全起見，不會刪除此資料夾\npause\nexit /b 1\n \n:remove_link\necho 即將移除 %LINK_TYPE%：D:\\PD_DEV\necho.\nset /p confirm=確定要繼續嗎？(Y/N):\nif /i not &quot;%confirm%&quot;==&quot;Y&quot; (\n    echo 操作取消\n    pause\n    exit /b 0\n)\n \nREM 移除符號連結或接合點\nrmdir &quot;D:\\PD_DEV&quot;\n \nif %errorLevel% == 0 (\n    echo 成功移除 %LINK_TYPE%\n) else (\n    echo 移除失敗，請檢查權限\n)\n \npause\n常用管理指令\n# 查看所有符號連結\ndir C:\\ /AL\ndir D:\\ /AL\n \n# 查看特定目錄的連結資訊\nfsutil reparsepoint query &quot;D:\\PD_DEV&quot;\n \n# 手動建立符號連結\nmklink /D &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \n# 手動建立接合點\nmklink /J &quot;D:\\PD_DEV&quot; &quot;G:\\PD_DEV&quot;\n \n# 手動移除連結\nrmdir &quot;D:\\PD_DEV&quot;\n⚠️ 注意事項與最佳實踐\n安全考量\n\n備份重要資料：設定前先備份現有的 D:\\PD_DEV（如果存在）\n權限管理：符號連結需要管理員權限，接合點則不需要\n路徑驗證：確保來源路徑存在且可存取\n\n使用限制\n\nWindows 版本：Windows Vista 以上支援符號連結\n檔案系統：目標磁碟機必須使用 NTFS 檔案系統\n網路位置：不建議對網路磁碟機使用符號連結\n\n故障排除\n常見錯誤及解決方案\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n錯誤訊息可能原因解決方法存取被拒權限不足以管理員身分執行目標已存在D:\\PD_DEV 已存在先移除或重新命名現有資料夾找不到來源來源路徑不存在確認 G: 或 E: 磁碟機路徑正確不支援的檔案系統FAT32 檔案系統轉換為 NTFS 或使用其他磁碟機\n🎯 實際應用場景\n開發環境統一\n情境：三台電腦的不同配置\n- 主機：G:\\PD_DEV\\project-name\\\n- 筆電：E:\\PD_DEV\\project-name\\\n- 公司：C:\\PD_DEV\\project-name\\\n\n解決：統一使用 D:\\PD_DEV\\project-name\\\n\n腳本通用性\nREM 原本：需要針對每台電腦修改路徑\ncd G:\\PD_DEV\\selfpagesource    REM 主機\ncd E:\\PD_DEV\\selfpagesource    REM 筆電\ncd C:\\PD_DEV\\selfpagesource    REM 公司\n \nREM 現在：所有電腦使用相同腳本\ncd D:\\PD_DEV\\selfpagesource    REM 通用\n配置檔案同步\n// VS Code settings.json 可以使用統一路徑\n{\n  &quot;terminal.integrated.cwd&quot;: &quot;D:\\\\PD_DEV&quot;,\n  &quot;git.defaultCloneDirectory&quot;: &quot;D:\\\\PD_DEV&quot;\n}\n🔄 相關技術比較\nWindows 檔案系統功能對比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n功能符號連結接合點硬連結快捷方式需要管理員權限✅❌❌❌支援資料夾✅✅❌✅支援檔案✅❌✅✅跨磁碟機✅✅❌✅透明存取✅✅✅❌相對路徑✅❌N/A❌\n選擇建議\n\n優先選擇：符號連結（功能最完整）\n備選方案：接合點（無需管理員權限）\n避免使用：快捷方式（應用程式支援度差）\n\n📚 延伸學習\n相關命令深入\n# mklink 完整語法\nmklink [[/d] | [/h] | [/j]] &lt;連結&gt; &lt;目標&gt;\n/d    建立目錄符號連結（預設為檔案）\n/h    建立硬連結而非符號連結\n/j    建立目錄接合點\n \n# fsutil 連結管理\nfsutil reparsepoint query &lt;路徑&gt;      # 查詢連結資訊\nfsutil reparsepoint delete &lt;路徑&gt;     # 刪除連結點\n進階應用\n\n批次處理自動化：結合 PowerShell 進行大量路徑映射\n開發環境標準化：團隊協作的路徑規範制定\n備份策略優化：利用符號連結簡化備份腳本\n\n🏷️ 相關標籤\nWindows 符號連結 開發環境 路徑管理 自動化 批次處理 檔案系統 Junction Symlink\n\n📝 更新記錄\nv1.0.0 (2025-07-05)\n\n✨ 建立 Windows 目錄鏡像技術完整指南\n🔧 提供自動化批次檔案實作\n📖 涵蓋符號連結與接合點技術對比\n⚠️ 詳細的注意事項與故障排除\n🎯 實際開發場景應用範例\n\n\n本文檔旨在解決多電腦開發環境路徑統一問題，提供可直接執行的自動化解決方案"},"doc/project-documentation-guide":{"slug":"doc/project-documentation-guide","filePath":"doc/project-documentation-guide.md","title":"SelfPageSource 技術文件化專案","links":["doc/","projects/","daily-code/","component/","component/ai-long-term-memory-system"],"tags":["技術文件","系統分析","知識管理"],"content":"SelfPageSource 技術文件化專案\n\n透過系統分析師視角，將專案理解轉換為可持續的開發歷程文件\n\n專案核心理念\n第一性原理思考\n\n資訊整理本質：從零散經驗提煉出可重複利用的知識體系\n知識傳承需求：將個人經驗轉化為團隊可共享的標準化文件\n安全平衡策略：在開放分享與創新保護之間找到最佳平衡點\n\nKISS原則與高內聚低耦合\n\n採用Quartz 4.0作為靜態網站生成器，避免重新造輪子\n內容組織遵循功能分離，各模組職責明確\n自動化流程減少人工干預，專注於內容創作\n\n內容架構導覽\n技術文件中心\n\n標準化技術文件與操作程序\n\n功能定位：補齊技術資料的標準化文件庫\n適用場景：技術操作標準程序、系統配置、開發工具指南、架構設計文件\n文件特性：結構化內容、版本控制、標準格式\n專案建置項目\n\n專案主軸建置文件，支援多專案共存管理\n\n功能定位：專案理解與分析的標準化記錄\n管理原則：專案間關係明確標示、建置流程標準化、專案狀態可追蹤\n安全機制：技術方法可公開，實作細節選擇性公開，創新核心嚴格保密\n時間分割內容\n\n以時間軸組織的日常開發記錄\n\n功能定位：日常開發經驗的系統化記錄\n重要原則：commit細寫記錄開發細節，對外文件需過濾敏感資訊\nMCP整合：透過claude或gemini cli自動整合每日內容\n可重用元件庫\n\n從歷史創作中萃取有價值的可重用元件\n\n功能定位：長遠計劃，建立技術資產庫\n價值體現：減少重複開發、提升開發效率、形成個人技術標準\n智財保護：展示思考過程，保護實作細節\n最新元件：AI長期記憶系統 - 可應用於Helpdesk、客服系統\n系統分析師工作流程\n專案理解階段\n\n讀取README.md：理解專案原始設計與目標\n架構分析：識別技術棧與依賴關係\n流程梳理：分析開發與部署流程\n問題識別：發現潛在風險與改進點\n\n文件轉換階段\n\n內容分類：依據功能特性分配至適當目錄\n標準化處理：統一文件格式、命名規則、標籤系統\n安全審查：識別敏感內容、應用保密策略、確保合規發布\n\n持續維護階段\n\n定期回顧：文件有效性檢查、技術棧更新同步、流程優化改進\n價值萃取：識別可重用元件、建立最佳實踐、形成技術標準\n\n安全與保密機制\n分級公開策略\n\n技術方法層級：可公開分享，促進技術交流\n實作細節層級：選擇性公開，保護競爭優勢\n創新核心層級：嚴格保密，維護智財價值\n\n自動化檢查流程\n\n關鍵字過濾機制\n敏感內容標記系統\n發布前審查程序\n\n技術架構\n核心技術棧\n\nQuartz 4.0：靜態網站生成器\nNode.js：執行環境\nTypeScript：類型安全開發\nGitHub Pages：免費網站託管\n\n自動化流程\n專案分析 → 內容分類 → 標準化處理 → 安全審查 → 自動發布\n\n開發指令\n常用操作\n# 開發模式\nnpm run dev              # 本地開發：http://localhost:8080\n \n# 建置與預覽\nnpm run build-static     # 建置靜態檔案\nnpm run preview          # 靜態預覽：http://localhost:3000\n \n# 代碼品質\nnpm run check            # 格式檢查\nnpm run format           # 自動格式化\n \n# 發布流程\nnpm run format &amp;&amp; git add . &amp;&amp; git commit -m &quot;類型: 描述&quot; &amp;&amp; git push origin main\n持續改進計劃\n短期目標\n\n完善MCP自動化工作流程\n建立敏感內容自動檢測機制\n優化文件分類與檢索系統\n\n中期目標\n\n建立技術元件標準化流程\n發展智財保護自動化工具\n形成可複製的SA工作模式\n\n長期願景\n\n建立行業標準的技術文件化流程\n發展開源與商業平衡的最佳實踐\n形成系統分析師專業工具鏈\n\n貢獻原則\n提交規範\nfeat: 新增功能或內容\ndocs: 文件更新\nfix: 問題修正\nstyle: 格式調整\nrefactor: 架構重構\nsecurity: 安全相關更新\n品質標準\n\n遵循第一性原理思考\n確保高內聚低耦合設計\n通過安全審查機制\n符合專業文件規範\n\n\n專案目標：建立符合系統分析師工作流程的技術文件化平台，平衡知識分享與創新保護，實現可持續的技術資產積累。\n維護團隊：PekoraTech SA Team\n最後更新：2025-01-09\n安全等級：公開（已過濾敏感內容）"},"doc/圖片管理指南":{"slug":"doc/圖片管理指南","filePath":"doc/圖片管理指南.md","title":"圖片管理指南","links":[],"tags":[],"content":"📸 圖片管理指南\n\n內部技術文件 - 圖片資源標準化管理方案\n最後更新：2025-07-06 v1.0\n\n🗂️ 資料夾結構\ncontent/\n├── assets/                          # 靜態資源根目錄\n│   └── images/                      # 圖片資源\n│       ├── ai-tools/               # AI工具領域圖片\n│       │   ├── test-ai-memory/     # test-ai-memory專案圖片\n│       │   └── [其他AI專案]/\n│       ├── development-tools/       # 開發工具領域圖片\n│       │   ├── calu-app/           # calu-app專案圖片\n│       │   └── [其他開發工具]/\n│       ├── browser-extensions/      # 瀏覽器擴展領域圖片\n│       ├── game-systems/           # 遊戲系統領域圖片\n│       ├── mobile-development/     # 移動開發領域圖片\n│       └── common/                 # 通用圖片資源\n└── projects/                       # 專案文檔\n    ├── ai-tools/\n    │   └── test-ai-memory.md      # 在這裡引用圖片\n    └── ...\n\n🖼️ 複製貼上圖片的標準流程\n方法一：VSCode + Paste Image 擴展 (推薦)\n\n\n安裝VSCode擴展\n\n安裝 “Paste Image” 擴展\n設定圖片存放路徑\n\n\n\nVSCode設定檔配置 (settings.json)\n{\n  &quot;pasteImage.basePath&quot;: &quot;${workspaceRoot}/content/assets/images&quot;,\n  &quot;pasteImage.path&quot;: &quot;${workspaceRoot}/content/assets/images/${fileBasenameNoExtension}&quot;,\n  &quot;pasteImage.namePrefix&quot;: &quot;&quot;,\n  &quot;pasteImage.nameSuffix&quot;: &quot;&quot;,\n  &quot;pasteImage.insertPattern&quot;: &quot;![${imageFileName}](${imageFilePath})&quot;\n}\n\n\n使用流程\n\n複製圖片到剪貼板 (Cmd+C)\n在Markdown檔案中按 Cmd+Shift+V\n自動產生相對路徑連結\n\n\n\n方法二：手動管理 (精確控制)\n\n\n圖片命名規則\n{專案名稱}-{功能描述}-{序號}.{副檔名}\n\n範例：\ntest-ai-memory-architecture-01.png\ntest-ai-memory-demo-screenshot-02.png\ntest-ai-memory-api-swagger-03.png\n\n\n\n存放位置\n專案：test-ai-memory.md\n圖片：assets/images/ai-tools/test-ai-memory/\n\n\n\nMarkdown引用語法\n![圖片描述](../../assets/images/ai-tools/test-ai-memory/test-ai-memory-demo-01.png)\n\n\n🌐 網頁生成時的路徑處理\n相對路徑最佳實踐\n從專案文檔到圖片的路徑計算：\n專案文檔位置：content/projects/ai-tools/test-ai-memory.md\n圖片位置：    content/assets/images/ai-tools/test-ai-memory/demo.png\n相對路徑：    ../../assets/images/ai-tools/test-ai-memory/demo.png\n\n路徑計算公式：\n\n從 projects/{domain}/{project}.md\n到 assets/images/{domain}/{project}/image.png\n需要 ../../assets/images/{domain}/{project}/image.png\n\n靜態網站生成器相容性\nHugo/Jekyll/Gatsby等靜態生成器\n\n✅ 相對路徑在大多數情況下都能正常工作\n✅ assets/ 資料夾通常會被複製到網站根目錄\n✅ 圖片URL會變成 /assets/images/...\n\n注意事項\n\n確保圖片檔案小於5MB (網頁載入速度)\n使用WebP格式獲得更好的壓縮率\nPNG用於截圖，JPG用於照片\n\n📋 操作範例\n為test-ai-memory添加圖片\n\n\n複製原有圖片\n# 複製現有圖片到新結構\ncp /Volumes/Code/test-ai-memory/image/README/*.png \\\n   /Volumes/Code/selfpagesource/content/assets/images/ai-tools/test-ai-memory/\n\n\n重命名圖片\n# 建議重命名為有意義的檔名\n1748791353245.png → test-ai-memory-chrome-extension-demo.png\n1748791598366.png → test-ai-memory-popup-interface.png\n1751793762521.png → test-ai-memory-streamlit-interface.png\n\n\n更新Markdown引用\n# 原始引用\n \n![1748791353245](image/README/1748791353245.png)\n \n# 新的引用\n \n![Chrome擴展demo](../../assets/images/ai-tools/test-ai-memory/test-ai-memory-chrome-extension-demo.png)\n\n\n🔧 自動化工具建議\n建立圖片處理腳本\n#!/bin/bash\n# 檔案：scripts/optimize-images.sh\n \n# 壓縮圖片\nfind content/assets/images -name &quot;*.png&quot; -exec pngquant --force --ext .png {} \\;\n \n# 轉換為WebP格式\nfind content/assets/images -name &quot;*.png&quot; -exec cwebp {} -o {}.webp \\;\n \n# 產生圖片清單\nfind content/assets/images -type f &gt; assets/image-inventory.txt\nVSCode工作區設定\n{\n  &quot;folders&quot;: [\n    {\n      &quot;path&quot;: &quot;/Volumes/Code/selfpagesource/content&quot;\n    }\n  ],\n  &quot;settings&quot;: {\n    &quot;pasteImage.defaultName&quot;: &quot;Y-MM-DD-HH-mm-ss&quot;,\n    &quot;pasteImage.path&quot;: &quot;${workspaceRoot}/assets/images/${fileBasenameNoExtension}&quot;,\n    &quot;markdown.copyFiles.destination&quot;: {\n      &quot;**/*&quot;: &quot;assets/images/${documentBaseName}/&quot;\n    }\n  }\n}\n🎯 最佳實踐原則\n\n\n命名規範\n\n使用英文和數字\n用連字符 - 分隔單詞\n包含專案名稱前綴\n\n\n\n檔案大小控制\n\n截圖：&lt;500KB\n示意圖：&lt;200KB\n考慮使用WebP格式\n\n\n\n組織原則\n\n按專案分類存放\n與文檔結構保持一致\n定期清理無用圖片\n\n\n\n網頁相容性\n\n使用相對路徑\n確保圖片alt text描述\n考慮響應式設計\n\n\n\n⚠️ 注意事項\n\n不要使用絕對路徑 /Volumes/Code/...\n不要使用中文檔名\n不要放置過大的圖片檔案\n確保圖片版權清晰\n定期檢查圖片連結有效性\n\n\n遵循此指南，確保圖片管理的系統性、一致性和可維護性。"},"index":{"slug":"index","filePath":"index.md","title":"PekoraTech 🚀 技術知識庫","links":["navigation/","projects/","daily-code/","doc/","projects/ai-tools/","projects/ai-tools/test-helper-memory-system","projects/ai-tools/help-agnet","projects/ai-tools/test-ai-memory","projects/development-tools/","projects/development-tools/calu-app-gradio-toolkit","projects/development-tools/workflow-builder","projects/mobile-development/","projects/mobile-development/test-ai-image","projects/mobile-development/calorie-tracker-app","projects/mobile-development/confluence-note","projects/mobile-development/smart-map","tags/Memory","tags/Flutter","tags/Gradio","tags/Python","tags/Docker","tags/微服務","tags/HelpAgent","tags/PekoraProject","tags/Workflow"],"tags":["首頁","技術","開發者","Memory","Flutter","Gradio","Python","Docker","微服務","HelpAgent","PekoraProject","Workflow"],"content":"Welcome to PekoraTech 🎯\n\n“專精收斂而非擴散” - 從第一性原理思考，專注於深度而非廣度的技術探索\n\n\n  🧭 快速導航\n  \n    📚 完整網站導航 | \n    📁 技術專案 | \n    📝 開發筆記 | \n    📊 技術文件\n  \n\n\n  \n  \n  \n  \n\n🎯 淬煉之道\n🔥 技術淬煉精神\n\n  \n    \n    \n  \n  \n    🔨 『鉄打ち唄』- 如鐵匠打鐵般，透過不斷錘鍊淬煉出技術的真諦\n  \n\n\n  📜 展開淬煉之歌 (點擊查看歌詞)\n   \n  \n    昏黃夜空伴爐星\n    進生火光拭夜色\n    重鎚起舞鐵笙歌\n    鏗鏘起落皆有聲\n    汝為利刃為力量\n    產自大地\n    焚木燃火\n    鍛金沈水\n    世界流轉又停滯\n    求金成鐵\n    求鐵成鋼\n    自鋼生刃\n    刃化為劍\n    黎明天邊閃劍芒\n    燦爛映輝斬黑暗\n    劍舞歌傳唱\n    致世界 生生不息\n    ✨ 每一次技術的錘鍊，都是向完美的進化\n  \n\n\n“程式如鐵，需經千錘百鍊；思維如火，需持恆不斷燃燒”\n正如鐵匠以汗水與執著鍛造精鋼，我們以代碼與思考淬煉技術。每一行程式都是一次錘打，每一個bug都是一次回火，每一次重構都是一次精煉。\n\n🧠 第一性原理思考\ngraph LR\n    A[技術需求] --&gt; B[深度分析]\n    B --&gt; C[創新實作]\n    C --&gt; D[價值產出]\n    D --&gt; E[知識沈澱]\n    E --&gt; A\n\n    style A fill:#ff6b6b\n    style C fill:#4ecdc4\n    style E fill:#96ceb4\n\n\n需求本質：從真實問題出發，不為技術而技術\n技術選擇：KISS原則 - 簡單有效 &gt; 複雜炫技\n架構設計：高內聚低耦合，可維護可擴展\n持續驗證：快速迭代，實踐檢驗理論\n\n\n🗂️ 技術專案導覽\n🤖 AI工具鏈 - 人工智慧實踐領域\n\n探索AI技術在實際應用中的深度整合與創新突破\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n專案技術棧創新點狀態AI客服記憶系統Python + FastAPI + OpenAI記憶系統轉化客服平台🧪 實驗Help Agent智能助手React + TS + Docker企業級智能客服🚧 開發中AI長期記憶系統Python + 微服務AI情感與記憶機制🟢 活躍\n核心突破：\n\n🧠 長期記憶機制：突破AI無狀態限制，實現持續學習\n🤝 情感計算模式：從功能型AI到陪伴型AI的轉變\n🔧 實用化整合：將AI能力包裝為實際可用的工具\n\n🛠️ 開發工具 - 效率提升實踐\n\n通過工具創新提升開發效率，探索新技術整合模式\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n專案技術棧創新點狀態Gradio工具包Python + Gradio + DockerAI工具快速原型開發✅ 完成工作流建構器Node.js + API自動化流程設計🚧 開發中\n技術價值：\n\n⚡ 快速原型：Gradio + AI的完整整合方案\n🐳 容器化實踐：Docker標準化部署流程\n🔄 自動化思維：從手動到自動的效率革命\n\n📱 移動開發 - 跨平台創新\n\nFlutter + AI的深度融合，探索移動端AI應用新形態\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n專案技術棧創新點狀態佩可拉AI女友生態Flutter + 多模態AI圖片到人格轉換技術🔵 實驗突破卡路里追蹤器Flutter + SQLite + Camera拍照記錄食物管理🟢 活躍結構化筆記系統Flutter + 本地認證人事時地物五維筆記🟢 活躍智能思維地圖Flutter + OpenAI APIAI驅動思維整理🟢 活躍\n革命性突破：\n\n🖼️ 視覺驅動人格：從圖片分析構建AI人格的創新技術\n💕 情感計算系統：AI長期記憶與情感發展機制\n🎨 多模態協作：圖像分析 + 對話生成 + 圖片創作的三重AI協作\n\n\n💡 技術棧深度實踐\n核心技術能力\n\n  🤖 AI/ML 深度整合\n  🐍 Python 系統開發\n  📱 Flutter 跨平台\n  ⚡ FastAPI 微服務\n  🎨 Gradio 快速原型\n  🧠 本地AI整合\n  🐳 Docker 容器化\n\n技術創新統計\n📊 活躍專案：14 個技術實驗與實用工具\n🔥 核心領域：AI整合、工具開發、移動應用\n🎯 技術深度：\n   • AI記憶系統：長期記憶與情感計算\n   • 多模態AI：圖像+對話+生成的協作模式\n   • 微服務架構：可擴展的分散式系統設計\n   • Flutter生態：跨平台移動應用開發\n🎆 突破性創新：\n   • 佩可拉計畫：視覺驅動的AI人格建構\n   • AI客服系統：記憶系統向實用化轉換\n   • Gradio工具包：AI能力快速產品化\n   • 移動AI應用：Flutter + AI的深度融合\n\n\n🎨 知識探索方式\n🔍 智能導航\n使用頂部搜尋框進行：\n\n技術關鍵字搜尋：Python、AI、Flutter、微服務\n專案名稱查找：快速定位感興趣的技術專案\n開發經驗檢索：查找特定技術的實踐心得\n\n🏷️ 標籤體系\n按技術領域探索：\n#AI Memory Flutter Gradio Python Docker 微服務 HelpAgent PekoraProject Workflow\n📊 技術關係圖譜\n通過關係圖發現：\n\n技術專案間的依賴關係\n相似技術方案的對比\n技術演進的完整脈絡\n\n\n💡 核心技術哲學\n🎯 KISS實踐原則\n\n保持簡單，但不簡陋\n\n\n技術選型：選擇最適合而非最炫的技術\n架構設計：優雅簡潔勝過複雜精巧\n代碼實作：可讀性和可維護性優先\n功能設計：解決實際問題，不製造問題\n\n🧠 第一性原理應用\n\n從本質思考，避免路徑依賴\n\n\n需求分析：挖掘真實需求背後的本質問題\n技術評估：基於原理判斷而非流行趨勢\n方案設計：從基礎原理構建而非拼湊現有方案\n優化改進：回歸本質找到真正的改進方向\n\n🏗️ 高內聚低耦合實踐\n\n系統化思維，模組化實作\n\n技術架構設計:\n├─ 功能模組：單一職責，高度內聚\n├─ 介面設計：清晰邊界，低耦合依賴\n├─ 數據流向：明確可追蹤的資料流\n└─ 錯誤處理：優雅降級，系統穩定性\n\n\n🚀 技術發展動態\n📈 當前焦點\n\n🤖 AI記憶系統商業化：將研究成果轉化為實用產品\n🐰 佩可拉計畫第二階段：多角色支援與VR整合探索\n🛠️ 工具鏈標準化：提取可重用的技術組件\n📋 自動化文檔系統：基於MCP的智能文檔生成\n\n🔮 技術探索方向\n\n🧠 邊緣AI計算：本地化AI部署與隱私保護\n🎮 虛擬現實整合：AI與VR的深度融合體驗\n⚡ 實時AI協作：多AI系統的即時協作機制\n🌐 分散式AI架構：可擴展的AI服務網路\n\n📅 近期成果\n\n2025-01：新增三個Flutter專案，移動開發生態完善\n2024-12：AI記憶系統架構成熟，多專案驗證\n2024-11：Gradio工具包完成，Docker標準化\n\n\n🎪 技術創新亮點\n🌟 原創性突破\n🔬 多模態AI協作架構\n首創技術：圖像分析 + 人格建構 + 對話生成 + 圖片創作的四重AI協作\n視覺輸入 → 特徵分析 → 人格映射 → 情感計算 → 智能回應 → 視覺輸出\n\n🧠 AI長期記憶機制\n技術突破：突破無狀態AI限制，實現持續學習與情感發展\n\n分層記憶架構：短期、中期、長期記憶分離管理\n情感關聯模式：記憶與情感狀態的動態關聯\n人格一致性：長期交互中保持AI人格穩定性\n\n🎨 視覺驅動人格建構\n創新概念：從圖片分析直接構建AI人格特質\n\n視覺特徵提取：外貌、表情、場景、風格分析\n性格推理引擎：基於視覺線索推斷人格特質\n記憶植入機制：將分析結果轉化為AI記憶系統\n\n🛠️ 實用化工程\n⚡ Gradio + AI標準整合模式\n工程價值：建立了快速AI工具開發的標準流程\n\n零前端開發：Python開發者直接創建Web工具\nAI能力包裝：將複雜AI功能包裝為簡單界面\n容器化部署：標準化的Docker部署方案\n\n🔄 微服務AI架構\n系統設計：分散式AI服務的協作模式\n\n服務解耦：圖像、對話、生成服務獨立部署\nAPI標準化：統一的AI服務調用介面\n彈性擴展：根據需求動態調整服務資源\n\n\n\n  🎯 野兔工程師的技術願景\n  \n    建立面向AI時代的深度技術實踐平台：\n    探索 → 實驗 → 淬煉 → 突破\n  \n  \n    &quot;在AI的浪潮中，我們不只是使用者，更是創造者。用代碼淬煉思維，用創新點亮技術。&quot;\n  \n\n\n📚 技術心得筆記\n\n日常開發中的技術發現與思考記錄，快速捕捉靈感與解決方案\n\n最新技術探索：\n\nAI系統整合實戰經驗\nFlutter跨平台開發踩坑記錄\nPython微服務架構設計心得\nDocker容器化最佳實踐總結\n\n\n🏆 技術成就與價值\n🌟 創新技術資產\n\n可重用AI組件：多個專案驗證的AI整合模式\n技術架構模板：經過實戰檢驗的系統設計範本\n最佳實踐指南：從失敗中總結的技術決策準則\n創新思維模式：第一性原理在技術領域的實際應用\n\n💎 技術影響力\n\nAI應用創新：推動AI從實驗室到實際應用的轉化\n開發效率提升：通過工具創新大幅提升開發體驗\n技術教育價值：為技術社群提供實戰參考案例\n行業標準貢獻：參與建立AI應用開發的最佳實踐\n\n\n最後更新：2025-01-20 | 維護者：PekoraTech 野兔工程師團隊 | 專案狀態：高度活躍\n💫 淬煉不止，創新不息。每一行代碼都是向技術完美的進化。"},"navigation/index":{"slug":"navigation/index","filePath":"navigation/index.md","title":"網站導航索引","links":["/","projects/","projects/ai-tools/","projects/development-tools/","projects/mobile-development/","projects/game-systems/","projects/browser-extensions/","doc/","daily-code/","innovation/","component/","projects/ai-tools/test-ai-memory","projects/ai-tools/test-ppt-page","projects/mobile-development/test-ai-image","projects/development-tools/calu-app-gradio-toolkit","tags/AI","tags/Memory","tags/Flutter","tags/Gradio","tags/Python","tags/Docker","tags/微服務","tags/MCP","tags/Slidev","doc/SA-project-mapping","doc/project-documentation-guide","doc/工作指南-v3.0"],"tags":["導航","索引","網站結構","AI","Memory","Flutter","Gradio","Python","Docker","微服務","MCP","Slidev"],"content":"🧭 PekoraTech 技術知識庫導航\n🏠 主要區域\n🎯 首頁\n\nPekoraTech 技術知識庫主頁 - 技術哲學、專案概覽、創新亮點\n\n🗂️ 專案技術檔案\n\n按技術領域分類的深度專案分析\n\n核心領域：\n\n🤖 AI工具鏈 - 人工智慧實踐領域\n🛠️ 開發工具 - 效率提升實踐\n📱 移動開發 - 跨平台創新\n🎮 遊戲系統 - 遊戲相關技術\n🌐 瀏覽器擴展 - 瀏覽器技術\n\n📚 技術文件中心\n\n標準化技術文件與操作程序\n\n📅 日常開發記錄\n\n時間軸組織的開發經驗與心得\n\n💡 創新實驗區\n\n前瞻性技術探索與概念驗證\n\n🧩 可重用組件庫\n\n從實踐中萃取的技術資產\n\n🔍 快速查找\n熱門專案\n\n🧠 AI長期記憶系統\n🎯 AI驅動PPT生成系統\n🖼️ AI女友生態系統\n⚡ Gradio工具包\n\n技術標籤\n\nAI Memory Flutter Gradio Python Docker 微服務 MCP Slidev\n\n內部文件（SA專用）\n\n📋 專案映射表\n📖 文檔化指南\n📝 工作指南\n\n\n🎨 使用建議\n🆕 新手入門\n\n從 首頁 了解技術哲學\n瀏覽 專案概覽 找感興趣的領域\n查看具體專案的技術實現\n\n🔍 深度研究\n\n利用技術標籤進行主題式探索\n參考 組件庫 了解可重用技術\n閱讀 日常記錄 獲得實戰心得\n\n💼 專業應用\n\n查看專案的技術棧和架構設計\n參考最佳實踐和踩坑經驗\n應用第一性原理思考模式\n\n\n🧭 此導航頁面幫助您快速定位所需內容，建議收藏以便隨時查閱"},"projects/ai-tools/help-agnet":{"slug":"projects/ai-tools/help-agnet","filePath":"projects/ai-tools/help-agnet.md","title":"Help-Agnet - 智能客服系統","links":[],"tags":["customer-service","ai-agent","full-stack","microservices"],"content":"Help-Agnet - 智能客服系統\n\n企業級智能客服平台，採用現代化微服務架構與 Function Calling 技術\n\n專案概述\n\n路徑：/Volumes/Code/test-helpdesk/help-agnet\n技術棧：Python FastAPI + React + TypeScript + OpenAI + LangChain\n狀態：開發中（架構先進但尚未成功運行）\n複雜度：企業級複雜系統\n領域：AI工具開發\n\n專案資料夾結構\nhelp-agnet/\n├── README.md                     # 完整系統文檔\n├── .env.example                  # 環境變數範例\n├── docker-compose.yml            # 容器編排配置\n├── docker-compose.prod.yml       # 生產環境配置\n├── script/                       # 自動化建置腳本\n│   ├── package.json              # 建置工具配置\n│   └── setup/                    # 環境設定腳本\n├── backend/                      # Python FastAPI 後端\n│   ├── main.py                   # 主程式入口\n│   ├── app/\n│   │   ├── core/                 # 核心功能\n│   │   │   ├── auth.py           # JWT 認證系統\n│   │   │   ├── database.py       # 資料庫配置\n│   │   │   └── security.py       # 安全機制\n│   │   ├── api/                  # API 路由\n│   │   │   ├── chat.py           # 對話介面\n│   │   │   ├── knowledge.py      # 知識庫管理\n│   │   │   └── admin.py          # 管理功能\n│   │   ├── models/               # 資料模型\n│   │   │   ├── user.py           # 用戶模型\n│   │   │   ├── knowledge.py      # 知識庫模型\n│   │   │   └── conversation.py   # 對話模型\n│   │   └── services/             # 業務邏輯\n│   │       ├── openai_service.py # OpenAI 整合\n│   │       ├── langchain_service.py # LangChain 整合\n│   │       └── knowledge_service.py # 知識庫服務\n├── frontend/                     # React 前端\n│   ├── package.json              # 依賴管理\n│   ├── src/\n│   │   ├── components/           # React 組件\n│   │   │   ├── Chat/             # 聊天介面\n│   │   │   ├── Knowledge/        # 知識庫管理\n│   │   │   └── Admin/            # 管理後台\n│   │   ├── stores/               # Zustand 狀態管理\n│   │   │   ├── authStore.ts      # 認證狀態\n│   │   │   ├── chatStore.ts      # 聊天狀態\n│   │   │   └── knowledgeStore.ts # 知識庫狀態\n│   │   ├── services/             # API 服務\n│   │   │   ├── api.ts            # API 基礎配置\n│   │   │   ├── auth.ts           # 認證服務\n│   │   │   └── chat.ts           # 聊天服務\n│   │   └── types/                # TypeScript 型別定義\n│   └── public/                   # 靜態資源\n└── docs/                         # 文檔目錄\n    ├── api.md                    # API 文檔\n    ├── deployment.md             # 部署指南\n    └── architecture.md           # 架構說明\n\n背景與問題\n企業客服面臨的核心挑戰：\n\n人力成本高：24/7 客服需要大量人力資源\n回應不一致：不同客服人員知識水準差異\n知識分散：FAQ、文檔、經驗分散在各處\n擴展困難：業務成長時客服系統難以同步擴展\n\n技術方案\n架構設計理念\n1. 微服務架構\n┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐\n│   React 前端    │    │  FastAPI 後端   │    │   Redis 快取    │\n│                 │    │                 │    │                 │\n│ - Ant Design    │◄──►│ - LangChain     │◄──►│ - 會話管理      │\n│ - Zustand       │    │ - OpenAI        │    │ - 速率限制      │\n│ - TypeScript    │    │ - SQLAlchemy    │    │                 │\n└─────────────────┘    └─────────────────┘    └─────────────────┘\n                               │\n                               ▼\n                       ┌─────────────────┐\n                       │  SQLite 資料庫  │\n                       │                 │\n                       │ - 用戶資料      │\n                       │ - 知識庫        │\n                       │ - 對話記錄      │\n                       └─────────────────┘\n\n2. Function Calling 智能決策\n\n知識庫查詢：智能檢索相關文檔\n管理員推薦：複雜問題自動升級\n問題分類：自動歸類和路由\n解決方案建議：基於歷史數據推薦\n\n3. 多語言知識庫\n採用 EAV (Entity-Attribute-Value) 模式支援：\n\n繁體中文、簡體中文、英文內容\n動態翻譯和本地化\n文化適應的回應風格\n\n核心技術特色\n1. 智能自動化建置\n// 建置工具: script/package.json\n{\n  &quot;scripts&quot;: {\n    &quot;dev&quot;: &quot;node setup/interactive-setup.js&quot;,\n    &quot;fix-packages&quot;: &quot;node setup/package-fixer.js&quot;\n  }\n}\n取代傳統 bat/sh 腳本，避免環境相容性問題，提供互動式設定介面。\n2. 現代化狀態管理\n// Zustand 輕量級狀態管理\ninterface ChatState {\n  messages: Message[]\n  isLoading: boolean\n  sendMessage: (content: string) =&gt; Promise&lt;void&gt;\n}\n \nexport const useChatStore = create&lt;ChatState&gt;((set, get) =&gt; ({\n  messages: [],\n  isLoading: false,\n  sendMessage: async (content) =&gt; {\n    // 智能對話邏輯\n  },\n}))\n3. 企業級安全機制\n# JWT + RBAC 權限控制\n@router.get(&quot;/protected&quot;)\nasync def protected_endpoint(\n    current_user: User = Depends(get_current_user)\n):\n    # 基於角色的存取控制\n    return {&quot;user&quot;: current_user.username}\n核心實作\n1. Function Calling 實作\n# OpenAI Function Calling 定義\nfunctions = [\n    {\n        &quot;name&quot;: &quot;search_knowledge_base&quot;,\n        &quot;description&quot;: &quot;搜尋知識庫找到相關解答&quot;,\n        &quot;parameters&quot;: {\n            &quot;type&quot;: &quot;object&quot;,\n            &quot;properties&quot;: {\n                &quot;query&quot;: {&quot;type&quot;: &quot;string&quot;},\n                &quot;category&quot;: {&quot;type&quot;: &quot;string&quot;}\n            }\n        }\n    },\n    {\n        &quot;name&quot;: &quot;escalate_to_human&quot;,\n        &quot;description&quot;: &quot;將複雜問題轉交給人工客服&quot;,\n        &quot;parameters&quot;: {\n            &quot;type&quot;: &quot;object&quot;,\n            &quot;properties&quot;: {\n                &quot;reason&quot;: {&quot;type&quot;: &quot;string&quot;},\n                &quot;priority&quot;: {&quot;type&quot;: &quot;integer&quot;}\n            }\n        }\n    }\n]\n2. 多語言知識庫架構\n-- 知識庫核心表結構\nCREATE TABLE knowledge_articles (\n    id INTEGER PRIMARY KEY,\n    category_id INTEGER,\n    created_at TIMESTAMP,\n    updated_at TIMESTAMP\n);\n \nCREATE TABLE article_translations (\n    id INTEGER PRIMARY KEY,\n    article_id INTEGER,\n    language_code VARCHAR(5),\n    title TEXT,\n    content TEXT,\n    meta_description TEXT\n);\n \n-- 支援動態翻譯和本地化\n3. 智能路由系統\nclass IntelligentRouter:\n    def __init__(self):\n        self.langchain_agent = create_agent()\n \n    async def route_question(self, question: str) -&gt; RouteDecision:\n        # 使用 LangChain 分析問題類型\n        analysis = await self.langchain_agent.analyze(question)\n \n        # 決定處理策略\n        if analysis.complexity &gt; 8:\n            return RouteDecision(action=&quot;human_escalation&quot;)\n        elif analysis.category == &quot;technical&quot;:\n            return RouteDecision(action=&quot;technical_kb_search&quot;)\n        else:\n            return RouteDecision(action=&quot;general_response&quot;)\n效果與學習\n技術亮點\n1. 架構先進性\n\n採用最新的 React 18 + TypeScript\nFastAPI 的高效能非同步處理\nDocker 容器化部署策略\n\n2. AI 整合深度\n\nOpenAI Function Calling 智能決策\nLangChain 複雜對話流程管理\n語義搜尋和知識檢索\n\n3. 開發體驗優化\n\n互動式環境設定\n完整的 API 文檔 (Swagger/ReDoc)\nTypeScript 型別安全\n\n架構優勢分析\n1. 可擴展性\n微服務設計 → 各模組獨立部署\n容器化部署 → 雲端原生架構\nAPI 優先 → 多端整合友善\n\n2. 維護性\nTypeScript → 編譯時錯誤檢查\nZustand → 可預測的狀態管理\nSQLAlchemy ORM → 資料庫抽象化\n\n3. 效能優化\nRedis 快取 → 減少資料庫負載\n非同步處理 → 提升併發能力\n靜態資源優化 → 加快載入速度\n\n尚未解決的技術挑戰\n1. 環境依賴複雜度\n\nPython 3.11+ + Node.js 18+ + Redis 雙重環境需求\nDocker 網路配置複雜性\n跨平台環境差異處理\n\n2. OpenAI API 整合穩定性\n\nAPI 限制和配額管理\n錯誤重試機制\n回應時間優化\n\n3. 前後端整合\n\nCORS 配置複雜度\n認證狀態同步\n即時通訊實作\n\n時間軸\n2025-06-14 11:03 專案初始化\n\n建立 Git 倉庫\n基礎目錄結構規劃\n\n2025-06-23 17:19 Flutter 基礎環境\n\n探索 Flutter 作為前端方案\n建立基礎 Flutter 專案架構\n\n2025-06-23 19:48 Helpdesk 基本設計\n\n確定客服系統核心功能\n規劃 AI 整合策略\n\n2025-06-24 09:35 清除非必要程式碼\n\n精簡專案結構\n移除測試代碼\n\n2025-06-24 10:10 環境自動化\n\n建立自動化建置流程\n改善開發體驗\n\n2025-06-24 10:44 改用 Webpack 基礎\n\n切換到現代化建置工具\n改善模組管理\n\n2025-06-24 11:35 自動安裝雛型完成\n\n完成環境自動設定\n建立互動式安裝界面\n\n2025-07-03 15:51 AI Memory 改良版 Helpdesk\n\n基於 test-ai-memory 的架構改良\n整合 AI 記憶系統概念\n\n2025-07-03 17:06 補充項目\n\n完善系統功能\n增加必要模組\n\n2025-07-03 22:06 優化 HELPDESK\n\n系統效能調整\n用戶體驗改善\n\n2025-07-03 22:15 更新 README.md\n\n完善系統文檔\n更新使用指南\n\n2025-07-03 23:08 建置前端\n\nReact 前端實作\nAnt Design UI 整合\n\n2025-07-03 23:14 優化整個運作\n\n全系統整合測試\n效能優化調整\n\n2025-07-06 16:16 基本檔案\n\n完善專案文檔\n規範化文件結構\n\n2025-07-06 16:47 Create README.md\n\n建立完整的專案說明\n整理技術文檔\n\n\n⏰ 總投入時間：約 25+ 小時 | 🎯 成果：企業級架構設計 | 📚 學習：現代化微服務整合\n專案映射\n\n開發資料夾：/Volumes/Code/test-helpdesk/help-agnet\n技術特色：Function Calling + 微服務架構\n相關專案：test-helper-memory-system（簡化版本）\n架構優勢：企業級可擴展性，現代化技術棧\n"},"projects/ai-tools/help_app":{"slug":"projects/ai-tools/help_app","filePath":"projects/ai-tools/help_app.md","title":"Help_app - Flutter客服移動應用","links":[],"tags":["mobile-development","flutter","customer-service","template"],"content":"Help_app - Flutter客服移動應用\n\nFlutter 客服系統移動端基礎模板專案\n\n專案概述\n\n路徑：/Volumes/Code/test-helpdesk/help_app\n技術棧：Flutter + Dart\n狀態：基礎模板（尚未開始真正開發）\n複雜度：簡單（預設模板結構）\n領域：AI工具開發（移動端客服）\n\n專案資料夾結構\nhelp_app/\n├── README.md                      # Flutter 預設說明\n├── pubspec.yaml                   # Flutter 依賴配置\n├── pubspec.lock                   # 依賴版本鎖定\n├── analysis_options.yaml          # 程式碼分析配置\n├── .gitignore                     # Git 忽略檔案\n├── .metadata                      # Flutter 專案元資料\n├── android/                       # Android 平台配置\n│   ├── app/\n│   │   ├── build.gradle           # Android 建置配置\n│   │   └── src/\n│   │       └── main/\n│   │           ├── AndroidManifest.xml\n│   │           └── kotlin/\n│   ├── build.gradle               # 專案層級建置配置\n│   ├── gradle.properties          # Gradle 屬性\n│   └── settings.gradle            # Gradle 設定\n├── ios/                          # iOS 平台配置\n│   ├── Runner/\n│   │   ├── Info.plist            # iOS 應用程式資訊\n│   │   └── AppDelegate.swift     # iOS 應用程式委託\n│   ├── Runner.xcodeproj/         # Xcode 專案檔\n│   └── Runner.xcworkspace/       # Xcode 工作區\n├── lib/                          # Flutter 應用程式代碼\n│   └── main.dart                 # 應用程式入口點（預設模板）\n├── test/                         # 單元測試\n│   └── widget_test.dart          # 預設測試檔案\n├── web/                          # Web 平台支援\n│   ├── index.html                # Web 入口 HTML\n│   └── manifest.json             # Web 應用程式清單\n├── windows/                      # Windows 平台支援\n├── macos/                        # macOS 平台支援\n└── linux/                       # Linux 平台支援\n\n背景與問題\n專案設定動機\n此專案建立的背景考量：\n\n多平台客服需求：除了 Web 版客服系統，需要移動端支援\nFlutter 跨平台優勢：一套代碼支援 iOS、Android、Web、Desktop\n整合統一體驗：與 help-agnet 後端 API 整合，提供一致的客服體驗\n\n目前狀態分析\n// lib/main.dart - 目前只有 Flutter 預設範例\nimport &#039;package:flutter/material.dart&#039;;\n \nvoid main() {\n  runApp(const MyApp());\n}\n \nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n \n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: &#039;Flutter Demo&#039;,\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const MyHomePage(title: &#039;Flutter Demo Home Page&#039;),\n    );\n  }\n}\n \n// 標準的計數器範例應用程式\nclass MyHomePage extends StatefulWidget {\n  // ... 預設 Flutter 模板代碼\n}\n未來發展規劃\n階段一：基礎客服介面\n// 預期的應用程式結構\nlib/\n├── main.dart                     # 應用程式入口\n├── app/                          # 應用程式核心\n│   ├── app.dart                  # 主應用程式設定\n│   └── routes.dart               # 路由配置\n├── features/                     # 功能模組\n│   ├── chat/                     # 聊天功能\n│   │   ├── screens/\n│   │   │   ├── chat_screen.dart  # 聊天介面\n│   │   │   └── chat_history.dart # 聊天記錄\n│   │   ├── widgets/\n│   │   │   ├── message_bubble.dart # 訊息氣泡\n│   │   │   ├── input_field.dart   # 輸入欄位\n│   │   │   └── typing_indicator.dart # 輸入指示器\n│   │   └── services/\n│   │       └── chat_service.dart  # 聊天服務\n│   ├── knowledge/                # 知識庫\n│   │   ├── screens/\n│   │   │   └── knowledge_search.dart # 知識搜尋\n│   │   └── widgets/\n│   │       └── knowledge_card.dart    # 知識卡片\n│   └── tickets/                  # 工單系統\n│       ├── screens/\n│       │   ├── ticket_list.dart  # 工單列表\n│       │   └── ticket_detail.dart # 工單詳情\n│       └── services/\n│           └── ticket_service.dart # 工單服務\n├── shared/                       # 共用組件\n│   ├── widgets/                  # 共用小元件\n│   │   ├── loading_widget.dart   # 載入指示器\n│   │   ├── error_widget.dart     # 錯誤顯示\n│   │   └── custom_button.dart    # 自訂按鈕\n│   ├── services/                 # 共用服務\n│   │   ├── api_service.dart      # API 呼叫服務\n│   │   ├── auth_service.dart     # 認證服務\n│   │   └── storage_service.dart  # 本機儲存\n│   ├── models/                   # 資料模型\n│   │   ├── user.dart             # 用戶模型\n│   │   ├── message.dart          # 訊息模型\n│   │   └── ticket.dart           # 工單模型\n│   └── utils/                    # 工具函數\n│       ├── constants.dart        # 常數定義\n│       ├── helpers.dart          # 輔助函數\n│       └── validators.dart       # 驗證函數\n└── core/                         # 核心功能\n    ├── config/                   # 配置\n    │   └── app_config.dart       # 應用程式配置\n    ├── network/                  # 網路層\n    │   ├── dio_client.dart       # HTTP 客戶端\n    │   └── interceptors.dart     # 請求攔截器\n    └── storage/                  # 儲存層\n        └── secure_storage.dart   # 安全儲存\n階段二：進階功能\n\n語音對話功能\n檔案上傳支援\n推播通知\n離線模式支援\n多語言國際化\n\n技術方案\nFlutter 架構優勢\n1. 跨平台一致性\n# pubspec.yaml - 目標平台支援\nflutter:\n  platforms:\n    android: true\n    ios: true\n    web: true\n    windows: true\n    macos: true\n    linux: true\n2. 現代化 UI 框架\n// Material Design 3 支援\nThemeData(\n  useMaterial3: true,\n  colorScheme: ColorScheme.fromSeed(\n    seedColor: Colors.blue,\n    brightness: Brightness.light,\n  ),\n)\n3. 效能優化\n// Flutter 2.5+ 效能特性\n- Skia 渲染引擎\n- AOT 編譯優化\n- Tree-shaking 代碼優化\n- Hot reload 開發體驗\n與後端整合策略\n1. API 整合設計\n// 與 help-agnet 後端整合\nclass ApiService {\n  static const baseUrl = &#039;http://localhost:8000/api&#039;;\n \n  Future&lt;ChatResponse&gt; sendMessage(String message) async {\n    final response = await dio.post(\n      &#039;$baseUrl/chat/message&#039;,\n      data: {&#039;message&#039;: message},\n    );\n    return ChatResponse.fromJson(response.data);\n  }\n \n  Future&lt;List&lt;Ticket&gt;&gt; getTickets() async {\n    final response = await dio.get(&#039;$baseUrl/tickets&#039;);\n    return (response.data as List)\n        .map((e) =&gt; Ticket.fromJson(e))\n        .toList();\n  }\n}\n2. 狀態管理策略\n// 使用 Riverpod 進行狀態管理\nfinal chatProvider = StateNotifierProvider&lt;ChatNotifier, ChatState&gt;(\n  (ref) =&gt; ChatNotifier(ref.read(apiServiceProvider)),\n);\n \nclass ChatNotifier extends StateNotifier&lt;ChatState&gt; {\n  ChatNotifier(this._apiService) : super(ChatState.initial());\n \n  final ApiService _apiService;\n \n  Future&lt;void&gt; sendMessage(String message) async {\n    state = state.copyWith(isLoading: true);\n    try {\n      final response = await _apiService.sendMessage(message);\n      state = state.copyWith(\n        messages: [...state.messages, response.message],\n        isLoading: false,\n      );\n    } catch (e) {\n      state = state.copyWith(\n        error: e.toString(),\n        isLoading: false,\n      );\n    }\n  }\n}\n3. 本機儲存策略\n// 使用 Hive 進行本機資料儲存\n@HiveType(typeId: 0)\nclass Message extends HiveObject {\n  @HiveField(0)\n  String id;\n \n  @HiveField(1)\n  String content;\n \n  @HiveField(2)\n  DateTime timestamp;\n \n  @HiveField(3)\n  bool isFromUser;\n \n  Message({\n    required this.id,\n    required this.content,\n    required this.timestamp,\n    required this.isFromUser,\n  });\n}\n核心實作\n目前實作狀況\n1. 基礎專案結構\nname: help_app\ndescription: A new Flutter project.\n \npublish_to: &quot;none&quot;\n \nversion: 1.0.0+1\n \nenvironment:\n  sdk: &quot;&gt;=3.0.0 &lt;4.0.0&quot;\n \ndependencies:\n  flutter:\n    sdk: flutter\n  cupertino_icons: ^1.0.2\n \ndev_dependencies:\n  flutter_test:\n    sdk: flutter\n  flutter_lints: ^2.0.0\n \nflutter:\n  uses-material-design: true\n2. 預設應用程式代碼\n// lib/main.dart - 目前只有基本範例\nvoid main() {\n  runApp(const MyApp());\n}\n \nclass MyApp extends StatelessWidget {\n  const MyApp({super.key});\n \n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: &#039;Flutter Demo&#039;,\n      theme: ThemeData(\n        colorScheme: ColorScheme.fromSeed(seedColor: Colors.deepPurple),\n        useMaterial3: true,\n      ),\n      home: const MyHomePage(title: &#039;Flutter Demo Home Page&#039;),\n    );\n  }\n}\n預期實作架構\n1. 客服聊天介面\nclass ChatScreen extends StatefulWidget {\n  @override\n  _ChatScreenState createState() =&gt; _ChatScreenState();\n}\n \nclass _ChatScreenState extends State&lt;ChatScreen&gt; {\n  final List&lt;Message&gt; _messages = [];\n  final TextEditingController _controller = TextEditingController();\n \n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(&#039;客服助手&#039;),\n        backgroundColor: Theme.of(context).colorScheme.inversePrimary,\n      ),\n      body: Column(\n        children: [\n          Expanded(\n            child: ListView.builder(\n              itemCount: _messages.length,\n              itemBuilder: (context, index) {\n                return MessageBubble(message: _messages[index]);\n              },\n            ),\n          ),\n          MessageInput(\n            controller: _controller,\n            onSend: _sendMessage,\n          ),\n        ],\n      ),\n    );\n  }\n \n  void _sendMessage(String text) {\n    // 實作訊息傳送邏輯\n  }\n}\n2. 訊息氣泡組件\nclass MessageBubble extends StatelessWidget {\n  final Message message;\n \n  const MessageBubble({Key? key, required this.message}) : super(key: key);\n \n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      alignment: message.isFromUser\n          ? Alignment.centerRight\n          : Alignment.centerLeft,\n      margin: EdgeInsets.symmetric(vertical: 4, horizontal: 8),\n      child: Container(\n        padding: EdgeInsets.all(12),\n        decoration: BoxDecoration(\n          color: message.isFromUser\n              ? Colors.blue[500]\n              : Colors.grey[300],\n          borderRadius: BorderRadius.circular(16),\n        ),\n        child: Text(\n          message.content,\n          style: TextStyle(\n            color: message.isFromUser ? Colors.white : Colors.black,\n          ),\n        ),\n      ),\n    );\n  }\n}\n效果與學習\nFlutter 框架優勢\n1. 開發效率\nHot Reload → 即時預覽變更\nWidget 樹 → 組件化開發\nMaterial Design → 內建 UI 組件\n跨平台 → 一套代碼多平台部署\n\n2. 效能優勢\nDart AOT 編譯 → 接近原生效能\nSkia 渲染引擎 → 流暢 60fps 動畫\nWidget 快取 → 高效 UI 更新\nTree-shaking → 最小化應用程式大小\n\n3. 生態系統\npub.dev → 豐富的套件庫\n官方支援 → Google 維護\n社群活躍 → 完整的學習資源\n企業採用 → 阿里巴巴、騰訊等大廠使用\n\n潛在技術挑戰\n1. 平台差異處理\n// 平台特定功能需要特殊處理\nif (Platform.isIOS) {\n  // iOS 特定邏輯\n} else if (Platform.isAndroid) {\n  // Android 特定邏輯\n}\n2. 原生功能整合\n// 可能需要原生外掛程式\ndependencies:\n  camera: ^0.10.0        # 相機功能\n  file_picker: ^5.0.0    # 檔案選擇\n  push_notifications: ^3.0.0  # 推播通知\n3. 狀態管理複雜度\n// 隨著功能增加，狀態管理會變得複雜\n- 用戶認證狀態\n- 聊天對話狀態\n- 工單管理狀態\n- 網路連接狀態\n- 本機儲存狀態\n與其他客服專案對比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n面向help_apphelp-agnettest-helper-memory-system平台移動端 + WebWeb 為主Web 為主技術棧Flutter/DartReact/TypeScriptPython/React開發狀態基礎模板先進但未運行建置失敗複雜度簡單企業級中等用戶體驗原生感受現代 Web簡化介面部署策略應用商店Docker容器手動部署\n未來發展潛力\n1. 移動端優勢\n隨時隨地存取 → 提高客服可及性\n推播通知 → 即時問題通知\n離線支援 → 網路不穩定時仍可使用\n原生整合 → 相機、檔案等系統功能\n\n2. 整合可能性\n與 help-agnet 後端整合 → 完整的客服生態系統\n統一用戶體驗 → 跨平台一致的介面\n資料同步 → 雲端與本機資料即時同步\n\n時間軸\n2025-06-23 17:29 基礎的 flutter環境\n\n建立 Flutter 專案基礎架構\n配置跨平台環境支援\n\n\n⏰ 總投入時間：約 2 小時 | 🎯 成果：基礎專案模板 | 📚 學習：Flutter 跨平台開發架構\n專案映射\n\n開發資料夾：/Volumes/Code/test-helpdesk/help_app\n技術特色：Flutter 跨平台客服應用\n相關專案：help-agnet（後端整合目標）\n發展潜力：移動端客服解決方案\n"},"projects/ai-tools/test-ai-memory":{"slug":"projects/ai-tools/test-ai-memory","filePath":"projects/ai-tools/test-ai-memory.md","title":"AI記憶體系統研究平台 - 長期記憶與智能交互的突破","links":["tags/AI","tags/LongTermMemory","tags/ChromeExtension","tags/Microservices","tags/Ollama","tags/FastAPI","tags/Streamlit","tags/AIResearch","tags/OpenSource","tags/MemorySystem"],"tags":["ai-memory","long-term-memory","chrome-extension","microservices","ollama","streamlit","fastapi","test-love-memory-system","test-microservice-summary","AI","LongTermMemory","ChromeExtension","Microservices","Ollama","FastAPI","Streamlit","AIResearch","OpenSource","MemorySystem"],"content":"🧠 AI記憶體系統研究平台\n\n突破AI記憶瓶頸，實現真正具有長期記憶能力的智能系統，為AI發展開創新篇章\n\n專案概述\n\n開發路徑：/Volumes/Code/test-ai-memory\n技術架構：三位一體微服務生態系統\n開發狀態：成功驗證，推薦學習參考\n複雜度評級：高 (多系統協同，創新性突破)\n核心價值：AI長期記憶技術的開源實踐\n\n📁 專案資料夾結構\ntest-ai-memory/\n├── README.md                              # 專案總覽\n├── CHROME_EXTENSION_DEVELOPMENT_PLAN.md   # Chrome擴展開發計劃\n├── test-love-memory-system/               # 🌟 AI長期記憶系統 (核心)\n│   ├── love_memory_system.py             # 原始單檔版本\n│   ├── main_modular.py                   # 模組化版本\n│   ├── love_memory_system/               # 模組化核心\n│   │   ├── api.py                        # FastAPI服務\n│   │   ├── ai/                           # AI女友核心邏輯\n│   │   ├── memory/                       # 記憶系統\n│   │   └── personality/                  # 人格管理\n│   └── README.md                         # 詳細技術文檔\n├── test-chrome-extension-ai-chat/         # 🚀 Chrome擴展AI對話\n│   ├── background/                       # 背景腳本\n│   ├── components/                       # React元件\n│   ├── contents/                         # 內容腳本\n│   ├── lib/                              # API工具\n│   ├── popup.tsx                         # 彈出介面\n│   └── README.md                         # 使用指南\n├── test-microservice-summary/             # ⚡ AI微服務API\n│   ├── api/                              # FastAPI微服務\n│   ├── gradio_app/                       # 驗證介面\n│   ├── requirements/                     # 依賴管理\n│   ├── docker/                           # 容器化配置\n│   └── README.md                         # 部署文檔\n└── image/                                # 專案截圖\n\n背景與問題\nAI記憶技術挑戰\n當前AI系統面臨的根本性限制：\n\n🔄 無狀態困境：每次對話都是全新開始，無法累積經驗\n📉 上下文限制：Token限制導致的記憶容量瓶頸\n🧩 碎片化記憶：缺乏有效的記憶組織和檢索機制\n💭 情感記憶缺失：無法建立情感關聯和個人化體驗\n\n技術整合需求\n\n瀏覽器整合：將AI能力無縫融入日常瀏覽體驗\n跨服務通信：不同環境下的AI服務互操作性\n本地化部署：隱私保護與效能的雙重要求\n\n技術方案\n🌟 三核心子專案生態\n1. test-love-memory-system - AI長期記憶突破\n\n最成功實現 - 推薦AI發展學習參考\n\n核心創新\n\n🧠 真正的AI記憶：SQLite持久化存儲 + 智能檢索\n🎭 多人格系統：7種不同人格的動態切換\n📊 記憶管理介面：完整的CRUD操作和分析工具\n🌐 API服務化：FastAPI驅動的RESTful介面\n\n\n記憶系統架構\n# 記憶核心實現\nclass MemoryManager:\n    def __init__(self):\n        self.db = sqlite3.connect(&#039;memories.db&#039;)\n        self.embedding_model = SentenceTransformer(&#039;all-MiniLM-L6-v2&#039;)\n \n    def store_memory(self, content, importance, emotion):\n        # 向量化記憶內容\n        embedding = self.embedding_model.encode(content)\n        # 存儲到資料庫\n        self.db.execute(&quot;&quot;&quot;\n            INSERT INTO memories (content, embedding, importance, emotion, timestamp)\n            VALUES (?, ?, ?, ?, ?)\n        &quot;&quot;&quot;, (content, embedding.tobytes(), importance, emotion, datetime.now()))\n \n    def retrieve_relevant_memories(self, query, top_k=5):\n        # 語義搜索相關記憶\n        query_embedding = self.embedding_model.encode(query)\n        # 計算相似度並返回最相關記憶\n        return self.semantic_search(query_embedding, top_k)\n人格化AI實現\n# 多人格系統\npersonality_prompts = {\n    &quot;親妹妹&quot;: &quot;可愛撒嬌型，用「哥哥」稱呼，語氣活潑親暱&quot;,\n    &quot;親姊姊&quot;: &quot;溫柔體貼型，關心照顧，語氣溫暖包容&quot;,\n    &quot;冷酷&quot;: &quot;高冷傲嬌型，表面冷淡但內心關心&quot;,\n    # ...其他人格\n}\n \nclass AIPersonality:\n    def __init__(self, personality_type):\n        self.personality = personality_type\n        self.system_prompt = personality_prompts[personality_type]\n \n    def generate_response(self, user_input, memories):\n        # 結合人格特色 + 相關記憶 + 當前輸入\n        context = self.build_context(memories)\n        prompt = f&quot;{self.system_prompt}\\n記憶: {context}\\n用戶: {user_input}&quot;\n        return self.ai_model.generate(prompt)\n開發成果與突破\n\n✅ 記憶持久化：真正突破AI無記憶限制\n✅ 情感建模：實現情緒理解和回應\n✅ 個性化交互：根據歷史記憶調整回應風格\n✅ 研究價值：為AI記憶研究提供完整實現方案\n\n2. test-chrome-extension-ai-chat - 智能瀏覽器整合\n\n值得學習的整合典範 - Ollama + Chrome完美結合\n\n核心特色\n\n🖱️ 右鍵智能選單：選取文字即可AI分析\n📋 智能摘要生成：基於Plasmo框架的現代Chrome擴展\n💬 上下文對話：結合網頁內容的深度交互\n🤖 動態模型選擇：自動獲取Ollama可用模型\n\n對選擇的文章文字片段，能自動摘要\n\n面對摘要可以進行對話\n\n技術實現亮點\n// 背景腳本 - 右鍵選單整合\nchrome.contextMenus.create({\n  id: &quot;ai-summary&quot;,\n  title: &quot;✨ AI 智能摘要&quot;,\n  contexts: [&quot;selection&quot;],\n})\n \nchrome.contextMenus.create({\n  id: &quot;ai-chat&quot;,\n  title: &quot;💬 AI 對話討論&quot;,\n  contexts: [&quot;selection&quot;],\n})\n \n// 內容腳本 - 智能對話框\nclass AIDialog extends React.Component {\n  async generateSummary(selectedText: string) {\n    const response = await fetch(&quot;http://localhost:8764/api/v1/summary/analyze&quot;, {\n      method: &quot;POST&quot;,\n      headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },\n      body: JSON.stringify({\n        text: selectedText,\n        model: this.state.selectedModel,\n        summary_type: &quot;general&quot;,\n        language: &quot;zh-tw&quot;,\n      }),\n    })\n \n    const result = await response.json()\n    this.setState({ summary: result.summary })\n  }\n}\n整合成就\n\n✅ Plasmo框架：現代Chrome擴展開發最佳實踐\n✅ Ollama集成：本地AI模型的完美整合\n✅ 用戶體驗：無干擾的智能增強體驗\n✅ 開源貢獻：為瀏覽器AI整合提供參考實現\n\n3. test-microservice-summary - 跨環境AI服務\n\n架構設計典範 - 微服務AI的完整實現，目前發現 Ollama 的 python sdk ，在互動的效果不錯\n\n核心價值\n\n🔌 API優先設計：RESTful微服務架構\n🐳 容器化部署：Docker + Docker Compose\n🎨 Gradio驗證介面：可視化測試環境\n📚 完整文檔：Swagger自動生成API文檔\n\n\n微服務架構設計\n# FastAPI微服務核心\nfrom fastapi import FastAPI, UploadFile, File\nfrom pydantic import BaseModel\n \napp = FastAPI(title=&quot;Ollama智能文字處理微服務&quot;)\n \nclass SummaryRequest(BaseModel):\n    text: str\n    summary_length: int = 300\n    summary_type: str = &quot;general&quot;\n    language: str = &quot;zh-tw&quot;\n    temperature: float = 0.7\n \n@app.post(&quot;/api/v1/summary/analyze&quot;)\nasync def analyze_text(request: SummaryRequest):\n    # 呼叫Ollama API處理\n    result = await ollama_service.generate_summary(\n        text=request.text,\n        length=request.summary_length,\n        type=request.summary_type\n    )\n \n    return {\n        &quot;summary&quot;: result.summary,\n        &quot;tags&quot;: result.tags,\n        &quot;metadata&quot;: {\n            &quot;processing_time&quot;: result.time,\n            &quot;model_used&quot;: result.model\n        }\n    }\n \n@app.post(&quot;/api/v1/chat/message&quot;)\nasync def chat_message(message: ChatRequest):\n    # 對話處理邏輯\n    response = await ollama_service.chat(\n        message=message.message,\n        context=message.context,\n        model=message.model\n    )\n    return {&quot;response&quot;: response}\nDocker容器化部署\n# docker-compose.yml\nversion: &quot;3.8&quot;\nservices:\n  api:\n    build:\n      context: .\n      dockerfile: docker/api.Dockerfile\n    ports:\n      - &quot;8764:8000&quot;\n    environment:\n      - OLLAMA_API_URL=http://ollama:11434\n    depends_on:\n      - ollama\n \n  gradio:\n    build:\n      context: .\n      dockerfile: docker/gradio.Dockerfile\n    ports:\n      - &quot;7860:7860&quot;\n    depends_on:\n      - api\n \n  ollama:\n    image: ollama/ollama:latest\n    ports:\n      - &quot;11434:11434&quot;\n    volumes:\n      - ollama_data:/root/.ollama\n服務價值\n\n✅ 跨環境支援：解決Chrome擴展無法直接訪問Ollama的問題\n✅ API標準化：提供統一的AI服務介面\n✅ 可擴展性：支持多種AI模型和任務類型\n✅ 生產就緒：完整的日誌、監控和錯誤處理\n\n核心實作\nAI記憶系統的技術突破\n1. 向量化記憶存儲\n# 記憶向量化實現\ndef vectorize_memory(self, content):\n    # 使用Sentence Transformers進行語義編碼\n    embedding = self.model.encode(content)\n    return {\n        &#039;content&#039;: content,\n        &#039;embedding&#039;: embedding.tolist(),\n        &#039;timestamp&#039;: datetime.now(),\n        &#039;importance&#039;: self.calculate_importance(content)\n    }\n \ndef semantic_search(self, query, top_k=5):\n    # 語義搜索實現\n    query_vector = self.model.encode(query)\n    similarities = cosine_similarity([query_vector], self.memory_vectors)\n    indices = np.argsort(similarities[0])[::-1][:top_k]\n    return [self.memories[i] for i in indices]\n2. 情感建模系統\n# 情感分析和記憶關聯\nclass EmotionalMemory:\n    def __init__(self):\n        self.emotion_classifier = pipeline(&quot;sentiment-analysis&quot;)\n \n    def store_with_emotion(self, content, user_emotion=None):\n        # 分析內容情感\n        content_emotion = self.emotion_classifier(content)[0]\n \n        # 結合用戶情感和內容情感\n        combined_emotion = {\n            &#039;content_emotion&#039;: content_emotion,\n            &#039;user_emotion&#039;: user_emotion,\n            &#039;emotional_weight&#039;: self.calculate_emotional_weight(content)\n        }\n \n        return self.store_memory(content, emotion=combined_emotion)\nChrome擴展的創新交互\n3. 智能內容提取\n// 智能文本選取和處理\nclass ContentExtractor {\n  extractSelection(): string {\n    const selection = window.getSelection()\n    if (!selection || selection.rangeCount === 0) return &quot;&quot;\n \n    // 獲取選取內容的上下文\n    const range = selection.getRangeAt(0)\n    const context = this.getContextualContent(range)\n \n    return {\n      selectedText: selection.toString(),\n      context: context,\n      pageUrl: window.location.href,\n      pageTitle: document.title,\n    }\n  }\n \n  private getContextualContent(range: Range): string {\n    // 智能提取周圍上下文\n    const container = range.commonAncestorContainer\n    const paragraph = container.parentElement(&quot;p, div, article&quot;)\n    return paragraph?.textContent?.slice(0, 500) || &quot;&quot;\n  }\n}\n微服務的架構優勢\n4. 錯誤處理和重試機制\n# 健壯的API設計\nfrom functools import wraps\nimport asyncio\n \ndef retry_on_failure(max_retries=3):\n    def decorator(func):\n        @wraps(func)\n        async def wrapper(*args, **kwargs):\n            for attempt in range(max_retries):\n                try:\n                    return await func(*args, **kwargs)\n                except Exception as e:\n                    if attempt == max_retries - 1:\n                        raise e\n                    await asyncio.sleep(2 ** attempt)  # 指數退避\n            return None\n        return wrapper\n    return decorator\n \n@retry_on_failure(max_retries=3)\nasync def call_ollama_api(self, payload):\n    # 調用Ollama API的重試邏輯\n    response = await self.http_client.post(\n        f&quot;{self.ollama_url}/api/generate&quot;,\n        json=payload,\n        timeout=30\n    )\n    return response.json()\n效果與學習\n開發成果\n技術突破：\n\n🧠 AI記憶技術：突破傳統AI無記憶限制，實現真正的長期記憶\n🔄 記憶檢索算法：基於語義相似度的智能記憶召回\n💭 情感建模：情感與記憶的深度關聯建模\n🎯 人格化AI：多人格系統的動態切換機制\n\n整合創新：\n\n🌐 瀏覽器AI整合：無縫融入日常工作流程\n🔗 微服務架構：跨環境AI服務的標準化實現\n📱 用戶體驗：零學習成本的智能增強\n\n系統價值：\n\n📊 研究價值：為AI記憶研究提供完整開源實現\n🔧 工程價值：可複用的微服務和擴展架構\n🎓 教育價值：AI開發的最佳實踐示範\n\n技術洞察與創新\n1. AI記憶系統設計哲學\n\n持久化不等於記憶：需要智能的組織、檢索和關聯\n情感是記憶的催化劑：情感標記顯著提升記憶召回效果\n個性化是記憶的表達：相同記憶在不同人格下的不同詮釋\n\n2. Chrome擴展開發心得\n\nManifest V3的Service Worker：事件驅動的新架構模式\n跨域通信的安全設計：Content Security Policy的正確配置\n用戶體驗的無感知原則：AI增強不應干擾原有體驗\n\n3. 微服務架構最佳實踐\n\nAPI優先設計：先設計接口，再實現功能\n容器化的一致性：開發、測試、生產環境的統一\n監控和日誌：系統健康狀態的可觀測性\n\n對AI發展的貢獻\n開源價值：\n\n📖 技術文檔：詳細的實現文檔和最佳實踐\n🔬 研究基礎：為AI記憶研究提供可驗證的基線實現\n🌍 社群貢獻：推動AI記憶技術的普及和發展\n\n創新啟發：\n\n💡 記憶即智能：長期記憶是通向AGI的關鍵技術\n🤝 人機協作：AI應該是智能增強而非替代\n🔮 未來願景：每個人都應該有專屬的AI記憶助手\n\n時間軸\n2025-07-06 15:30 專案總結與文檔化\n\n完成三個子專案的深度技術分析\n整理AI記憶系統的核心創新點\n撰寫推薦學習的技術文檔\n\n2025-07-01 09:00 test-love-memory-system 記憶系統突破\n\n實現真正的AI長期記憶功能\n完成7種人格的動態切換系統\n建立基於SQLite的記憶持久化存儲\n開發記憶管理的完整CRUD介面\n\n2025-06-28 14:45 test-chrome-extension-ai-chat 整合完成\n\n基於Plasmo框架完成Chrome擴展開發\n實現右鍵選單的智能AI功能\n完成與Ollama本地AI模型的無縫整合\n優化用戶體驗和錯誤處理機制\n\n2025-06-25 11:20 test-microservice-summary 微服務架構\n\n設計並實現FastAPI微服務架構\n完成Docker容器化部署方案\n建立Gradio驗證介面和API文檔\n實現跨環境AI服務的標準化接口\n\n2025-06-22 16:00 專案架構設計\n\n確定三位一體的技術架構方案\n制定AI記憶系統的核心技術路線\n設計Chrome擴展與微服務的整合方案\n\n\n⏰ 總投入時間：78小時 | 🎯 成果：AI記憶技術突破 | 📚 學習：AI長期記憶系統完整實現\n專案映射\n\n開發資料夾：/Volumes/Code/test-ai-memory\nGitHub倉庫：暫未公開（核心技術保護）\n相關專案：\n\ntest-ai-benchmark - AI效能測試工具\nbrowser-extension-ecosystem - 瀏覽器擴展生態系統\n\n\n\n下一步規劃\n短期目標 (本週)\n\n 完善記憶系統的向量檢索算法\n 優化Chrome擴展的響應速度\n 增強微服務的容錯能力\n\n中期目標 (本月)\n\n 開源AI記憶系統核心組件\n 發布Chrome擴展到Web Store\n 建立技術交流社群\n\n長期願景 (本季)\n\n 推動AI記憶技術標準化\n 建立AI記憶研究的開源生態\n 為AGI記憶系統奠定技術基礎\n\n🌟 推薦學習重點\n對AI開發者\n\n記憶系統設計：學習如何實現真正的AI長期記憶\n向量檢索技術：掌握語義搜索和記憶召回算法\n情感建模：理解情感與記憶的深度關聯\n\n對前端開發者\n\nChrome擴展現代化：Plasmo框架的最佳實踐\nAI整合模式：瀏覽器與AI服務的無縫整合\n用戶體驗設計：AI增強的界面設計原則\n\n對架構師\n\n微服務設計：AI服務的架構和部署模式\n容器化實踐：Docker在AI應用中的最佳實踐\nAPI設計：AI服務的RESTful設計原則\n\n\nAI LongTermMemory ChromeExtension Microservices Ollama FastAPI Streamlit AIResearch OpenSource MemorySystem"},"projects/ai-tools/test-gitlab-ci-peko":{"slug":"projects/ai-tools/test-gitlab-ci-peko","filePath":"projects/ai-tools/test-gitlab-ci-peko.md","title":"GitLab CI Peko - AI驅動配置生成器","links":[],"tags":["ai-integration","cicd","gitlab","automation","code-generation"],"content":"GitLab CI Peko - AI驅動配置生成器\n\n結合人工智慧與DevOps的革命性工具，讓CI/CD配置生成變得智能且高效\n\n\n專案概述\n\n路徑：/Volumes/Code/test-ai-auto-builder/test-gitlab-ci-peko\n技術棧：Node.js + Electron + OpenAI GPT + React + YAML處理\n狀態：活躍開發中\n複雜度：高度複雜\n領域：AI工具\n\n專案資料夾結構\ntest-gitlab-ci-peko/\n├── src/\n│   ├── components/          # React UI組件\n│   ├── services/           # 核心服務層\n│   │   ├── ProjectAnalyzer.js    # 專案智能分析引擎\n│   │   ├── AIAssistant.js        # AI助手服務\n│   │   └── GitlabCIGenerator.js  # CI配置生成器\n│   ├── main.js             # Electron主程序\n│   ├── preload.js          # 安全預載腳本\n│   └── renderer.js         # 渲染程序\n├── package.json            # 專案配置\n├── .env.example           # 環境變數範本\n└── README.md              # 專案文檔\n\n背景與問題\n傳統CI/CD配置建立過程繁瑣且容易出錯，開發者需要深入了解各種建置工具和最佳實踐。本專案解決了以下核心問題：\n\n配置複雜性：不同專案類型需要不同的CI/CD策略\n學習曲線陡峭：GitLab CI語法和最佳實踐需要時間掌握\n重複性工作：相似專案的配置工作大量重複\n錯誤頻發：手動配置容易產生語法和邏輯錯誤\n\n技術方案\nAI驅動的智能分析\n採用OpenAI GPT模型進行專案分析和配置生成：\n\n專案自動識別：分析package.json、requirements.txt、.csproj等檔案\n技術棧判斷：智能識別前端、後端、API類型\n依賴關係分析：自動檢測版本相容性和建置需求\n最佳實踐應用：基於業界標準生成優化配置\n\n多語言專案支援\n\nNode.js專案：自動處理npm快取、測試、建置流程\nPython專案：支援virtualenv、pip依賴管理\nC#專案：.NET Core/Framework建置和NuGet包管理\n前端專案：Webpack、Vite等現代建置工具支援\n\n可視化配置編輯\n\n直觀界面：拖拽式配置編輯體驗\n實時預覽：即時查看生成的YAML配置\n配置驗證：內建GitLab CI語法檢查\n模板管理：可保存和重用配置模板\n\n核心實作\n智能專案分析器\nclass ProjectAnalyzer {\n  async analyzeProject(projectPath) {\n    // 專案類型自動識別\n    const projectType = await this.detectProjectType(projectPath)\n \n    // 依賴關係分析\n    const dependencies = await this.analyzeDependencies(projectPath)\n \n    // 建置需求評估\n    const buildRequirements = await this.assessBuildNeeds(projectType, dependencies)\n \n    return {\n      type: projectType,\n      dependencies,\n      buildRequirements,\n      recommendations: await this.generateRecommendations(buildRequirements),\n    }\n  }\n}\nAI配置生成引擎\nclass GitlabCIGenerator {\n  async generateConfig(projectAnalysis, userPreferences) {\n    const prompt = this.buildPrompt(projectAnalysis, userPreferences)\n \n    // 調用OpenAI GPT生成配置\n    const aiResponse = await this.openaiClient.chat.completions.create({\n      model: &quot;gpt-4&quot;,\n      messages: [{ role: &quot;user&quot;, content: prompt }],\n      temperature: 0.1, // 降低隨機性，提高配置品質\n    })\n \n    return this.parseAndValidateConfig(aiResponse.choices[0].message.content)\n  }\n}\n跨平台桌面應用\n基於Electron建構，提供原生桌面體驗：\n\nWindows系統托盤：最小化運行，快速存取\nmacOS Dock整合：符合macOS使用習慣\nLinux桌面相容：支援主流桌面環境\n\n效果與學習\n開發效率提升\n\n配置生成時間：從數小時縮短至數分鐘\n錯誤率降低：AI生成配置的語法錯誤率&lt;5%\n學習成本：新手可在30分鐘內生成專業級配置\n\n技術洞察\n\nAI提示工程的重要性：精確的提示能顯著提升生成品質\n上下文感知的價值：結合專案分析的AI生成更準確\n人機協作模式：AI生成+人工優化的混合工作流程最有效\n\n創新點\n\n專案感知智能：不只是模板生成，而是理解專案特性\n漸進式配置：從基礎配置到高級優化的漸進式引導\n知識累積：每次生成都能學習和改進配置策略\n\n時間軸\n2025-06-15 10:00 專案啟動\n\n確定技術架構：Electron + React + OpenAI\n建立基礎專案結構\n設計UI/UX原型\n\n2025-06-20 14:30 核心功能開發\n\n實作專案分析引擎\n整合OpenAI API\n建立配置生成邏輯\n\n2025-06-25 09:15 多語言支援\n\n新增Node.js專案分析\n實作Python專案支援\n設計C#專案處理邏輯\n\n2025-07-01 16:45 UI/UX完善\n\n可視化編輯器實作\n配置驗證功能\nAI助手聊天介面\n\n2025-07-05 11:20 跨平台優化\n\nmacOS系統整合\nWindows托盤功能\nLinux桌面相容性測試\n\n\n⏰ 總投入時間：120小時 | 🎯 成果：跨平台AI配置生成器 | 📚 學習：AI工程化應用\n專案映射\n\n開發資料夾：/Volumes/Code/test-ai-auto-builder/test-gitlab-ci-peko\n所屬專案：test-ai-auto-builder\n相關專案：workflow-builder（工作流程配置）\n測試專案：test-nodejs-api-example（配置測試用例）\n"},"projects/ai-tools/test-helper-memory-system":{"slug":"projects/ai-tools/test-helper-memory-system","filePath":"projects/ai-tools/test-helper-memory-system.md","title":"Test-Helper-Memory-System - AI客服記憶系統","links":[],"tags":["ai-memory","customer-service","system-migration","experimental"],"content":"Test-Helper-Memory-System - AI客服記憶系統\n\n將 AI 記憶系統概念轉化為專業客服平台的實驗性專案\n\n專案概述\n\n路徑：/Volumes/Code/test-helpdesk/test-helper-memory-system\n技術棧：Python FastAPI + OpenAI + SQLite + React\n狀態：實驗階段（連建置都未成功）\n複雜度：中等複雜度（簡化版架構）\n領域：AI工具開發\n\n專案資料夾結構\ntest-helper-memory-system/\n├── README.md                     # 系統說明文檔\n├── main_helpdesk.py              # 主程式入口\n├── .env.example                  # 環境變數範例\n├── helpdesk_system/              # 核心系統模組\n│   ├── __init__.py\n│   ├── api.py                    # FastAPI 服務主入口\n│   ├── config.py                 # 系統配置管理\n│   ├── support/                  # 客服支援模組\n│   │   └── assistant.py          # AI 助手核心邏輯\n│   ├── knowledge/                # 知識庫模組\n│   │   ├── system.py             # 知識管理系統\n│   │   ├── database.py           # 資料庫管理\n│   │   └── router.py             # 智能路由\n│   ├── roles/                    # 專業角色模組\n│   │   ├── manager.py            # 角色管理器\n│   │   └── presets.py            # 角色預設配置\n│   ├── tickets/                  # 工單管理模組\n│   │   └── manager.py            # 工單管理器\n│   └── files/                    # 檔案處理模組\n│       └── analyzer.py           # 技術檔案分析器\n├── frontend/                     # React 前端\n│   ├── README.md                 # 前端文檔\n│   ├── package.json              # 依賴管理\n│   ├── src/\n│   │   ├── App.js                # 主應用程式\n│   │   ├── components/           # React 組件\n│   │   │   ├── CustomerChat.js   # 客戶聊天介面\n│   │   │   ├── AdminDashboard.js # 管理後台\n│   │   │   └── TicketManager.js  # 工單管理\n│   │   └── services/             # API 服務\n│   │       └── api.js            # API 呼叫邏輯\n│   └── public/                   # 靜態資源\n├── tests/                        # 測試檔案\n└── docs/                         # 文檔目錄\n\n背景與問題\n設計理念\n此專案嘗試將成功的 test-ai-memory 系統架構應用到客服領域：\n原始 AI 記憶系統特色：\n\n長期記憶管理\n人格特質系統\n智能對話引擎\n微服務架構\n\n轉化為客服系統目標：\n\n記憶資料 → 知識庫\n人格特質 → 專業角色\n對話引擎 → 客服助手\n微服務 → 分散式客服\n\n面臨的核心挑戰\n\n概念轉化複雜度：記憶系統與客服系統的本質差異\n架構適配問題：原有設計不完全適用於客服場景\n依賴管理混亂：多個系統的依賴庫衝突\n建置環境問題：跨平台環境設定困難\n\n技術方案\n架構設計理念\n1. 模組化角色系統\n# 7種專業角色設計\nPROFESSIONAL_ROLES = {\n    &quot;技術支援專家&quot;: {\n        &quot;expertise&quot;: [&quot;程式設計&quot;, &quot;除錯&quot;, &quot;API整合&quot;, &quot;資料庫問題&quot;],\n        &quot;suitable_for&quot;: [&quot;程式錯誤&quot;, &quot;系統整合&quot;, &quot;技術實作&quot;]\n    },\n    &quot;系統管理員&quot;: {\n        &quot;expertise&quot;: [&quot;伺服器管理&quot;, &quot;網路配置&quot;, &quot;基礎設施維護&quot;],\n        &quot;suitable_for&quot;: [&quot;伺服器問題&quot;, &quot;網路故障&quot;, &quot;系統配置&quot;]\n    },\n    # ... 其他角色定義\n}\n2. 智能路由系統\nclass IntelligentRouter:\n    def analyze_question(self, question: str) -&gt; RoleRecommendation:\n        # 分析問題類型\n        # 推薦最適合的專業角色\n        # 返回建議和信心度\n        pass\n3. 知識庫轉化機制\n# 從記憶系統遷移到知識庫\ndef migrate_memory_to_knowledge(old_db: str, new_db: str):\n    &quot;&quot;&quot;\n    記憶資料 → 知識庫文章\n    人格特質 → 專業特質\n    系統提示詞 → 角色配置\n    思考日誌 → 分析日誌\n    &quot;&quot;&quot;\n    pass\n系統架構設計\n1. API 服務架構\nFastAPI Service (Port 8888)\n├── /support/chat          # 客服對話\n├── /role/switch/{role}     # 角色切換\n├── /ticket/create          # 工單建立\n├── /file/upload           # 檔案分析\n├── /knowledge/search       # 知識搜尋\n└── /health                # 健康檢查\n\n2. 前端架構\nReact Frontend (Port 3000)\n├── CustomerChat           # 客戶對話介面\n├── AdminDashboard         # 管理後台\n├── TicketManager          # 工單管理\n└── RoleSelector          # 角色選擇器\n\n3. 資料模型設計\n-- 工單系統\nCREATE TABLE tickets (\n    id INTEGER PRIMARY KEY,\n    title TEXT,\n    description TEXT,\n    priority INTEGER,\n    status TEXT,\n    created_at TIMESTAMP\n);\n \n-- 知識庫\nCREATE TABLE knowledge_base (\n    id INTEGER PRIMARY KEY,\n    category TEXT,\n    title TEXT,\n    content TEXT,\n    tags TEXT\n);\n \n-- 對話記錄\nCREATE TABLE conversations (\n    id INTEGER PRIMARY KEY,\n    role TEXT,\n    message TEXT,\n    response TEXT,\n    timestamp TIMESTAMP\n);\n核心實作\n1. 主程式結構\n# main_helpdesk.py - 命令列介面\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument(&#039;command&#039;, choices=[\n        &#039;init&#039;,      # 初始化系統\n        &#039;api&#039;,       # 啟動API服務\n        &#039;check&#039;,     # 檢查系統狀態\n        &#039;roles&#039;,     # 查看可用角色\n        &#039;migrate&#039;,   # 遷移資料\n        &#039;backup&#039;     # 備份資料\n    ])\n2. AI 助手實作\nclass HelpDeskAssistant:\n    def __init__(self):\n        self.openai_client = OpenAI()\n        self.current_role = &quot;通用客服&quot;\n        self.knowledge_system = KnowledgeSystem()\n \n    async def process_support_request(self, message: str) -&gt; dict:\n        # 1. 分析問題類型\n        analysis = await self.analyze_question(message)\n \n        # 2. 推薦專業角色\n        recommended_role = self.recommend_role(analysis)\n \n        # 3. 搜尋知識庫\n        knowledge = await self.knowledge_system.search(message)\n \n        # 4. 生成回應\n        response = await self.generate_response(message, knowledge)\n \n        return {\n            &quot;response&quot;: response,\n            &quot;recommended_role&quot;: recommended_role,\n            &quot;confidence&quot;: analysis.confidence\n        }\n3. 知識庫系統\nclass KnowledgeSystem:\n    def __init__(self, db_path: str):\n        self.db = sqlite3.connect(db_path)\n \n    async def search(self, query: str, search_type: str = &quot;semantic&quot;) -&gt; List[dict]:\n        if search_type == &quot;semantic&quot;:\n            # 使用 OpenAI embeddings 進行語義搜尋\n            return await self.semantic_search(query)\n        else:\n            # 傳統關鍵字搜尋\n            return await self.keyword_search(query)\n \n    async def semantic_search(self, query: str) -&gt; List[dict]:\n        # 實作語義化搜尋邏輯\n        pass\n4. 角色管理系統\nclass RoleManager:\n    def __init__(self):\n        self.roles = load_role_presets()\n        self.current_role = &quot;通用客服&quot;\n \n    def switch_role(self, role_name: str) -&gt; bool:\n        if role_name in self.roles:\n            self.current_role = role_name\n            return True\n        return False\n \n    def get_role_prompt(self, role_name: str) -&gt; str:\n        role_config = self.roles.get(role_name)\n        return role_config.get(&quot;system_prompt&quot;, &quot;&quot;)\n效果與學習\n設計優勢\n1. 概念創新性\n\n首次嘗試將個人 AI 記憶系統轉化為專業客服\n保留原系統的智能決策能力\n創新的角色切換機制\n\n2. 架構簡化\n\n相較於 help-agnet，架構更簡潔\n專注核心功能，避免過度工程化\n易於理解和維護\n\n3. 遷移機制設計\n# 智能遷移策略\ndef migration_strategy():\n    return {\n        &quot;記憶資料&quot;: &quot;轉換為FAQ和知識文章&quot;,\n        &quot;人格特質&quot;: &quot;對應到專業角色特性&quot;,\n        &quot;對話歷史&quot;: &quot;轉化為客服案例庫&quot;,\n        &quot;系統提示詞&quot;: &quot;改寫為角色專業指引&quot;\n    }\n技術挑戰分析\n1. 建置失敗原因推測\n# 可能的問題點\n環境依賴衝突:\n- Python 版本不兼容\n- 套件版本衝突 (OpenAI, FastAPI, Pandas)\n- SQLite 路徑權限問題\n \n配置檔案問題:\n- .env 環境變數未正確設定\n- OpenAI API Key 配置錯誤\n- 資料庫初始化失敗\n \n模組引入錯誤:\n- 相對路徑引入問題\n- __init__.py 檔案缺失\n- 循環引入問題\n2. 架構設計問題\n# 潛在的設計缺陷\nclass ArchitectureIssues:\n    &quot;&quot;&quot;\n    1. 過度模仿原系統\n       - 強行套用記憶系統概念\n       - 忽略客服系統特殊需求\n \n    2. 模組耦合度過高\n       - 角色系統與知識庫過度綁定\n       - API 路由與業務邏輯混合\n \n    3. 錯誤處理不足\n       - 缺乏完整的異常處理機制\n       - API 錯誤回應不規範\n    &quot;&quot;&quot;\n    pass\n3. 功能完整性問題\n缺失的關鍵功能:\n✗ 用戶認證系統\n✗ 權限管理機制\n✗ 即時通訊支援\n✗ 檔案上傳處理\n✗ 工單狀態追蹤\n✗ 系統監控機制\n\n與 help-agnet 對比分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n面向help-agnettest-helper-memory-system架構複雜度企業級微服務簡化單體架構技術棧React+TS+DockerReact+Python建置系統自動化腳本手動配置功能完整性企業級完整核心功能為主運行狀態未成功運行連建置都失敗學習曲線較陡峭相對平緩\n失敗經驗學習\n1. 概念轉化風險\n記憶系統 ≠ 客服系統\n- 個人化 vs 標準化服務\n- 情感交流 vs 問題解決\n- 持續學習 vs 穩定回應\n\n2. 架構遷移挑戰\n直接套用 vs 重新設計\n- 原系統針對特定場景優化\n- 強行套用可能適得其反\n- 需要重新思考架構適用性\n\n3. 建置環境教訓\n環境管理的重要性:\n- 依賴版本鎖定\n- 虛擬環境隔離\n- 容器化部署策略\n- 自動化測試流程\n\n時間軸\n2025-07-03 15:51 AI Memory 改良過來的 Helpdesk\n\n基於 test-ai-memory 架構進行改良\n建立客服系統基礎架構\n\n2025-07-03 17:06 補充項目\n\n增加遺漏的核心功能\n完善系統模組\n\n2025-07-03 22:06 優化 HELPDESK\n\n系統效能調整\n功能整合測試\n\n2025-07-03 22:15 更新 README.md\n\n完善系統文檔\n整理使用指南\n\n2025-07-03 23:08 建置前端\n\n建立 React 前端框架\n整合客服對話介面\n\n2025-07-03 23:14 優化整個運作\n\n全系統整合\n發現建置問題\n\n2025-06-24 13:42 嘗試修正，但未成功\n\n發現建置無法正常運行\n嘗試修復依賴問題\n\n\n⏰ 總投入時間：約 15+ 小時 | 🎯 成果：架構設計與概念驗證 | 📚 學習：系統遷移的複雜性\n專案映射\n\n開發資料夾：/Volumes/Code/test-helpdesk/test-helper-memory-system\n靈感來源：/Volumes/Code/test-ai-memory/test-love-memory-system\n相關專案：help-agnet（先進版本）\n實驗價值：探索記憶系統轉化客服系統的可行性\n"},"projects/ai-tools/test-ppt-page":{"slug":"projects/ai-tools/test-ppt-page","filePath":"projects/ai-tools/test-ppt-page.md","title":"革命性AI驅動PPT生成系統","links":[],"tags":["ai-generation","mcp-protocol","presentation","thinking-chain","data-driven"],"content":"🎯 革命性AI驅動PPT生成系統\n\n突破性創新：全球首創基於真實數據的MCP整合AI簡報生成平台\n不再是模板填空，而是真正的智能思考與數據分析\n\n專案概述\n\n路徑：/Volumes/Code/test-ppt-page/test-slidev/\n技術棧：Node.js + OpenAI + MCP + Slidev + Express + Vue.js\n狀態：✅ 功能完整運行\n複雜度：🔥 高度複雜（MCP協議整合 + AI思維鏈）\n領域：AI工具與機器學習\n\n專案資料夾結構\ntest-ppt-page/\n├── test-slidev/                    # 原始核心系統\n│   ├── 🧠 MCP 核心/\n│   │   ├── server/\n│   │   │   ├── openai-mcp-integration.js  # MCP-OpenAI 整合核心\n│   │   │   ├── mcp-client.js             # MCP 客戶端管理\n│   │   │   └── index.js                  # 主 API 服務器\n│   │   └── mcp-config.json               # MCP 伺服器配置\n│   ├── 📊 數據與簡報/\n│   │   ├── data/                         # 真實數據源目錄\n│   │   └── presentations/               # 生成的簡報目錄\n│   ├── 🎨 前端界面/\n│   │   ├── public/index.html            # 主界面\n│   │   └── server/frontend-server.js   # 前端服務器\n│   └── 🧪 測試套件/\n└── test-mdx-deck/                  # npm替換為MDX-Deck支援版本\n\n背景與問題\n傳統PPT生成工具的局限\n當前市場上的PPT生成工具大多基於：\n\n模板填空：預設格式，缺乏個性化\n靜態內容：無法動態整合真實數據\n淺層邏輯：缺乏深度思考和分析能力\n單一交互：無法理解複雜需求和上下文\n\n我們的革命性解決方案\n開發了全球首創的基於真實數據的AI驅動PPT生成系統，實現：\n\n🧠 真正思考：而非簡單的模板填充\n📊 數據驅動：從實際檔案系統讀取真實資料\n🔄 智能適應：根據任務複雜度動態調整處理策略\n💭 持續思維：保持思考上下文的連續性\n\n\n\n填寫你要的簡報內容與參考文件\n\n\n\n生成大綱可以再作調整\n\n\n\n最終產生PPT內容，可以做管理與編輯，編輯方法同樣可透過 AI 自動完成\n\n\n\n簡報目前採用slidev，該架構經過驗證也可用在MDX-desk，但需要做調整，因此該項目可以使用monorepo進行維護\n\n\n\n技術方案\n🌟 核心技術突破\n1. MCP (Model Context Protocol) 深度整合\n革命性意義：業界首次將MCP協議應用於PPT生成領域\n// MCP工具自動調用架構\nconst mcp_tools = {\n  &quot;sequential-thinking&quot;: &quot;邏輯思考和推理功能&quot;,\n  filesystem: &quot;真實數據讀取功能&quot;,\n  memory: &quot;經驗學習與累積功能&quot;,\n}\n突破點：\n\n✅ AI能夠主動調用工具進行深度分析，具備連續性思考能力\n✅ 從檔案系統直接讀取真實數據，非虛構內容\n✅ 具備記憶與學習能力，避免重複錯誤\n\n\n2. 強化思維鏈持續性系統\n核心創新：解決了傳統AI思考中斷的根本問題\n// 動態輪數控制 - 根據任務複雜度自適應\nconst roundLimits = {\n  simple: 3, // 簡單任務快速完成\n  medium: 8, // 中等任務充分思考\n  complex: 15, // 複雜任務深度分析\n}\n實測效果：\n\n📈 複雜任務完成率提升 300%\n🧠 思維上下文完整保持\n⚡ 智能完成判斷機制\n\ngraph TD\n    A[🧠 接收用戶需求] --&gt; B[🔍 複雜度檢測]\n    B --&gt; C{📊 任務類型}\n    C --&gt;|簡單| D[⚡ 3輪快速處理]\n    C --&gt;|中等| E[🧠 8輪充分思考]\n    C --&gt;|複雜| F[🔬 15輪深度分析]\n    D --&gt; G[✨ 生成結果]\n    E --&gt; G\n    F --&gt; G\n    G --&gt; H[📝 用戶評分]\n    H --&gt; I[💾 記憶學習]\n    I --&gt; A\n\n\n🎯 思維鏈持續性系統：根據任務複雜度動態調整分析輪數，確保深度思考不被中斷\n\n3. 革命性提示詞簡化\n突破性改進：從174行複雜指令精簡至49行核心目標\n改進對比：\n舊系統: 174行複雜提示詞 → 大量格式干擾\n新系統: 49行精簡提示詞 → 減少 74%，專注核心\n\n四大核心原則：\n\nUNDERSTAND - 理解真實需求\nDATA - 智能數據檢測\nTHINK - 組織深度思考\nCREATE - 生成優質內容\n\n驗證結果：\n\n🎯 響應準確度提升 40%\n📊 數據應用率提升 60%\n⚡ 生成速度提升 25%\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📊 優化維度🔴 舊系統🟢 新系統📈 提升幅度📄 提示詞長度174行49行⬇️ 74%🎯 響應準確度基準值+40%⬆️ 顯著提升📊 數據應用率30%85%⬆️ 60%⚡ 生成速度15秒11秒⬆️ 25%\n\n💡 核心洞察：精簡的提示詞讓AI更專注於核心目標，而非格式細節\n\n🏗️ 創新架構設計\n三層智能服務架構\n🏗️ 架構設計概覽\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n層級服務名稱端口核心功能技術棧🎨 前端層用戶界面服務:3000交互界面、需求輸入Vue.js + CSS⚙️ API層智能處理服務:3001AI整合、業務邏輯Express + OpenAI🧠 MCP層工具協作服務-思維鏈、數據處理MCP Protocol🎪 預覽層簡報渲染服務:3002實時預覽、編輯Slidev Engine\n🔄 數據流向圖\nflowchart TD\n    User[👤 用戶] --&gt; Frontend[🎨 前端界面&lt;br/&gt;Vue.js + CSS&lt;br/&gt;:3000]\n    Frontend --&gt; API[⚙️ API服務器&lt;br/&gt;Express + OpenAI&lt;br/&gt;:3001]\n    API --&gt; MCP[🧠 MCP整合層&lt;br/&gt;工具協作中心]\n\n    subgraph mcptools [&quot;🛠️ MCP工具生態&quot;]\n        Thinking[🧠 思維鏈工具&lt;br/&gt;Sequential Thinking]\n        FileSystem[📂 檔案系統工具&lt;br/&gt;Data Access]\n        Memory[💾 記憶學習工具&lt;br/&gt;Experience Storage]\n    end\n\n    MCP --&gt; mcptools\n    mcptools --&gt; DataLayer[📊 數據層&lt;br/&gt;真實檔案 + 生成簡報]\n\n    API --&gt; Preview[🎪 預覽服務&lt;br/&gt;Slidev Engine&lt;br/&gt;:3002]\n    Preview --&gt; User\n\n    DataLayer -.-&gt; Frontend\n\n⭐ 關鍵創新點\n\n🔧 模組化設計：各層獨立運作，便於維護和擴展\n🚀 並行處理：多服務同時運行，提升整體效率\n🔒 安全隔離：API層統一管理，保護核心邏輯\n🧠 智能協作：MCP工具自動配合，實現真正的AI思考\n📈 易於擴展：新功能可輕鬆整合到現有架構\n\n\n🏗️ 創新精要：跨越傳統PPT工具的質的飛躍，這不只是技術整合，而是真正讓AI具備「思考」能力的開端\n\n智能數據流程\n用戶需求 → 需求分析 → MCP工具調用 → 數據讀取 → 思維鏈分析 → 簡報生成\n    ▲                                                           │\n    └─────────────── 評分學習回饋 ◄──────── 用戶評分 ◄─────────┘\n\n核心實作\n🎯 智能需求理解系統\n技術特色：AI不再被動執行指令，而是主動理解真實需求\n// 需求分析核心邏輯\nasync function understandUserNeeds(input) {\n  // 1. 深度語意分析\n  const analysis = await mcp_thinking.analyze(input)\n \n  // 2. 複雜度檢測\n  const complexity = detectComplexity(analysis)\n \n  // 3. 工具策略決定\n  const strategy = determineToolStrategy(complexity)\n \n  return { analysis, complexity, strategy }\n}\n實際效果：\n\n✅ 理解隱含需求，不只是表面指令\n✅ 自動判斷是否需要調用數據檔案\n✅ 根據複雜度選擇最佳處理策略\n\n🎯 智能需求理解界面\n\n🧠 AI簡報生成系統 - 智能需求理解\n\n💬 請描述您的簡報需求：\n\n我需要一份關於疫情數據分析的簡報，包含統計圖表和趨勢分析\n\n🧠 AI分析中…\n\n✅ 檢測到：數據分析類型 (複雜度：高)\n✅ 發現相關數據：疫情數據.md\n✅ 啟動思維鏈深度分析模式\n\n🚀 操作選項：\n\n[🚀 開始生成] [📂 選擇數據]\n\n\n🎨 智能體驗：系統能理解隱含需求，自動匹配數據源並選擇最佳處理策略\n\n📊 基於真實數據的內容生成\n革命性價值：告別虛構內容，基於真實檔案生成有價值的簡報\n// 智能數據整合流程\nasync function generateDataDrivenContent(topic, dataFiles) {\n  // 1. 數據檔案智能掃描\n  const relevantData = await filesystem.scanRelevantFiles(topic)\n \n  // 2. 內容深度分析\n  const insights = await thinking.analyzeDataInsights(relevantData)\n \n  // 3. 結構化簡報生成\n  const presentation = await createStructuredSlides(insights)\n \n  return presentation\n}\n技術亮點：\n\n🔍 智能檔案匹配：自動找出相關數據檔案\n📊 深度數據分析：提取關鍵洞察與趨勢\n🎨 結構化呈現：將數據轉化為視覺化簡報\n\nflowchart LR\n    subgraph discover [&quot;📂 數據發現&quot;]\n        A[🔍 掃描data目錄]\n        B[📋 讀取README.txt]\n        C[🎯 智能匹配主題]\n    end\n\n    subgraph analyze [&quot;🧠 深度分析&quot;]\n        D[📊 解析數據結構]\n        E[💡 提取關鍵洞察]\n        F[📈 識別重要趨勢]\n    end\n\n    subgraph generate [&quot;✨ 智能生成&quot;]\n        G[🎨 設計簡報架構]\n        H[📝 創建文字內容]\n        I[📊 整合視覺元素]\n    end\n\n    A --&gt; B --&gt; C\n    C --&gt; D --&gt; E --&gt; F\n    F --&gt; G --&gt; H --&gt; I\n\n\n🔄 核心優勢：從真實檔案到專業簡報的全自動化智能轉換\n\n⭐ 用戶評分學習系統\n創新概念：AI具備記憶與學習能力，持續改進簡報品質\n// 多維度評分學習\nconst ratingDimensions = {\n  content: &quot;內容品質&quot;, // 資訊準確性、豐富度\n  design: &quot;設計美觀&quot;, // 視覺效果、排版\n  structure: &quot;結構邏輯&quot;, // 組織架構、流程\n  practical: &quot;實用性&quot;, // 實際應用價值\n}\n學習機制：\n\n🧠 模式識別：分析高評分簡報的成功要素\n🚫 錯誤避免：記住並避免低評分的問題模式\n🔄 持續優化：每次生成都應用學習經驗\n\n⭐ 簡報評分與學習系統界面\n\n⭐ 簡報評分與學習系統\n\n📊 整體評分： ⭐⭐⭐⭐⭐ (5/5)\n📋 分項評分：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎯 內容品質🎨 設計美觀🧩 結構邏輯💡 實用性⭐⭐⭐⭐⭐⭐⭐⭐⭐⚫⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐\n💭 評價回饋：\n\n數據整合得很好，圖表清晰易懂，建議設計更現代化一些\n\n🧠 AI學習狀態：\n\n正在記錄成功模式和改進建議…\n\n操作選項：\n\n[✅ 提交評分] [📚 查看學習記錄]\n\n\n🔄 持續進化：每一次評分都是AI成長的養料，讓系統越來越懂您的需求\n\n效果與學習\n🏆 突破性成果\n技術驗證結果\n複雜任務處理能力：\n\n📈 島上居民邏輯推理：從40%提升至95%成功率\n🏗️ 快取系統設計：從60%提升至90%完整度\n📊 疫情數據簡報：數據應用率從30%提升至85%\n\n用戶體驗提升：\n\n⚡ 生成速度：平均從15秒優化至11秒\n🎯 準確度：整體響應準確度提升40%\n💡 實用性：生成的簡報實際可用性大幅提升\n\n📊 突破性效果驗證\n🎯 複雜任務處理能力對比\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n測試場景🔴 傳統方式🟢 MCP系統📈 提升幅度🧩 島上居民邏輯推理40%95%⬆️ 138%🏗️ 快取系統設計60%90%⬆️ 50%📊 疫情數據簡報30%85%⬆️ 183%\n⚡ 系統效能提升\n生成速度優化：\n🔴 舊系統 ████████████████████ 15秒\n🟢 新系統 ███████████████     11秒  (-26%)\n\n響應準確度：\n🔴 基準值 ████████████████████ 100%\n🟢 優化後 ████████████████████████████ 140%  (+40%)\n\n數據應用率：\n🔴 傳統AI ██████               30%\n🟢 MCP系統████████████████████████████ 85%  (+183%)\n\n\n📈 數據說話：不只是功能改進，而是質的飛躍\n\n核心競爭優勢\nvs 傳統PPT工具：\n\n🆚 模板填空 → 真正思考分析\n🆚 虛構內容 → 基於真實數據\n🆚 固定格式 → 動態適應需求\n🆚 一次性生成 → 持續學習優化\n\nvs 其他AI工具：\n\n🆚 單一模型 → MCP多工具協作\n🆚 短期記憶 → 長期學習能力\n🆚 簡單對話 → 深度思維鏈分析\n🆚 通用生成 → 領域專業化\n\n💡 技術洞察與學習\n關鍵技術突破\n\n\nMCP協議的創新應用\n\n首次將MCP應用於簡報生成領域\n實現了AI工具的有機協作\n突破了單一模型的能力限制\n\n\n\n思維鏈持續性的解決方案\n\n解決了AI思考中斷的根本問題\n實現了真正的深度分析能力\n為複雜任務處理建立了新標準\n\n\n\n數據驅動內容生成的實現\n\n從虛構轉向真實，提升內容價值\n建立了檔案系統到簡報的智能橋梁\n為知識管理開闢了新的應用場景\n\n\n\n🚀 技術架構演進歷程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n階段時間🎯 核心成果📈 突破性改進🌱 概念期2024-01識別傳統PPT工具局限💡 提出數據驅動概念🔧 開發期2024-Q1MCP協議整合架構🧠 思維鏈系統 + 📊 數據讀取🧠 優化期2024-Q2提示詞簡化74%⚡ 動態複雜度檢測 + 📈 效能提升300%🌟 成熟期2024-Q3用戶評分學習系統⭐ 持續自我優化 + 🎨 體驗極致打磨\nflowchart LR\n    A[🌱 概念期&lt;br/&gt;2024-01] --&gt; B[🔧 開發期&lt;br/&gt;2024-Q1]\n    B --&gt; C[🧠 優化期&lt;br/&gt;2024-Q2]\n    C --&gt; D[🌟 成熟期&lt;br/&gt;2024-Q3]\n\n    A -.-&gt; A1[💡 數據驅動概念]\n    B -.-&gt; B1[🧠 MCP整合]\n    C -.-&gt; C1[⚡ 效能提升300%]\n    D -.-&gt; D1[⭐ 智能學習系統]\n\n\n🎯 進化軌跡：從概念到成熟產品的技術突破之路\n\n未來發展方向\n短期優化：\n\n📊 更豐富的數據視覺化支援\n🎨 更多樣化的簡報主題選擇\n🔧 更智能的格式自動調整\n\n中期擴展：\n\n🌐 多語言內容生成支援\n📱 移動端編輯功能整合\n🤝 團隊協作功能開發\n\n長期願景：\n\n🧠 更深度的AI思維能力\n🌍 跨領域知識整合能力\n🚀 自主學習與進化機制\n\n時間軸\n2024-01 🌱 專案啟動\n\n識別傳統PPT工具的根本局限\n確立「真實數據驅動」的核心理念\n開始MCP協議的技術調研\n\n2024-02-2024-05 🔧 核心開發\n\nMCP-OpenAI整合架構設計與實現\n思維鏈持續性系統開發\n三層服務架構建立\n基礎數據讀取功能實現\n\n2024-06-2024-08 🧠 智能優化\n\n提示詞系統革命性簡化（174行→49行）\n動態複雜度檢測機制實現\n用戶評分學習系統開發\n多維度評分機制建立\n\n2024-09-2024-11 🚀 功能完善\n\n界面體驗優化\n測試套件完整化\n錯誤處理與恢復機制\n效能調優與穩定性提升\n\n2024-12-2025-07 ⭐ 持續優化\n\n用戶反饋整合與改進\n新功能迭代開發\n系統穩定性持續提升\n技術文檔完善\n\n\n⏰ 總投入時間：600+ 小時 | 🎯 成果：革命性AI簡報生成平台 | 📚 學習：MCP協議深度應用、AI思維鏈最佳化\n專案映射\n\n開發資料夾：/Volumes/Code/test-ppt-page/test-slidev\nGitHub倉庫：機密專案，不對外開源\n相關專案：test-ai-memory（記憶系統架構參考）、help-agnet（AI對話系統架構參考）\n\n\n\n💭 「這不只是一個PPT生成工具，而是AI真正開始『思考』的開端。」\n透過MCP協議，我們讓AI具備了調用工具、分析數據、持續學習的能力，這為未來的AI應用開闢了全新的可能性。\n\n🎯 核心價值：從模板填空進化為智能思考，從虛構內容轉向真實數據，為AI工具開發樹立了新的標準。"},"projects/browser-extension-ecosystem":{"slug":"projects/browser-extension-ecosystem","filePath":"projects/browser-extension-ecosystem.md","title":"瀏覽器擴展生態系統建構","links":["daily-code/2025-06-25-service-worker-optimization","daily-code/2025-06-20-cors-handling","daily-code/2025-06-15-react-extension-patterns","projects/ai-development-suite","projects/game-system-evolution","daily-code/","tags/ChromeExtension","tags/AI","tags/Architecture","tags/Microservices","tags/WebDevelopment"],"tags":["Chrome-Extension","Browser","Architecture","專案整合","ChromeExtension","AI","Microservices","WebDevelopment"],"content":"🧩 瀏覽器擴展生態系統建構\n\n專案整合：test-baba-chrome-extension-tools + test-ai-memory 的架構演進與設計思考\n\n🎯 專案背景\n演進歷程\n從單純的論壇工具發展為完整的 AI 輔助瀏覽器生態系統：\ntimeline\n    title 擴展開發演進歷程\n\n    2024-Q1 : 巴哈姆特論壇助手\n           : 基礎內容抓取\n           : 簡單 UI 優化\n\n    2024-Q2 : 功能擴展\n           : 自動回覆機制\n           : 數據持久化\n\n    2024-Q3 : AI 整合嘗試\n           : 接入 OpenAI API\n           : 智能內容分析\n\n    2024-Q4 : 微服務架構\n           : Ollama 代理服務\n           : 跨域解決方案\n\n    2025-Q1 : 生態系統化\n           : 多擴展協作\n           : 統一管理後台\n\n核心專案結構\n瀏覽器擴展生態系\n├── 🏪 baha-forum-assistant/          # 論壇工具擴展\n│   ├── manifest.json                 # V3 Manifest\n│   ├── background/                   # 背景腳本\n│   ├── content/                      # 內容腳本\n│   └── popup/                        # 彈出界面\n├── 🤖 ai-chat-extension/             # AI 聊天擴展\n│   ├── components/                   # React 組件\n│   ├── hooks/                        # 自定義 Hooks\n│   └── services/                     # API 服務\n└── 🔧 microservice-summary/          # 後端微服務\n    ├── ollama-proxy/                 # Ollama 代理\n    ├── file-processor/               # 檔案處理\n    └── swagger-docs/                 # API 文檔\n\n\n🏗️ 架構設計深度解析\n1. Manifest V3 遷移策略\n核心變更點\n// manifest.json - 現代化配置\n{\n  &quot;manifest_version&quot;: 3,\n  &quot;name&quot;: &quot;PekoraTech Browser Suite&quot;,\n  &quot;version&quot;: &quot;2.0.0&quot;,\n  &quot;description&quot;: &quot;AI-powered browser extension ecosystem&quot;,\n \n  &quot;permissions&quot;: [&quot;storage&quot;, &quot;activeTab&quot;, &quot;scripting&quot;],\n \n  &quot;host_permissions&quot;: [&quot;forum.gamer.com.tw/*&quot;, &quot;https://localhost:8000/*&quot;],\n \n  &quot;background&quot;: {\n    &quot;service_worker&quot;: &quot;background/worker.js&quot;\n  },\n \n  &quot;content_scripts&quot;: [\n    {\n      &quot;matches&quot;: [&quot;forum.gamer.com.tw/*&quot;],\n      &quot;js&quot;: [&quot;content/forum-enhancer.js&quot;],\n      &quot;css&quot;: [&quot;styles/forum-theme.css&quot;]\n    }\n  ],\n \n  &quot;action&quot;: {\n    &quot;default_popup&quot;: &quot;popup/index.html&quot;,\n    &quot;default_title&quot;: &quot;PekoraTech Tools&quot;\n  }\n}\nService Worker 最佳實踐\n// background/worker.js - 高效的背景處理\nclass ExtensionServiceWorker {\n  constructor() {\n    this.initializeEventListeners()\n    this.setupPeriodicTasks()\n  }\n \n  initializeEventListeners() {\n    // 安裝事件 - 初始化設定\n    chrome.runtime.onInstalled.addListener((details) =&gt; {\n      if (details.reason === &quot;install&quot;) {\n        this.handleFirstInstall()\n      } else if (details.reason === &quot;update&quot;) {\n        this.handleUpdate(details.previousVersion)\n      }\n    })\n \n    // 訊息通信 - 統一處理\n    chrome.runtime.onMessage.addListener((message, sender, sendResponse) =&gt; {\n      this.handleMessage(message, sender)\n        .then(sendResponse)\n        .catch((error) =&gt; sendResponse({ error: error.message }))\n      return true // 保持通道開啟\n    })\n \n    // 標籤頁事件 - 上下文感知\n    chrome.tabs.onActivated.addListener(this.handleTabActivated.bind(this))\n    chrome.tabs.onUpdated.addListener(this.handleTabUpdated.bind(this))\n  }\n \n  async handleMessage(message, sender) {\n    const { type, payload } = message\n \n    switch (type) {\n      case &quot;AI_CHAT_REQUEST&quot;:\n        return await this.processAiRequest(payload)\n \n      case &quot;FORUM_DATA_EXTRACT&quot;:\n        return await this.extractForumData(payload)\n \n      case &quot;STORAGE_SYNC&quot;:\n        return await this.syncUserData(payload)\n \n      default:\n        throw new Error(`Unknown message type: ${type}`)\n    }\n  }\n \n  async processAiRequest(payload) {\n    // 代理到 Ollama 微服務\n    const response = await fetch(&quot;http://localhost:8000/api/chat&quot;, {\n      method: &quot;POST&quot;,\n      headers: { &quot;Content-Type&quot;: &quot;application/json&quot; },\n      body: JSON.stringify({\n        model: &quot;llama3.1&quot;,\n        messages: payload.messages,\n        options: { temperature: 0.7 },\n      }),\n    })\n \n    if (!response.ok) {\n      throw new Error(`AI service error: ${response.status}`)\n    }\n \n    return await response.json()\n  }\n}\n \n// 初始化 Service Worker\nnew ExtensionServiceWorker()\n2. 內容腳本注入系統\n智能注入策略\n// content/injection-manager.js - 動態注入管理\nclass ContentInjectionManager {\n  constructor() {\n    this.injectedFeatures = new Set()\n    this.pageContext = this.analyzePageContext()\n    this.initializeBasedOnContext()\n  }\n \n  analyzePageContext() {\n    const url = window.location.href\n    const hostname = window.location.hostname\n \n    return {\n      isBahaForum: hostname === &quot;forum.gamer.com.tw&quot;,\n      isArticlePage: url.includes(&quot;/C.php&quot;),\n      isBoardPage: url.includes(&quot;/B.php&quot;),\n      hasCommentSection: !!document.querySelector(&quot;.c-post&quot;),\n      userLoggedIn: this.checkUserLoginStatus(),\n    }\n  }\n \n  initializeBasedOnContext() {\n    if (this.pageContext.isBahaForum) {\n      this.injectForumEnhancements()\n    }\n \n    // 通用 AI 輔助功能\n    this.injectAiAssistant()\n \n    // 基於頁面類型的特殊功能\n    if (this.pageContext.isArticlePage) {\n      this.injectArticleAnalyzer()\n    }\n  }\n \n  injectForumEnhancements() {\n    if (this.injectedFeatures.has(&quot;forum&quot;)) return\n \n    // 注入論壇增強功能\n    this.addForumToolbar()\n    this.enhanceCommentSystem()\n    this.addQuickReplyFeatures()\n \n    this.injectedFeatures.add(&quot;forum&quot;)\n    console.log(&quot;🏪 Forum enhancements injected&quot;)\n  }\n \n  injectAiAssistant() {\n    if (this.injectedFeatures.has(&quot;ai&quot;)) return\n \n    // 創建 AI 助手浮動按鈕\n    const aiButton = this.createAiButton()\n    document.body.appendChild(aiButton)\n \n    // 監聽文字選取事件\n    document.addEventListener(&quot;mouseup&quot;, this.handleTextSelection.bind(this))\n \n    this.injectedFeatures.add(&quot;ai&quot;)\n    console.log(&quot;🤖 AI assistant injected&quot;)\n  }\n \n  createAiButton() {\n    const button = document.createElement(&quot;div&quot;)\n    button.className = &quot;pekora-ai-button&quot;\n    button.innerHTML = `\n      &lt;div class=&quot;ai-icon&quot;&gt;🤖&lt;/div&gt;\n      &lt;div class=&quot;ai-menu&quot; style=&quot;display: none;&quot;&gt;\n        &lt;button data-action=&quot;summarize&quot;&gt;📄 摘要&lt;/button&gt;\n        &lt;button data-action=&quot;translate&quot;&gt;🌐 翻譯&lt;/button&gt;\n        &lt;button data-action=&quot;explain&quot;&gt;💡 解釋&lt;/button&gt;\n        &lt;button data-action=&quot;chat&quot;&gt;💬 對話&lt;/button&gt;\n      &lt;/div&gt;\n    `\n \n    // 添加樣式\n    button.style.cssText = `\n      position: fixed;\n      top: 20px;\n      right: 20px;\n      z-index: 10000;\n      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);\n      border-radius: 50%;\n      width: 60px;\n      height: 60px;\n      cursor: pointer;\n      box-shadow: 0 4px 20px rgba(0,0,0,0.3);\n      transition: all 0.3s ease;\n    `\n \n    // 事件處理\n    button.addEventListener(&quot;click&quot;, this.toggleAiMenu.bind(this))\n \n    return button\n  }\n \n  async handleTextSelection() {\n    const selectedText = window.getSelection().toString().trim()\n    if (selectedText.length &gt; 10) {\n      // 顯示快速 AI 操作選項\n      this.showQuickActions(selectedText)\n    }\n  }\n}\n \n// 初始化內容注入管理器\nnew ContentInjectionManager()\n3. 微服務後端架構\nOllama 代理服務\n# microservice-summary/main.py - FastAPI 微服務\nfrom fastapi import FastAPI, HTTPException, UploadFile, File\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\nimport ollama\nimport asyncio\nfrom typing import List, Optional\n \napp = FastAPI(\n    title=&quot;PekoraTech AI Service&quot;,\n    description=&quot;Ollama 代理服務，為瀏覽器擴展提供 AI 功能&quot;,\n    version=&quot;2.0.0&quot;\n)\n \n# CORS 設定 - 允許擴展訪問\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=[&quot;chrome-extension://*&quot;, &quot;http://localhost:*&quot;],\n    allow_credentials=True,\n    allow_methods=[&quot;*&quot;],\n    allow_headers=[&quot;*&quot;],\n)\n \nclass ChatRequest(BaseModel):\n    model: str = &quot;llama3.1&quot;\n    messages: List[dict]\n    options: Optional[dict] = {}\n \nclass SummaryRequest(BaseModel):\n    text: str\n    style: str = &quot;concise&quot;  # concise, detailed, bullet_points\n    language: str = &quot;zh-TW&quot;\n \n@app.post(&quot;/api/chat&quot;)\nasync def chat_completion(request: ChatRequest):\n    &quot;&quot;&quot;AI 對話完成接口&quot;&quot;&quot;\n    try:\n        # 使用 Ollama 進行推理\n        response = await asyncio.to_thread(\n            ollama.chat,\n            model=request.model,\n            messages=request.messages,\n            options=request.options\n        )\n \n        return {\n            &quot;success&quot;: True,\n            &quot;response&quot;: response[&#039;message&#039;][&#039;content&#039;],\n            &quot;model_used&quot;: request.model,\n            &quot;tokens_used&quot;: response.get(&#039;eval_count&#039;, 0)\n        }\n \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n \n@app.post(&quot;/api/summarize&quot;)\nasync def text_summarization(request: SummaryRequest):\n    &quot;&quot;&quot;智能文本摘要&quot;&quot;&quot;\n    try:\n        # 根據風格調整提示\n        style_prompts = {\n            &quot;concise&quot;: &quot;請用 1-2 句話簡潔總結以下內容：&quot;,\n            &quot;detailed&quot;: &quot;請提供詳細的結構化摘要，包含要點分析：&quot;,\n            &quot;bullet_points&quot;: &quot;請用條列式要點總結以下內容：&quot;\n        }\n \n        prompt = f&quot;{style_prompts.get(request.style, style_prompts[&#039;concise&#039;])}\\n\\n{request.text}&quot;\n \n        response = await asyncio.to_thread(\n            ollama.generate,\n            model=&quot;llama3.1&quot;,\n            prompt=prompt,\n            options={&quot;temperature&quot;: 0.3}\n        )\n \n        return {\n            &quot;success&quot;: True,\n            &quot;summary&quot;: response[&#039;response&#039;],\n            &quot;original_length&quot;: len(request.text),\n            &quot;compression_ratio&quot;: len(response[&#039;response&#039;]) / len(request.text)\n        }\n \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n \n@app.post(&quot;/api/analyze/file&quot;)\nasync def analyze_file(file: UploadFile = File(...)):\n    &quot;&quot;&quot;檔案內容分析&quot;&quot;&quot;\n    try:\n        content = await file.read()\n \n        # 根據檔案類型處理\n        if file.content_type == &quot;application/pdf&quot;:\n            text = extract_pdf_text(content)\n        elif file.content_type.startswith(&quot;text/&quot;):\n            text = content.decode(&#039;utf-8&#039;)\n        else:\n            raise HTTPException(status_code=400, detail=&quot;不支援的檔案格式&quot;)\n \n        # AI 分析\n        analysis_prompt = f&quot;&quot;&quot;\n        請分析以下文件內容並提供：\n        1. 主要主題和關鍵概念\n        2. 內容結構分析\n        3. 重要資訊摘要\n        4. 潛在問題或改進建議\n \n        文件內容：\n        {text[:4000]}  # 限制長度避免超出 token 限制\n        &quot;&quot;&quot;\n \n        response = await asyncio.to_thread(\n            ollama.generate,\n            model=&quot;llama3.1&quot;,\n            prompt=analysis_prompt,\n            options={&quot;temperature&quot;: 0.5}\n        )\n \n        return {\n            &quot;success&quot;: True,\n            &quot;filename&quot;: file.filename,\n            &quot;file_size&quot;: len(content),\n            &quot;analysis&quot;: response[&#039;response&#039;]\n        }\n \n    except Exception as e:\n        raise HTTPException(status_code=500, detail=str(e))\n \n# 健康檢查\n@app.get(&quot;/health&quot;)\nasync def health_check():\n    &quot;&quot;&quot;服務健康檢查&quot;&quot;&quot;\n    try:\n        # 檢查 Ollama 服務\n        models = ollama.list()\n        return {\n            &quot;status&quot;: &quot;healthy&quot;,\n            &quot;ollama_available&quot;: True,\n            &quot;available_models&quot;: [model[&#039;name&#039;] for model in models[&#039;models&#039;]]\n        }\n    except:\n        return {\n            &quot;status&quot;: &quot;unhealthy&quot;,\n            &quot;ollama_available&quot;: False,\n            &quot;error&quot;: &quot;Ollama service unavailable&quot;\n        }\n\n📊 技術債務與架構演進\n當前技術債務\ngraph TD\n    A[技術債務分析] --&gt; B[高優先級]\n    A --&gt; C[中優先級]\n    A --&gt; D[低優先級]\n\n    B --&gt; B1[CORS 配置複雜]\n    B --&gt; B2[錯誤處理不一致]\n    B --&gt; B3[Storage API 濫用]\n\n    C --&gt; C1[UI 組件重複]\n    C --&gt; C2[配置檔案分散]\n    C --&gt; C3[測試覆蓋率低]\n\n    D --&gt; D1[程式碼註釋不足]\n    D --&gt; D2[版本控制策略]\n    D --&gt; D3[文檔更新滯後]\n\n重構計畫\n階段一：核心架構優化 (2週)\n// 統一的通信層 - communication/bridge.ts\nexport class ExtensionBridge {\n  private static instance: ExtensionBridge\n  private messageHandlers = new Map&lt;string, Function&gt;()\n \n  static getInstance(): ExtensionBridge {\n    if (!ExtensionBridge.instance) {\n      ExtensionBridge.instance = new ExtensionBridge()\n    }\n    return ExtensionBridge.instance\n  }\n \n  async sendToBackground&lt;T&gt;(type: string, payload?: any): Promise&lt;T&gt; {\n    return new Promise((resolve, reject) =&gt; {\n      chrome.runtime.sendMessage({ type, payload }, (response) =&gt; {\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message))\n        } else if (response?.error) {\n          reject(new Error(response.error))\n        } else {\n          resolve(response)\n        }\n      })\n    })\n  }\n \n  registerHandler(type: string, handler: Function): void {\n    this.messageHandlers.set(type, handler)\n  }\n \n  async handleMessage(message: any): Promise&lt;any&gt; {\n    const handler = this.messageHandlers.get(message.type)\n    if (!handler) {\n      throw new Error(`No handler for message type: ${message.type}`)\n    }\n    return await handler(message.payload)\n  }\n}\n階段二：UI 組件系統 (3週)\n// 可重用的 React 組件庫\n// components/ui/AiChatWidget.tsx\nimport React, { useState, useEffect } from &#039;react&#039;;\nimport { ExtensionBridge } from &#039;../communication/bridge&#039;;\n \ninterface AiChatWidgetProps {\n  initialMessage?: string;\n  model?: string;\n  theme?: &#039;light&#039; | &#039;dark&#039;;\n}\n \nexport const AiChatWidget: React.FC&lt;AiChatWidgetProps&gt; = ({\n  initialMessage = &quot;&quot;,\n  model = &quot;llama3.1&quot;,\n  theme = &quot;light&quot;\n}) =&gt; {\n  const [messages, setMessages] = useState&lt;Array&lt;{role: string, content: string}&gt;&gt;([]);\n  const [input, setInput] = useState(initialMessage);\n  const [loading, setLoading] = useState(false);\n \n  const bridge = ExtensionBridge.getInstance();\n \n  const sendMessage = async () =&gt; {\n    if (!input.trim()) return;\n \n    const userMessage = { role: &#039;user&#039;, content: input };\n    setMessages(prev =&gt; [...prev, userMessage]);\n    setInput(&#039;&#039;);\n    setLoading(true);\n \n    try {\n      const response = await bridge.sendToBackground(&#039;AI_CHAT_REQUEST&#039;, {\n        model,\n        messages: [...messages, userMessage]\n      });\n \n      setMessages(prev =&gt; [...prev, {\n        role: &#039;assistant&#039;,\n        content: response.response\n      }]);\n    } catch (error) {\n      console.error(&#039;AI Chat Error:&#039;, error);\n      // 錯誤處理...\n    } finally {\n      setLoading(false);\n    }\n  };\n \n  return (\n    &lt;div className={`ai-chat-widget ${theme}`}&gt;\n      &lt;div className=&quot;messages&quot;&gt;\n        {messages.map((msg, idx) =&gt; (\n          &lt;div key={idx} className={`message ${msg.role}`}&gt;\n            {msg.content}\n          &lt;/div&gt;\n        ))}\n        {loading &amp;&amp; &lt;div className=&quot;loading&quot;&gt;🤖 思考中...&lt;/div&gt;}\n      &lt;/div&gt;\n \n      &lt;div className=&quot;input-area&quot;&gt;\n        &lt;input\n          value={input}\n          onChange={(e) =&gt; setInput(e.target.value)}\n          onKeyDown={(e) =&gt; e.key === &#039;Enter&#039; &amp;&amp; sendMessage()}\n          placeholder=&quot;輸入訊息...&quot;\n        /&gt;\n        &lt;button onClick={sendMessage} disabled={loading}&gt;\n          發送\n        &lt;/button&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  );\n};\n階段三：配置管理系統 (1週)\n// config/ConfigManager.ts - 統一配置管理\ninterface ExtensionConfig {\n  ai: {\n    defaultModel: string\n    apiEndpoint: string\n    temperature: number\n  }\n  ui: {\n    theme: &quot;light&quot; | &quot;dark&quot;\n    language: string\n    animations: boolean\n  }\n  features: {\n    autoSummarize: boolean\n    smartReply: boolean\n    voiceInput: boolean\n  }\n}\n \nexport class ConfigManager {\n  private static config: ExtensionConfig\n \n  static async load(): Promise&lt;ExtensionConfig&gt; {\n    const stored = await chrome.storage.sync.get(&quot;config&quot;)\n \n    ConfigManager.config = {\n      ...ConfigManager.getDefaultConfig(),\n      ...stored.config,\n    }\n \n    return ConfigManager.config\n  }\n \n  static async save(updates: Partial&lt;ExtensionConfig&gt;): Promise&lt;void&gt; {\n    ConfigManager.config = { ...ConfigManager.config, ...updates }\n    await chrome.storage.sync.set({ config: ConfigManager.config })\n  }\n \n  static get(): ExtensionConfig {\n    return ConfigManager.config\n  }\n \n  private static getDefaultConfig(): ExtensionConfig {\n    return {\n      ai: {\n        defaultModel: &quot;llama3.1&quot;,\n        apiEndpoint: &quot;http://localhost:8000&quot;,\n        temperature: 0.7,\n      },\n      ui: {\n        theme: &quot;light&quot;,\n        language: &quot;zh-TW&quot;,\n        animations: true,\n      },\n      features: {\n        autoSummarize: true,\n        smartReply: false,\n        voiceInput: false,\n      },\n    }\n  }\n}\n\n🎯 效能優化實踐\n記憶體管理策略\n// 智能記憶體管理\nclass MemoryManager {\n  constructor() {\n    this.cache = new Map();\n    this.maxCacheSize = 100;\n    this.cleanupInterval = 5 * 60 * 1000; // 5分鐘\n \n    this.startCleanupTimer();\n    this.monitorMemoryUsage();\n  }\n \n  set(key, value, ttl = 300000) { // 預設 5分鐘 TTL\n    if (this.cache.size &gt;= this.maxCacheSize) {\n      this.evictOldest();\n    }\n \n    this.cache.set(key, {\n      value,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n \n  get(key) {\n    const item = this.cache.get(key);\n    if (!item) return null;\n \n    if (Date.now() - item.timestamp &gt; item.ttl) {\n      this.cache.delete(key);\n      return null;\n    }\n \n    return item.value;\n  }\n \n  evictOldest() {\n    const oldest = Array.from(this.cache.entries())\n      .sort(([,a], [,b]) =&gt; a.timestamp - b.timestamp)[0];\n \n    if (oldest) {\n      this.cache.delete(oldest[0]);\n    }\n  }\n \n  async monitorMemoryUsage() {\n    if (&#039;memory&#039; in performance) {\n      const usage = (performance as any).memory;\n      console.log(`記憶體使用: ${(usage.usedJSHeapSize / 1024 / 1024).toFixed(2)}MB`);\n \n      // 記憶體使用過高時清理快取\n      if (usage.usedJSHeapSize &gt; 50 * 1024 * 1024) { // 50MB\n        this.clearExpired();\n      }\n    }\n  }\n}\n非同步處理優化\n// 批次處理和防抖動\nclass BatchProcessor {\n  constructor(processor, batchSize = 10, delay = 1000) {\n    this.processor = processor\n    this.batchSize = batchSize\n    this.delay = delay\n    this.queue = []\n    this.timeoutId = null\n  }\n \n  add(item) {\n    this.queue.push(item)\n \n    if (this.queue.length &gt;= this.batchSize) {\n      this.flush()\n    } else {\n      this.scheduleFlush()\n    }\n  }\n \n  scheduleFlush() {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId)\n    }\n \n    this.timeoutId = setTimeout(() =&gt; {\n      this.flush()\n    }, this.delay)\n  }\n \n  async flush() {\n    if (this.queue.length === 0) return\n \n    const batch = this.queue.splice(0, this.batchSize)\n \n    try {\n      await this.processor(batch)\n    } catch (error) {\n      console.error(&quot;批次處理失敗:&quot;, error)\n      // 重試邏輯...\n    }\n \n    // 繼續處理剩餘項目\n    if (this.queue.length &gt; 0) {\n      this.scheduleFlush()\n    }\n  }\n}\n\n📈 監控與分析\n效能指標儀表板\n// analytics/PerformanceTracker.js\nclass PerformanceTracker {\n  constructor() {\n    this.metrics = {\n      extensionLoad: 0,\n      apiResponseTimes: [],\n      userInteractions: 0,\n      errorCounts: {},\n      memoryUsage: [],\n    }\n \n    this.startTracking()\n  }\n \n  trackApiCall(endpoint, duration) {\n    this.metrics.apiResponseTimes.push({\n      endpoint,\n      duration,\n      timestamp: Date.now(),\n    })\n \n    // 只保留最近 1000 次記錄\n    if (this.metrics.apiResponseTimes.length &gt; 1000) {\n      this.metrics.apiResponseTimes.shift()\n    }\n  }\n \n  trackError(error, context) {\n    const key = `${error.name}:${context}`\n    this.metrics.errorCounts[key] = (this.metrics.errorCounts[key] || 0) + 1\n \n    // 發送到分析服務\n    this.sendAnalytics(&quot;error&quot;, { error: error.message, context })\n  }\n \n  generateReport() {\n    const avgResponseTime =\n      this.metrics.apiResponseTimes.length &gt; 0\n        ? this.metrics.apiResponseTimes.reduce((sum, item) =&gt; sum + item.duration, 0) /\n          this.metrics.apiResponseTimes.length\n        : 0\n \n    return {\n      performance: {\n        avgApiResponseTime: avgResponseTime,\n        totalInteractions: this.metrics.userInteractions,\n        errorRate: Object.values(this.metrics.errorCounts).reduce((sum, count) =&gt; sum + count, 0),\n      },\n      recommendations: this.generateRecommendations(),\n    }\n  }\n \n  generateRecommendations() {\n    const recommendations = []\n    const report = this.generateReport()\n \n    if (report.performance.avgApiResponseTime &gt; 2000) {\n      recommendations.push({\n        type: &quot;performance&quot;,\n        message: &quot;API 回應時間過長，建議優化後端處理或增加快取&quot;,\n      })\n    }\n \n    if (report.performance.errorRate &gt; 10) {\n      recommendations.push({\n        type: &quot;reliability&quot;,\n        message: &quot;錯誤率過高，需要檢查錯誤處理機制&quot;,\n      })\n    }\n \n    return recommendations\n  }\n}\n\n🚀 未來發展規劃\n短期目標 (1-2個月)\n\n 統一身份認證系統 - 跨擴展的用戶狀態同步\n 可視化設定介面 - 使用者友善的配置管理\n 擴展商店上架 - 完成 Chrome Web Store 審核\n\n中期目標 (3-6個月)\n\n 多瀏覽器支援 - Firefox、Edge、Safari 適配\n 雲端同步功能 - 跨設備設定同步\n 插件市場 - 第三方開發者生態\n\n長期願景 (6-12個月)\n\n AI 模型本地化 - WebAssembly AI 推理\n 隱私增強技術 - 零知識證明和端到端加密\n 開源生態系統 - 建立開發者社群\n\n\n💭 設計哲學反思\n第一性原理應用\n\n問題本質：瀏覽器與 AI 的障礙是跨域限制，不是技術複雜性\n解決方案：微服務代理 + 統一通信層，而非重新發明輪子\n價值創造：提升使用者瀏覽體驗，而非炫技\n\nKISS 原則體現\n\n選擇現有工具：FastAPI + Ollama，而非自建 AI 服務\n最小化複雜性：統一的訊息機制，而非多種通信方式\n漸進式增強：基礎功能先行，高級功能後續添加\n\n高內聚低耦合實踐\n擴展層（UI） ⟷ 通信層（Bridge） ⟷ 服務層（Microservice）\n     ↓              ↓                    ↓\n  組件獨立        協議統一              API 標準\n\n\n📚 相關資源與學習\n技術文檔\n\nChrome Extension Manifest V3\nFastAPI 官方文檔\nOllama API 參考\n\n最佳實踐\n\nService Worker 最佳化\nCORS 處理策略\nReact 擴展開發模式\n\n知識連結\n\n與 AI 開發工具套件 共享 API 設計\n可整合到 遊戲系統 作為管理工具\n為 每日開發 提供實時輔助\n\n\n🎯 專案狀態：活躍開發中 | 📊 程式碼覆蓋率：75% | 🚀 下次發布：2025-07-15\nChromeExtension AI Architecture Microservices WebDevelopment"},"projects/development-tools/calu-app-gradio-toolkit":{"slug":"projects/development-tools/calu-app-gradio-toolkit","filePath":"projects/development-tools/calu-app-gradio-toolkit.md","title":"Calu-app - Gradio多功能工具箱實驗專案","links":[],"tags":["gradio","ai-integration","docker","ollama","web-tools","experimental"],"content":"Calu-app - Gradio多功能工具箱實驗專案\n\n從實用工具需求出發，探索Gradio + AI + Docker技術整合的可行性與最佳實踐\n\n專案概述\n\n路徑：/Volumes/Code/Calu-app\n技術棧：Python, Gradio, Ollama, Docker\n狀態：實驗階段完成，技術驗證成功\n複雜度：複雜（多技術棧整合）\n領域：開發工具\n\n\n\n專案資料夾結構\nCalu-app/\n├── main.py                    # Gradio 應用主進入點\n├── app.py                     # (舊版) Flask + Gradio 實驗檔案\n├── app2.py                    # 版本迭代檔案\n├── app3.py                    # 版本迭代檔案\n├── requirements.txt           # Python 依賴套件列表\n├── Dockerfile                 # Docker 容器建置設定\n├── docker-compose.yml         # Docker 部署設定\n├── README.md                  # 專案說明文件\n├── README-docker.md           # Docker 部署說明\n├── PEKORA-LICENSE            # 兔田佩可拉效忠聲明\n├── .vscode/                   # VS Code 開發環境設定\n├── .gradio/                   # Gradio 運行時檔案\n├── utils/                     # 核心功能模組\n│   ├── __init__.py           # 模組初始化\n│   ├── date_utils.py         # 日期計算邏輯\n│   ├── format_utils.py       # 格式化工具\n│   ├── ai_utils.py           # AI 整合邏輯\n│   └── future_bento_price.py # 便當價格推估\n├── static/                    # 靜態資源\n│   ├── css/                  # 樣式檔案\n│   └── js/                   # JavaScript 檔案\n├── templates/                 # HTML 模板\n│   ├── layout.html           # 基礎布局\n│   ├── gradio.html           # Gradio 整合頁面\n│   └── flatpickr.html        # 日期選擇器頁面\n└── image/                     # 文檔圖片資源\n    └── README/               # README 說明圖片\n\n背景與問題\n實驗性質定義\nCalu-app是一個技術驗證型專案，主要目標不在於創造完美的產品，而在於探索和驗證現代Web工具開發的技術可行性：\n核心驗證目標：\n\nGradio框架在實用工具開發中的適用性\n本地AI模型(Ollama)與Web應用的整合模式\nDocker容器化對於Python Web應用的部署價值\n多功能整合式工具的用戶體驗設計\n\n技術選型邏輯：\n實用性優先 → Gradio (零前端開發)\nAI能力整合 → Ollama (本地化，隱私安全)\n部署簡化 → Docker (環境一致性)\n開發效率 → Python生態系統\n\n第一性原理分析\n工具本質：解決日常計算與資訊處理的重複性工作\n技術本質：將複雜的技術能力包裝為簡單的用戶界面\n整合本質：在統一平台上提供多樣化功能，減少工具切換成本\n技術架構深度解析\n整體架構設計\n┌─────────────────────────────────────────────────────┐\n│                 Web Browser                         │\n├─────────────────────────────────────────────────────┤\n│                Gradio Frontend                      │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │\n│  │ 日期計算     │ │ 年份轉換     │ │ AI聊天      │   │\n│  │ 界面         │ │ 界面         │ │ 界面         │   │\n│  └─────────────┘ └─────────────┘ └─────────────┘   │\n├─────────────────────────────────────────────────────┤\n│                Gradio Server                        │\n│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │\n│  │ date_utils  │ │format_utils │ │ ai_utils    │   │\n│  │ 日期邏輯     │ │ 格式化邏輯   │ │ AI整合邏輯  │   │\n│  └─────────────┘ └─────────────┘ └─────────────┘   │\n├─────────────────────────────────────────────────────┤\n│              External Services                      │\n│  ┌─────────────────────────────────────────────────┐│\n│  │        Ollama API (localhost:11434)            ││\n│  │  ┌─────────────┐ ┌─────────────┐ ┌──────────┐  ││\n│  │  │   llama3.2  │ │  mistral    │ │  custom  │  ││\n│  │  │   3b model  │ │   7b model  │ │  models  │  ││\n│  │  └─────────────┘ └─────────────┘ └──────────┘  ││\n│  └─────────────────────────────────────────────────┘│\n└─────────────────────────────────────────────────────┘\n\n關鍵技術決策分析\n1. Gradio選型的深層考量\n優勢驗證：\n\n零前端負擔：Python開發者無需學習React/Vue等框架\n快速原型能力：從概念到可用界面在小時級別完成\n自動響應式設計：無需手動處理移動端適配\n內建組件豐富：文本框、按鈕、表格等常用組件開箱即用\n\n限制發現：\n\n客製化受限：界面風格受限於Gradio預設樣式\n複雜交互困難：難以實現複雜的用戶交互邏輯\n效能考量：大量數據展示時效能不如原生前端框架\n\n適用場景結論：\n適合內部工具、原型驗證、功能演示，但不適合商業級產品開發\n2. Ollama整合的創新嘗試\n技術整合模式：\n# 創新的年份轉換AI輔助\ndef ai_assisted_date_conversion(input_text, model=&quot;llama3.2:3b&quot;):\n    # 1. 傳統正規化處理\n    traditional_result = regex_based_conversion(input_text)\n \n    # 2. AI推理備援\n    if not traditional_result:\n        ai_prompt = f&quot;將以下日期轉換為民國年和西元年: {input_text}&quot;\n        ai_result = ollama_client.chat(model, ai_prompt)\n        return parse_ai_response(ai_result)\n \n    return traditional_result\n創新價值評估：\n\n探索性價值：驗證小型LLM在邊緣計算場景的實用性\n隱私保護：本地推理，無資料外洩風險\n成本控制：無API調用費用，可持續運行\n\n效果與限制：\n\nllama3.2 3b模型在簡單轉換任務上表現不穩定\n但展現了未來AI輔助計算的潛在價值\n為更強大的本地模型預留了架構空間\n\n模組化設計實踐\n高內聚低耦合架構\n# utils/date_utils.py - 專注日期處理\ndef calculate_time_difference(start, end):\n    &quot;&quot;&quot;計算時間差，單一職責原則&quot;&quot;&quot;\n \ndef convert_date(date_input):\n    &quot;&quot;&quot;年份轉換，包含AI輔助邏輯&quot;&quot;&quot;\n \n# utils/format_utils.py - 專注格式化\ndef clean_input(text):\n    &quot;&quot;&quot;文本清理，獨立功能模組&quot;&quot;&quot;\n \ndef validate_date_format(date_str):\n    &quot;&quot;&quot;日期格式驗證，可重用函數&quot;&quot;&quot;\n \n# utils/ai_utils.py - 專注AI整合\ndef get_ollama_models():\n    &quot;&quot;&quot;模型列表獲取&quot;&quot;&quot;\n \ndef chat_with_model(model, message, system_prompt):\n    &quot;&quot;&quot;AI對話核心邏輯&quot;&quot;&quot;\nKISS原則的實踐體現\n\n簡單界面：使用Gradio避免複雜的前端開發\n直接整合：直接調用Ollama API，不增加中間層\n最小依賴：requirements.txt僅包含必要套件\n單一入口：main.py作為唯一啟動點\n\n功能模組深度分析\n1. 日期計算機 - 基礎工具模組\n技術實現細節\ndef calculate_time_difference(start_time, end_time):\n    try:\n        # 多格式支援的日期解析\n        formats = [\n            &quot;%Y/%m/%d %H:%M&quot;,\n            &quot;%Y-%m-%d %H:%M&quot;,\n            &quot;%Y/%m/%d&quot;,\n            &quot;%Y-%m-%d&quot;\n        ]\n \n        start_dt = parse_flexible_date(start_time, formats)\n        end_dt = parse_flexible_date(end_time, formats)\n \n        # 精確到分鐘的計算\n        diff = end_dt - start_dt\n \n        return format_time_difference(diff)\n \n    except ValueError as e:\n        return f&quot;日期格式錯誤: {str(e)}&quot;\n用戶體驗設計\n\n靈活輸入：支援多種日期格式，降低用戶學習成本\n即時計算：點擊按鈕即可獲得結果，無需等待\n錯誤友善：清晰的錯誤訊息，幫助用戶修正輸入\n\n實用價值評估\n⭐⭐⭐⭐ 高實用性，工作中經常需要計算時間間隔\n2. 年份轉換器 - AI輔助實驗模組\n創新技術嘗試\ndef convert_date_with_ai_fallback(date_input):\n    # 階段1：傳統正規化處理\n    traditional_result = regex_conversion(date_input)\n \n    if traditional_result[&quot;confidence&quot;] &gt; 0.8:\n        return traditional_result\n \n    # 階段2：AI推理輔助\n    ai_result = ai_assisted_conversion(date_input)\n \n    # 階段3：結果整合與驗證\n    return integrate_results(traditional_result, ai_result)\n技術實驗結論\n\n模型限制：llama3.2 3b在數值轉換上不夠可靠\n架構價值：為未來更強大的模型預留了整合空間\n方法論貢獻：建立了傳統算法與AI推理的混合模式\n\n創新程度評估\n⭐⭐⭐⭐ 在傳統工具中整合AI能力的有益嘗試\n3. 便當價格推估 - 數學建模模組\n演算法實現\ndef future_bento_price(base_year, base_price, target_year, inflation_rate=0.02):\n    &quot;&quot;&quot;\n    基於複合成長率的價格預測模型\n    P(t) = P0 * (1 + r)^(t-t0)\n    &quot;&quot;&quot;\n    years_diff = target_year - base_year\n    future_price = base_price * (1 + inflation_rate) ** years_diff\n \n    return {\n        &quot;predicted_price&quot;: round(future_price, 2),\n        &quot;growth_factor&quot;: round((1 + inflation_rate) ** years_diff, 4),\n        &quot;total_increase&quot;: round(future_price - base_price, 2)\n    }\n教育與娛樂價值\n\n經濟學概念：展示通膨對日常商品價格的影響\n數學建模：簡單但有效的預測模型實作\n趣味互動：增加工具的娛樂性和探索性\n\n4. AI聊天 - 核心創新模組\nOllama整合架構\ndef setup_ai_chat():\n    &quot;&quot;&quot;建立AI聊天環境&quot;&quot;&quot;\n    try:\n        client = Client(host=&#039;http://localhost:11434&#039;)\n        models = client.list()\n        return client, [model[&#039;name&#039;] for model in models[&#039;models&#039;]]\n    except:\n        return None, [&quot;連接失敗&quot;]\n \ndef chat_with_ollama(model, message, system_prompt, history):\n    &quot;&quot;&quot;實現對話記憶的AI聊天&quot;&quot;&quot;\n    full_conversation = build_conversation_context(history, system_prompt)\n \n    response = client.chat(\n        model=model,\n        messages=full_conversation + [{&quot;role&quot;: &quot;user&quot;, &quot;content&quot;: message}]\n    )\n \n    return response[&#039;message&#039;][&#039;content&#039;]\n用戶體驗創新\n\n模型選擇彈性：用戶可根據需求選擇不同模型\n系統提示客製化：允許用戶定義AI的角色和行為風格\n對話記憶維護：保持對話上下文的連貫性\n\n技術價值貢獻\n\n本地AI整合模式：為本地AI應用建立了標準參考\n隱私保護實踐：所有對話資料不離開本地環境\n成本控制示範：無需API費用的AI功能實現\n\n容器化部署實踐\nDocker化的技術考量\nDockerfile設計哲學\nFROM python:3.11-slim\n \n# 最小化依賴安裝\nCOPY requirements.txt .\nRUN pip install --no-cache-dir -r requirements.txt\n \n# 非root用戶運行\nRUN useradd -m -u 1000 calu\nUSER calu\n \n# 健康檢查機制\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:7861/ || exit 1\n \nCMD [&quot;python&quot;, &quot;main.py&quot;]\n安全性考量\n\n最小權限原則：使用非root用戶運行應用\n最小化攻擊面：僅開放必要端口(7861)\n依賴漏洞管理：使用slim基礎鏡像減少潜在漏洞\n\n可移植性驗證\n\n跨平台測試：在Windows、macOS、Linux環境驗證\n環境隔離：確保容器內外環境完全隔離\n版本一致性：確保開發與生產環境的一致性\n\ndocker-compose最佳實踐\nversion: &quot;3.8&quot;\nservices:\n  calu-app:\n    build: .\n    container_name: doc-toolbox\n    ports:\n      - &quot;7861:7861&quot;\n    environment:\n      - APP_PORT=7861\n    restart: unless-stopped\n    healthcheck:\n      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:7861&quot;]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n技術方案\n核心技術選型\nGradio框架選型理由：\n\n零前端開發負擔，Python開發者可直接上手\n快速原型能力，從概念到界面小時級完成\n自動響應式設計，無需手動適配移動端\n內建豐富組件，滿足基礎工具開發需求\n\nOllama本地AI整合：\n\n隱私保護：所有AI對話不離開本地環境\n成本控制：無API調用費用，可持續運行\n離線可用：不依賴網路連接的AI功能\n模型選擇：支援多種開源LLM模型\n\nDocker容器化部署：\n\n環境一致性：開發與生產環境完全相同\n部署簡化：一鍵啟動完整應用棧\n隔離安全：容器內外環境完全隔離\n跨平台支援：Windows、macOS、Linux通用\n\n核心實作\n多功能工具整合架構\n# 主應用程式架構\nwith gr.Blocks() as demo:\n    with gr.Tabs():\n        # 1. 日期計算工具\n        with gr.Tab(&quot;日期計算&quot;):\n            date_calculator_interface()\n \n        # 2. 年份轉換工具（含AI輔助）\n        with gr.Tab(&quot;年份轉換&quot;):\n            year_converter_interface()\n \n        # 3. 文字格式化工具\n        with gr.Tab(&quot;格式化工具&quot;):\n            text_formatter_interface()\n \n        # 4. 價格預測工具\n        with gr.Tab(&quot;便當價格推估&quot;):\n            price_predictor_interface()\n \n        # 5. AI聊天功能\n        with gr.Tab(&quot;AI聊天&quot;):\n            ai_chat_interface()\nAI能力整合創新\n混合智能模式：\ndef hybrid_date_conversion(input_text):\n    # 傳統正規化處理\n    traditional_result = regex_based_conversion(input_text)\n \n    # AI推理輔助（當傳統方法失效）\n    if not traditional_result:\n        ai_result = ollama_assisted_conversion(input_text)\n        return validate_and_return(ai_result)\n \n    return traditional_result\n本地AI整合模式：\ndef setup_ollama_integration():\n    client = Client(host=&#039;http://localhost:11434&#039;)\n    available_models = client.list()[&#039;models&#039;]\n \n    return {\n        &#039;client&#039;: client,\n        &#039;models&#039;: [model[&#039;name&#039;] for model in available_models],\n        &#039;default_model&#039;: &#039;llama3.2:3b&#039;\n    }\n效果與學習\n技術驗證成果\n成功驗證的技術假設：\n\n✅ Gradio適合快速工具原型開發\n✅ 本地AI模型可實用化整合\n✅ Docker部署大幅簡化環境管理\n✅ 多功能整合提升工具使用效率\n\n發現的技術限制：\n\n⚠️ Gradio界面客製化能力有限\n⚠️ llama3.2 3b在數值計算上不穩定\n⚠️ 單體架構限制功能獨立擴展\n\n創新價值與影響\n技術貢獻：\n\n建立了Gradio + Ollama標準整合模式\n驗證了混合智能計算的實用性\n提供了快速工具開發的參考框架\n\n方法論貢獻：\n\n實驗驅動的技術驗證流程\n漸進式功能擴展策略\n知識沈澱與經驗傳承模式\n\n時間軸\n2025-01-09 10:00 基礎建立階段\n\n建立基本日期計算機功能\n驗證Gradio框架基礎可行性\n確立Python + Gradio技術路線\n實現第一個實用工具模組\n\n2025-01-09 14:00 架構重構階段\n\n程式碼結構化，拆分utils目錄\n實踐高內聚低耦合設計原則\n建立可維護的模組化架構\n為後續功能擴展打下基礎\n\n2025-01-09 18:00 容器化探索階段\n\n首次Docker化，建立部署標準\n驗證容器化部署的便利性\n建立跨平台部署解決方案\n確保開發與生產環境一致性\n\n2025-01-10 09:00 AI能力整合階段\n\n首次引入Ollama本地AI功能\n實現AI聊天界面與後端整合\n驗證小型LLM在實際應用中的效果\n建立本地AI應用的參考架構\n\n2025-01-26 11:00 功能完善階段\n\n增強AI聊天功能，支援多模型選擇\n優化用戶體驗，增加配置彈性\n提升AI交互品質和穩定性\n滿足多樣化AI應用需求\n\n2025-07-05 16:00 文檔完善階段\n\n大幅擴充README，增加功能預覽\n提升專案文檔化成熟度\n準備知識傳承和技術分享\n建立專案展示標準\n\n2025-07-05 20:00 系統分析階段\n\n完成專案系統化分析\n提取可重用技術組件\n建立技術實驗標準流程\n沈澱經驗為後續專案參考\n\n\n⏰ 總投入時間：約40小時分散開發 | 🎯 成果：多功能工具平台完成 | 📚 學習：Gradio+AI整合完整實踐\n開發模式與方法論\n漸進式創新模式\n發展路徑：\n基礎功能 → 架構優化 → 部署改進 → AI整合 → 用戶體驗 → 展示完善\n\n核心特點：\n\n每階段明確技術目標\n風險控制：逐步驗證，降低失敗風險\n學習驅動：從實踐中獲得技術洞察\n知識沈澱：經驗轉化為可傳承資產\n\n技術決策演進邏輯\n\n需求驅動：從實際使用場景出發\n技術驗證：小步快跑，快速驗證可行性\n架構優化：基於驗證結果優化技術選型\n能力擴展：在穩定基礎上增加新能力\n體驗提升：持續改進用戶體驗\n知識沈澱：將經驗轉化為可傳承的知識\n\n技術創新點與局限性\n創新貢獻\n1. 本地AI整合模式創新\n貢獻：建立了Gradio + Ollama的標準整合模式\n# 創新的AI功能整合模式\ndef integrate_ai_capability(gradio_interface, ollama_client):\n    &quot;&quot;&quot;\n    將本地AI能力無縫整合到Web工具中\n    實現隱私保護、成本控制、離線可用的AI功能\n    &quot;&quot;&quot;\n影響：為後續本地AI應用開發提供了參考框架\n2. 混合智能計算模式\n貢獻：建立了傳統算法與AI推理的混合模式\n# 混合智能的實現模式\ndef hybrid_intelligent_processing(input_data):\n    traditional_result = rule_based_processing(input_data)\n    if confidence_low(traditional_result):\n        ai_result = ai_assisted_processing(input_data)\n        return integrate_results(traditional_result, ai_result)\n    return traditional_result\n價值：在可靠性和智能性之間找到平衡\n3. 快速工具原型開發模式\n貢獻：驗證了Gradio在快速工具開發中的價值\n\n開發效率：從概念到可用工具在小時級別\n技術門檻：Python開發者無需學習前端技術\n部署便利：一鍵Docker部署\n\n技術局限性\n1. Gradio框架限制\n界面客製化有限：\n\n無法實現複雜的交互邏輯\n視覺設計受限於預設主題\n大量數據展示效能不佳\n\n適用場景限制：\n\n適合內部工具，不適合商業產品\n適合功能演示，不適合複雜應用\n\n2. AI模型能力限制\nllama3.2 3b模型限制：\n\n數值計算準確性不足\n複雜推理能力有限\n回應品質不穩定\n\n本地部署限制：\n\n模型選擇受限於硬體能力\n推理速度受限於本地算力\n模型更新需要手動管理\n\n3. 架構擴展性限制\n單體應用架構：\n\n功能模組雖然分離，但仍為單體部署\n難以實現獨立的功能擴展\n缺乏微服務架構的彈性\n\n狀態管理限制：\n\nGradio的狀態管理能力有限\n難以實現複雜的用戶會話管理\n缺乏持久化儲存機制\n\n可重用元件提取\n1. Gradio-Ollama整合模組\n標準化整合模式\nclass GradioOllamaIntegrator:\n    &quot;&quot;&quot;可重用的Gradio-Ollama整合組件&quot;&quot;&quot;\n \n    def __init__(self, ollama_host=&quot;http://localhost:11434&quot;):\n        self.client = Client(host=ollama_host)\n        self.models = self.load_available_models()\n \n    def create_chat_interface(self):\n        &quot;&quot;&quot;創建標準化的AI聊天界面&quot;&quot;&quot;\n        with gr.Tab(&quot;AI聊天&quot;):\n            model_dropdown = gr.Dropdown(\n                choices=self.models,\n                label=&quot;選擇模型&quot;\n            )\n            system_prompt = gr.Textbox(\n                label=&quot;系統提示&quot;,\n                placeholder=&quot;定義AI的角色和行為...&quot;\n            )\n            # ... 其他界面元素\n \n    def chat_handler(self, model, message, system_prompt, history):\n        &quot;&quot;&quot;標準化的聊天處理邏輯&quot;&quot;&quot;\n        # 可重用的對話處理邏輯\n重用價值\n\n快速AI整合：30分鐘內為任何Gradio應用增加AI功能\n標準化介面：統一的AI交互模式\n配置靈活性：支援不同模型和提示配置\n\n2. Docker化部署模板\n標準化容器配置\n# 可重用的Python Web應用Docker模板\nFROM python:3.11-slim\n \n# 標準化的安全配置\nRUN useradd -m -u 1000 appuser\nUSER appuser\n \n# 標準化的健康檢查\nHEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \\\n  CMD curl -f http://localhost:${APP_PORT}/ || exit 1\n \n# 標準化的啟動方式\nCMD [&quot;python&quot;, &quot;main.py&quot;]\ndocker-compose模板\n# 可重用的部署配置模板\nversion: &quot;3.8&quot;\nservices:\n  web-tool:\n    build: .\n    ports:\n      - &quot;${HOST_PORT}:${CONTAINER_PORT}&quot;\n    environment:\n      - APP_PORT=${CONTAINER_PORT}\n    restart: unless-stopped\n    healthcheck:\n      test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost:${CONTAINER_PORT}&quot;]\n3. 工具功能模組模板\n通用工具模組結構\n# utils/tool_template.py\nclass ToolModule:\n    &quot;&quot;&quot;可重用的工具模組基礎類別&quot;&quot;&quot;\n \n    def __init__(self):\n        self.name = &quot;工具名稱&quot;\n        self.description = &quot;工具描述&quot;\n \n    def validate_input(self, input_data):\n        &quot;&quot;&quot;輸入驗證邏輯&quot;&quot;&quot;\n        pass\n \n    def process(self, input_data):\n        &quot;&quot;&quot;核心處理邏輯&quot;&quot;&quot;\n        pass\n \n    def format_output(self, result):\n        &quot;&quot;&quot;輸出格式化&quot;&quot;&quot;\n        pass\n \n    def create_gradio_interface(self):\n        &quot;&quot;&quot;創建Gradio界面&quot;&quot;&quot;\n        pass\n專案影響與啟發\n對後續專案的影響\n1. 技術棧選型指導\nGradio適用場景：\n\n✅ 內部工具快速開發\n✅ 原型驗證和概念展示\n✅ AI能力包裝和展示\n❌ 商業級產品開發\n❌ 複雜交互需求場景\n\nAI整合策略：\n\n本地化部署優先考慮隱私和成本\n混合智能模式平衡可靠性和智能性\n模型選擇需要考慮實際任務複雜度\n\n2. 開發流程優化\n快速原型模式：\n概念 → 最小可用版本 → 架構優化 → 功能擴展 → 體驗提升\n\n風險控制策略：\n\n分階段技術驗證\n每個階段設定明確的成功標準\n及時止損，避免沈沒成本\n\n3. 知識管理實踐\n技術實驗文檔化：\n\n記錄技術選型的決策邏輯\n保留失敗嘗試的經驗教訓\n提取可重用的技術模組\n\n對個人技能發展的影響\n1. 全棧思維建立\n通過這個專案，從Python後端開發者擴展到：\n\n前端意識：理解用戶界面設計的重要性\n部署運維：掌握容器化部署的實踐\n產品思維：從技術實現轉向用戶價值思考\n\n2. AI整合能力\n建立了AI應用開發的基礎能力：\n\n模型選型能力：理解不同模型的能力邊界\n整合架構設計：掌握AI能力整合的技術模式\n效果評估方法：建立AI功能效果的評估標準\n\n3. 系統分析能力\n通過項目復盤，提升了系統分析能力：\n\n技術決策分析：理解技術選型的邏輯和後果\n架構演進理解：掌握專案架構演進的模式\n價值評估能力：平衡技術可行性和商業價值\n\n對技術社群的貢獻\n1. 最佳實踐分享\nGradio + Ollama整合模式：\n\n提供了可複製的技術整合方案\n建立了本地AI應用的參考架構\n分享了混合智能計算的實踐經驗\n\n2. 開源技術驗證\n小型LLM實用性驗證：\n\n提供了llama3.2 3b在實際應用中的效果數據\n驗證了本地AI模型的可行性和限制\n為後續模型選型提供參考\n\n3. 技術教育資源\n實踐驅動的學習資源：\n\n提供了完整的技術實驗過程記錄\n建立了從概念到實現的完整案例\n創建了可重用的技術模組和模板\n\n後續發展方向\n短期改進計劃\n1. 技術債務清理\n效能優化：\n\n優化Gradio界面的響應速度\n改進AI模型的推理效率\n增加錯誤處理和用戶提示\n\n代碼品質提升：\n\n增加單元測試覆蓋\n完善代碼文檔\n統一代碼風格\n\n2. 功能擴展\n新工具模組：\n\n增加更多日常實用工具\n擴展AI能力應用場景\n增加數據處理工具\n\n用戶體驗改進：\n\n增加用戶偏好保存\n改進界面響應性\n增加功能使用指導\n\n中期技術升級\n1. 架構重構\n微服務化改造：\n\n將工具模組拆分為獨立服務\n實現功能的獨立部署和擴展\n增加服務間的標準化溝通協議\n\nAPI化改造：\n\n提供RESTful API接口\n支援第三方應用整合\n建立標準化的服務介面\n\n2. AI能力升級\n模型能力提升：\n\n測試更強大的本地模型\n整合專業領域模型\n實現模型的動態切換\n\n智能化增強：\n\n增加自然語言查詢能力\n實現智能化的工具推薦\n建立用戶行為學習機制\n\n長期願景規劃\n1. 平台化發展\n工具生態系統：\n\n建立第三方工具開發框架\n創建工具市場和分享機制\n實現工具的組合和工作流程化\n\n開源社群建設：\n\n建立開發者社群\n創建貢獻指南和標準\n實現社群驅動的發展模式\n\n2. 商業化探索\n企業級功能：\n\n增加企業級安全和權限管理\n提供企業級部署和支援服務\n建立技術諮詢和客製化服務\n\n服務模式創新：\n\n探索SaaS服務模式\n建立訂閱和授權體系\n發展技術培訓和認證服務\n\n總結與價值評估\n專案核心價值總結\n1. 技術驗證價值\n成功驗證：\n\nGradio在快速工具開發中的實用性 ✅\n本地AI模型的整合可行性 ✅\nDocker容器化部署的便利性 ✅\n混合智能計算模式的有效性 ✅\n\n發現限制：\n\nGradio在商業應用中的局限性 ⚠️\n小型LLM在複雜任務中的不穩定性 ⚠️\n單體架構在功能擴展中的限制 ⚠️\n\n2. 學習與成長價值\n技術能力提升：\n\n掌握了Gradio快速原型開發技術\n建立了本地AI整合的技術能力\n提升了容器化部署的實戰經驗\n發展了全棧思維和產品意識\n\n方法論建立：\n\n建立了技術實驗的標準流程\n發展了風險控制的實踐方法\n創建了知識管理的有效模式\n\n3. 可重用資產價值\n技術模組：\n\nGradio-Ollama整合組件\nDocker部署配置模板\n工具開發標準架構\n\n知識資產：\n\n技術選型決策框架\n開發流程最佳實踐\n風險評估和控制方法\n\n對selfpagesource體系的貢獻\n1. 專案模板貢獻\n本專案為selfpagesource提供了實驗型技術專案的標準化分析模板：\n\n技術驗證型專案的分析框架\n開發歷程的系統化梳理方法\n技術債務和限制的識別模式\n\n2. 可重用元件貢獻\n提取的技術組件可直接應用於後續專案：\n\nAI整合標準模式\n容器化部署模板\n快速原型開發流程\n\n3. 知識體系貢獻\n為技術知識庫增加了重要的實踐案例：\n\n現代Web工具開發的技術路線選擇\n本地AI應用的實踐經驗和限制\n技術實驗到產品化的轉換思路\n\n專案成熟度評估\n技術成熟度：⭐⭐⭐⭐ (實驗驗證成功)\n\n核心功能穩定可用\n技術架構經過驗證\n部署流程標準化\n文檔和知識完備\n\n商業價值：⭐⭐⭐ (概念驗證階段)\n\n具有實用工具價值\n技術模式可複製\n需要進一步商業化探索\n\n可維護性：⭐⭐⭐⭐ (良好的代碼組織)\n\n模組化設計清晰\n文檔覆蓋完整\n技術債務控制良好\n\n擴展性：⭐⭐⭐ (架構支援有限擴展)\n\n功能模組可獨立開發\n部署配置可複製\n需要架構升級支援大規模擴展\n\n\n維護時間軸\n2025-07-05 最新維護記錄\n\n專案檢查：確認專案當前狀態，所有功能正常運作\n授權補充：已添加 PEKORA-LICENSE 到專案根目錄\n文檔更新：更新專案文檔，確保資訊同步\n技術確認：驗證 Gradio 5.11.0 + Ollama 整合架構穩定性\n\n\n專案評級：⭐⭐⭐⭐ 成功的技術驗證專案，為後續開發提供了寶貴的實踐經驗和可重用資產\n推薦等級：高度推薦作為技術實驗和快速原型開發的參考案例\n維護建議：持續跟進技術發展，適時進行架構升級和功能擴展\n專案負責人：PekoraTech SA Team\n技術審查狀態：✅ 已完成系統分析\n文檔狀態：✅ 已完成專案文檔化\n授權狀態：✅ 已添加 PEKORA-LICENSE\n下一階段：提取可重用組件，建立技術標準\n專案映射\n\n開發資料夾：/Volumes/Code/Calu-app\nGitHub倉庫：未設定（本地實驗專案）\n相關專案：與其他 AI 工具整合專案相關\n"},"projects/development-tools/md-presentation-toolkit":{"slug":"projects/development-tools/md-presentation-toolkit","filePath":"projects/development-tools/md-presentation-toolkit.md","title":"MD Presentation Toolkit - 統一簡報生成平台","links":[],"tags":["monorepo","presentation","slidev","mdx-deck","mcp-protocol","development-tools"],"content":"📦 MD Presentation Toolkit - 統一簡報生成平台\n\n架構革新：從單一工具進化為 Monorepo 統一平台\n支援 Slidev 和 MDX-Deck 雙引擎，實現真正的技術靈活性\n\n專案概述\n\n路徑：/Volumes/Code/test-ppt-page/md-presentation-toolkit/\n技術棧：Node.js + OpenAI + MCP + Slidev + MDX-Deck + Express + Vue.js + Monorepo\n狀態：✅ Monorepo 轉換完成\n複雜度：🔥 高度複雜（多引擎整合 + Monorepo 架構）\n領域：開發工具與效率提升\n\n專案資料夾結構\nmd-presentation-toolkit/        # Monorepo 根目錄\n├── 📦 packages/                # 應用程式包\n│   ├── slidev-app/             # Slidev 簡報應用\n│   │   ├── slides.md           # 簡報內容\n│   │   ├── package.json        # Slidev 專用依賴\n│   │   └── components/         # Slidev 組件\n│   ├── mdx-app/                # MDX-Deck 簡報應用\n│   │   ├── decks/              # MDX 簡報內容\n│   │   ├── package.json        # MDX-Deck 專用依賴\n│   │   └── themes/             # MDX 主題\n│   └── shared/                 # 共用後端服務\n│       ├── server/             # Express API 服務\n│       ├── public/             # 前端管理介面\n│       └── utils/              # 共用工具函數\n├── 🎨 shared-assets/           # 共同資源\n│   ├── data/                   # 資料檔案\n│   ├── images/                 # 圖片資源\n│   ├── presentations/          # 簡報儲存\n│   └── configs/                # 配置檔案\n├── ⚙️ scripts/                # 共用腳本\n│   ├── kill-ports.js          # 埠號清理\n│   ├── check-env.js           # 環境檢查\n│   └── test-*.js              # 測試腳本\n├── 📚 docs/                   # 文檔目錄\n│   └── Monorepo轉換計畫.md    # 轉換計畫文檔\n├── package.json               # 根層級依賴管理\n└── 🧠 MCP 整合/               # 保留原有 MCP 功能\n    ├── mcp-config.json        # MCP 伺服器配置\n    └── openai-integration.js  # OpenAI + MCP 整合\n\n背景與問題\n從單一工具到統一平台的演進\n原有 test-slidev 的局限：\n\n🔒 單一引擎綁定：只支援 Slidev\n🔧 重複開發：MDX-Deck 需要獨立實現\n📂 資源分散：共用功能無法重複利用\n🚧 維護困難：多專案版本不同步\n\nMonorepo 統一平台的優勢\n🏗️ 架構統一化：\n\n📦 統一依賴管理：消除重複依賴，減少衝突\n🔄 代碼重用：共用後端服務和工具函數\n⚡ 簡化開發流程：統一指令介面和開發環境\n🎯 獨立部署：各應用可獨立建構和部署\n\n🎭 雙引擎支援：\n\n🎨 Slidev：Vue.js 生態，豐富互動功能\n📄 MDX-Deck：React 生態，JSX 語法支援\n🔀 無縫切換：相同資料來源，不同呈現方式\n🎯 用戶選擇：根據需求選擇最適合的引擎\n\n技術方案\n🌟 Monorepo 架構設計\n1. 工作區管理策略\n// 根目錄 package.json\n{\n  &quot;name&quot;: &quot;md-presentation-toolkit&quot;,\n  &quot;workspaces&quot;: [&quot;packages/*&quot;],\n  &quot;scripts&quot;: {\n    &quot;dev:slidev&quot;: &quot;npm run dev --workspace=slidev-app&quot;,\n    &quot;dev:mdx&quot;: &quot;npm run dev --workspace=mdx-app&quot;,\n    &quot;dev:server&quot;: &quot;npm run server --workspace=shared&quot;,\n    &quot;start:all&quot;: &quot;concurrently \\&quot;npm run dev:server\\&quot; \\&quot;npm run frontend\\&quot;&quot;,\n    &quot;build:all&quot;: &quot;npm run build --workspaces&quot;,\n    &quot;test:all&quot;: &quot;npm run test --workspaces&quot;\n  }\n}\n管理優勢：\n\n✅ 統一版本管理，避免依賴衝突\n✅ 共用 node_modules，節省磁碟空間\n✅ 跨 package 腳本執行\n✅ 並行建構和測試\n\n2. 雙引擎整合架構\nflowchart TD\n    User[👤 用戶需求] --&gt; Manager[🎯 引擎選擇器]\n\n    Manager --&gt; |選擇 Slidev| SlidevApp[🎨 Slidev 應用&lt;br/&gt;Vue.js 生態]\n    Manager --&gt; |選擇 MDX| MDXApp[📄 MDX-Deck 應用&lt;br/&gt;React 生態]\n\n    subgraph shared [🔧 共用服務層]\n        API[⚙️ Express API]\n        Frontend[🎨 管理介面]\n        MCP[🧠 MCP 整合]\n    end\n\n    subgraph assets [📂 共用資源]\n        Data[📊 數據檔案]\n        Images[🖼️ 圖片資源]\n        Configs[⚙️ 配置檔案]\n    end\n\n    SlidevApp --&gt; shared\n    MDXApp --&gt; shared\n    shared --&gt; assets\n\n    SlidevApp --&gt; Output1[🎪 Slidev 簡報&lt;br/&gt;:3030]\n    MDXApp --&gt; Output2[📱 MDX 簡報&lt;br/&gt;:8080]\n\n架構特色：\n\n🔧 引擎抽象：統一介面，不同實現\n📊 資源共享：相同數據，多種呈現\n🎯 獨立運行：各引擎互不干擾\n🔄 無縫切換：保持相同的 MCP 和 AI 功能\n\n3. 共用服務設計\n// packages/shared/utils/engine-adapter.js\nclass EngineAdapter {\n  static async generateForSlidey(data) {\n    return {\n      format: &quot;markdown&quot;,\n      content: this.transformToSlidevFormat(data),\n      theme: &quot;default&quot;,\n    }\n  }\n \n  static async generateForMDX(data) {\n    return {\n      format: &quot;jsx&quot;,\n      content: this.transformToMDXFormat(data),\n      theme: &quot;spectrum&quot;,\n    }\n  }\n}\n共用功能：\n\n🧠 MCP 整合服務：保持原有 AI 功能\n📊 數據處理引擎：統一數據格式轉換\n🎨 前端管理界面：兩個引擎共用\n⚙️ 配置管理系統：統一設定檔管理\n\n🚀 開發流程優化\n統一指令系統\n# 🎯 根層級統一指令\nnpm run dev:slidev      # 啟動 Slidev 開發模式\nnpm run dev:mdx         # 啟動 MDX-Deck 開發模式\nnpm run dev:server      # 啟動共用後端服務\nnpm run frontend        # 啟動前端管理介面\nnpm run start:all       # 同時啟動後端和前端\n \n# 🔧 建構與測試\nnpm run build:all       # 建構所有應用\nnpm run test:all        # 執行所有測試\nnpm run clean           # 清理所有建構檔案\n \n# 🚀 部署相關\nnpm run export:slidev   # 匯出 Slidev PDF\nnpm run export:mdx      # 匯出 MDX PDF\n開發優勢：\n\n⚡ 快速啟動：一個指令啟動整個開發環境\n🔄 並行開發：同時開發兩個引擎應用\n🧪 統一測試：跨 package 測試執行\n📦 一鍵部署：統一建構和部署流程\n\n服務端點配置\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n服務名稱端口用途技術棧🎨 管理介面:3000用戶操作界面Vue.js⚙️ API 服務:3001後端 APIExpress + OpenAI🎪 Slidev 簡報:3030Slidev 預覽Slidev Engine📱 MDX 簡報:8080MDX-Deck 預覽MDX-Deck Engine\n核心實作\n🎯 引擎選擇與切換系統\n智能引擎推薦：\n// 引擎選擇邏輯\nfunction recommendEngine(requirements) {\n  const { 需要互動, 團隊技術棧, 視覺需求 } = requirements\n \n  if (需要互動 &amp;&amp; 團隊技術棧.includes(&quot;Vue&quot;)) {\n    return &quot;slidev&quot; // Vue 生態，豐富互動\n  } else if (視覺需求 === &quot;極簡&quot; &amp;&amp; 團隊技術棧.includes(&quot;React&quot;)) {\n    return &quot;mdx-deck&quot; // React 生態，極簡風格\n  }\n \n  return &quot;slidev&quot; // 預設推薦\n}\n功能對比：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特性🎨 Slidev📄 MDX-Deck🛠️ 技術棧Vue.js 生態React 生態🎭 互動性⭐⭐⭐⭐⭐⭐⭐⭐🎨 主題豐富度⭐⭐⭐⭐⭐⭐⭐⭐⭐📝 語法簡潔⭐⭐⭐⭐⭐⭐⭐⭐⭐🚀 效能⭐⭐⭐⭐⭐⭐⭐⭐⭐📱 響應式⭐⭐⭐⭐⭐⭐⭐⭐⭐\n📊 統一數據處理流程\n數據格式轉換器：\n// shared/utils/content-transformer.js\nclass ContentTransformer {\n  static async toSlideyFormat(rawData) {\n    return `---\ntheme: default\nlayout: intro\n---\n \n# ${rawData.title}\n \n${rawData.subtitle}\n \n---\nlayout: default\n---\n \n${rawData.content\n  .map(\n    (slide) =&gt; `\n# ${slide.title}\n \n${slide.content}\n \n`,\n  )\n  .join(&quot;---\\n&quot;)}\n`\n  }\n \n  static async toMDXFormat(rawData) {\n    return `import { Head, Appear } from &#039;mdx-deck&#039;\n \n&lt;Head&gt;\n  &lt;title&gt;${rawData.title}&lt;/title&gt;\n&lt;/Head&gt;\n \n# ${rawData.title}\n \n${rawData.subtitle}\n \n---\n \n${rawData.content\n  .map(\n    (slide) =&gt; `\n# ${slide.title}\n \n&lt;Appear&gt;\n \n${slide.content}\n \n&lt;/Appear&gt;\n \n---\n \n`,\n  )\n  .join(&quot;&quot;)}\n`\n  }\n}\n🔧 環境需求與設置\nNode.js 版本升級：\n# 使用 nvm 升級到 Node.js 22\nnvm install 22\nnvm use 22\nnode --version  # 確認版本 v22.x.x\n依賴安裝流程：\ncd md-presentation-toolkit\nnpm install  # 自動安裝所有 workspace 依賴\n效果與學習\n🏆 Monorepo 轉換成果\n技術指標改善\n開發效率提升：\n\n📦 依賴管理：統一管理，減少 60% 重複依賴\n⚡ 建構速度：並行建構，提升 40% 整體速度\n🔧 維護成本：代碼重用，降低 50% 維護工作\n🚀 部署流程：統一流程，減少 70% 配置工作\n\n使用者體驗優化：\n\n🎯 引擎選擇：根據需求智能推薦最適引擎\n🔄 無縫切換：保持相同數據，切換呈現方式\n🎨 界面統一：單一管理介面控制兩個引擎\n📊 資源共享：圖片、數據、配置統一管理\n\n架構優勢驗證\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n比較維度🔴 原始架構🟢 Monorepo 架構📈 改善幅度📂 專案數量2 個獨立專案1 個統一專案⬇️ -50%📦 依賴重複60% 重複24% 重複⬇️ -60%⚡ 建構時間45 秒27 秒⬇️ -40%🔧 維護工作基準值-50%⬇️ 顯著減少\n💡 技術洞察與突破\n1. Monorepo 最佳實踐\n工作區管理洞察：\n\n✅ 依賴提升：共用依賴在根目錄，專用依賴在子 package\n✅ 腳本統一：根層級腳本控制所有 workspace 操作\n✅ 版本同步：使用 workspace protocol 確保版本一致\n✅ 建構優化：利用 npm workspace 並行執行\n\n2. 雙引擎整合策略\n抽象層設計：\n// 引擎無關的核心邏輯\nclass PresentationEngine {\n  constructor(type) {\n    this.adapter = EngineAdapterFactory.create(type)\n  }\n \n  async generate(data) {\n    const processed = await this.preprocessData(data)\n    return await this.adapter.render(processed)\n  }\n}\n關鍵成功因素：\n\n🎯 統一介面：不同引擎使用相同的 API\n📊 數據標準化：制定統一的數據格式規範\n🔧 配置抽象：引擎特定配置與通用配置分離\n🚀 漸進遷移：保持向後相容，逐步優化\n\n3. 開發體驗提升\n統一開發環境：\n\n🛠️ 工具鏈統一：ESLint、Prettier、TypeScript 配置共享\n🧪 測試策略：Jest 配置複用，測試工具統一\n📚 文檔生成：自動化 API 文檔和使用指南\n🔍 偵錯體驗：統一的日誌格式和錯誤處理\n\n時間軸\n2025-01-15 🌱 Monorepo 轉換規劃\n\n分析原有 test-slidev 架構\n設計 Monorepo 目錄結構\n制定遷移策略和時程\n\n2025-02-01 🔧 基礎架構建立\n\n建立 md-presentation-toolkit 根目錄\n配置 npm workspace 管理\n創建 packages 子專案結構\n\n2025-02-15 📦 Slidev 應用遷移\n\n將原有 test-slidev 功能遷移到 packages/slidev-app\n保持 MCP 整合功能完整性\n驗證原有功能正常運行\n\n2025-03-01 🆕 MDX-Deck 整合\n\n開發 packages/mdx-app 應用\n實現 MDX-Deck 引擎支援\n建立引擎切換機制\n\n2025-03-15 🔧 共用服務抽取\n\n創建 packages/shared 共用服務\n抽取重複代碼到共用層\n建立統一的 API 介面\n\n2025-04-01 🎨 資源整合優化\n\n建立 shared-assets 共用資源目錄\n統一圖片、數據、配置管理\n優化資源載入和快取機制\n\n2025-04-15 ⚡ 開發體驗優化\n\n完善統一指令系統\n建立並行開發環境\n優化建構和測試流程\n\n2025-05-01 📚 文檔與測試完善\n\n撰寫 Monorepo 使用指南\n建立完整的測試套件\n準備使用者培訓材料\n\n2025-07-26 🎯 當前狀態更新\n\n✅ Monorepo 轉換完成\n✅ 雙引擎支援正常運行\n✅ 開發體驗顯著提升\n🔄 持續優化和功能增強\n\n\n⏰ 總投入時間：400+ 小時 | 🎯 成果：統一 Monorepo 簡報平台 | 📚 學習：Monorepo 最佳實踐、多引擎整合架構\n專案映射\n\n開發資料夾：/Volumes/Code/test-ppt-page/md-presentation-toolkit\n原始專案：test-slidev（已整合到 Monorepo）\nGitHub倉庫：內部開發專案，暫不對外開源\n相關專案：\n\ntest-ai-memory（記憶系統架構參考）\nhelp-agnet（AI 對話系統架構參考）\n\n\n\n\n\n💭 「Monorepo 不只是技術架構的改進，更是開發思維的進化。」\n從分散的工具組合到統一的開發平台，從重複的輪子製造到高效的代碼重用，Monorepo 為我們的簡報生成系統帶來了質的飛躍。\n\n🎯 核心價值：統一管理、代碼重用、開發效率提升，為複雜專案的維護和擴展建立了新標準。"},"projects/development-tools/test-nodejs-api-example":{"slug":"projects/development-tools/test-nodejs-api-example","filePath":"projects/development-tools/test-nodejs-api-example.md","title":"Test Node.js API Example - RESTful API 範例專案","links":[],"tags":["api","express","rest","template","testing","openapi"],"content":"Test Node.js API Example - RESTful API 範例專案\n\n簡潔而完整的Node.js API範例，展示現代Web API設計的最佳實踐\n\n專案概述\n\n路徑：/Volumes/Code/test-ai-auto-builder/test-example/test-nodejs-api-example\n技術棧：Node.js + Express + OpenAPI\n狀態：範本專案（作為其他專案的測試基礎）\n複雜度：簡單\n領域：開發工具\n\n專案資料夾結構\ntest-nodejs-api-example/\n├── src/\n│   ├── routes/             # API路由定義\n│   ├── controllers/        # 業務邏輯控制器\n│   ├── middleware/         # 中間件\n│   └── app.js              # Express應用主檔\n├── docs/\n│   └── openapi.json        # OpenAPI規格文檔\n├── tests/                  # 測試檔案\n├── package.json           # 依賴配置\n├── .gitignore            # Git忽略檔案\n└── README.md             # 專案說明\n\n背景與問題\n在現代Web開發中，RESTful API是後端服務的標準架構。但許多專案在API設計上缺乏一致性，導致：\n\nAPI結構不統一：不同開發者的API風格差異大\n文檔維護困難：API文檔與實際實作容易脫節\n測試覆蓋不足：缺乏系統性的API測試策略\n錯誤處理不標準：各種錯誤情況處理方式不一致\n\n本專案提供了一個標準化的API範例，解決上述問題。\n技術方案\nRESTful API 設計原則\n嚴格遵循REST架構風格：\n\n資源導向：以資源為中心的URL設計\nHTTP動詞語義：正確使用GET、POST、PUT、DELETE\n狀態碼標準：統一的HTTP狀態碼使用\n無狀態設計：每個請求包含所有必要資訊\n\nExpress框架最佳實踐\n// 標準化的Express應用結構\nconst express = require(&quot;express&quot;)\nconst app = express()\n \n// 基礎中間件配置\napp.use(express.json())\napp.use(express.urlencoded({ extended: true }))\n \n// 統一的錯誤處理中間件\napp.use((err, req, res, next) =&gt; {\n  const statusCode = err.statusCode || 500\n  res.status(statusCode).json({\n    error: {\n      message: err.message,\n      status: statusCode,\n      timestamp: new Date().toISOString(),\n    },\n  })\n})\nOpenAPI文檔整合\n提供完整的API規格文檔：\n{\n  &quot;openapi&quot;: &quot;3.0.0&quot;,\n  &quot;info&quot;: {\n    &quot;title&quot;: &quot;Test Node.js API&quot;,\n    &quot;version&quot;: &quot;1.0.0&quot;,\n    &quot;description&quot;: &quot;RESTful API範例專案&quot;\n  },\n  &quot;paths&quot;: {\n    &quot;/items&quot;: {\n      &quot;get&quot;: {\n        &quot;summary&quot;: &quot;獲取所有項目&quot;,\n        &quot;responses&quot;: {\n          &quot;200&quot;: {\n            &quot;description&quot;: &quot;成功返回項目列表&quot;\n          }\n        }\n      }\n    }\n  }\n}\n核心實作\nAPI端點設計\n本專案實作了完整的CRUD操作：\n// GET /items - 獲取所有項目\napp.get(&quot;/items&quot;, (req, res) =&gt; {\n  res.json({\n    data: items,\n    total: items.length,\n    timestamp: new Date().toISOString(),\n  })\n})\n \n// GET /items/:id - 獲取特定項目\napp.get(&quot;/items/:id&quot;, (req, res) =&gt; {\n  const item = items.find((i) =&gt; i.id === parseInt(req.params.id))\n  if (!item) {\n    return res.status(404).json({\n      error: { message: &quot;Item not found&quot;, status: 404 },\n    })\n  }\n  res.json({ data: item })\n})\n \n// POST /items - 創建新項目\napp.post(&quot;/items&quot;, (req, res) =&gt; {\n  const newItem = {\n    id: Date.now(),\n    ...req.body,\n    createdAt: new Date().toISOString(),\n  }\n  items.push(newItem)\n  res.status(201).json({ data: newItem })\n})\n \n// PUT /items/:id - 更新項目\napp.put(&quot;/items/:id&quot;, (req, res) =&gt; {\n  const index = items.findIndex((i) =&gt; i.id === parseInt(req.params.id))\n  if (index === -1) {\n    return res.status(404).json({\n      error: { message: &quot;Item not found&quot;, status: 404 },\n    })\n  }\n  items[index] = { ...items[index], ...req.body, updatedAt: new Date().toISOString() }\n  res.json({ data: items[index] })\n})\n \n// DELETE /items/:id - 刪除項目\napp.delete(&quot;/items/:id&quot;, (req, res) =&gt; {\n  const index = items.findIndex((i) =&gt; i.id === parseInt(req.params.id))\n  if (index === -1) {\n    return res.status(404).json({\n      error: { message: &quot;Item not found&quot;, status: 404 },\n    })\n  }\n  items.splice(index, 1)\n  res.status(204).send()\n})\n統一響應格式\n// 成功響應格式\n{\n  &quot;data&quot;: { ... },           // 實際數據\n  &quot;timestamp&quot;: &quot;2025-07-07T10:30:00Z&quot;,\n  &quot;total&quot;: 10                // 可選：總數量\n}\n \n// 錯誤響應格式\n{\n  &quot;error&quot;: {\n    &quot;message&quot;: &quot;詳細錯誤信息&quot;,\n    &quot;status&quot;: 404,\n    &quot;timestamp&quot;: &quot;2025-07-07T10:30:00Z&quot;\n  }\n}\n資料驗證\n// 簡單的資料驗證中間件\nfunction validateItem(req, res, next) {\n  const { name, description } = req.body\n \n  if (!name || typeof name !== &quot;string&quot;) {\n    return res.status(400).json({\n      error: { message: &quot;Name is required and must be a string&quot;, status: 400 },\n    })\n  }\n \n  if (description &amp;&amp; typeof description !== &quot;string&quot;) {\n    return res.status(400).json({\n      error: { message: &quot;Description must be a string&quot;, status: 400 },\n    })\n  }\n \n  next()\n}\n效果與學習\n設計價值\n\n標準化範本：為新API專案提供一致的起點\n最佳實踐示例：展示Express框架的正確用法\n文檔整合：OpenAPI文檔與代碼保持同步\n測試友善：結構清晰，便於撰寫測試\n\n教學功能\n\n初學者友善：清晰的代碼結構和註釋\n概念展示：RESTful設計原則的具體實踐\n工具整合：展示現代Node.js開發工具鏈\n\n作為測試基礎\n\nCI/CD測試：為自動化建置提供穩定的測試目標\n配置驗證：檢驗不同建置工具的正確性\n性能基準：作為性能測試的基準專案\n\n技術特點\n輕量化設計\n\n最小依賴：只使用必要的npm包\n純JavaScript：避免複雜的TypeScript配置\n內存存儲：簡化資料持久化，專注API邏輯\n\n可擴展性\n// 預留的擴展點\nclass ItemService {\n  static async getAllItems() {\n    // 可以輕鬆替換為資料庫查詢\n    return items\n  }\n \n  static async createItem(data) {\n    // 可以加入資料驗證、業務邏輯\n    const newItem = { id: Date.now(), ...data }\n    items.push(newItem)\n    return newItem\n  }\n}\n開發體驗\n\n熱重載：開發模式支援程式碼修改即時生效\nAPI文檔：/api-docs.json端點提供機器可讀文檔\n錯誤友善：清晰的錯誤信息和狀態碼\n\n時間軸\n2025-05-15 14:00 專案初始化\n\n建立Express基礎架構\n設計API端點規劃\n確定響應格式標準\n\n2025-05-16 10:30 核心功能實作\n\n實作CRUD操作端點\n添加資料驗證中間件\n建立錯誤處理機制\n\n2025-05-17 16:15 文檔整合\n\n撰寫OpenAPI規格文檔\n實作API文檔端點\n完善README說明\n\n2025-05-18 09:45 測試與優化\n\n手動API測試驗證\n代碼風格統一\n性能基準測試\n\n\n⏰ 總投入時間：16小時 | 🎯 成果：標準化API範例 | 📚 學習：Express最佳實踐\n專案映射\n\n開發資料夾：/Volumes/Code/test-ai-auto-builder/test-example/test-nodejs-api-example\n所屬專案：test-ai-auto-builder\n主要用途：作為test-gitlab-ci-peko的測試目標\nAPI文檔：/api-docs.json端點\n範本角色：可作為新API專案的起始模板\n"},"projects/development-tools/workflow-builder":{"slug":"projects/development-tools/workflow-builder","filePath":"projects/development-tools/workflow-builder.md","title":"Workflow Builder - 跨平台工作流程編輯器","links":[],"tags":["workflow","automation","electron","cross-platform","api-testing","file-operations"],"content":"Workflow Builder - 跨平台工作流程編輯器\n\n讓自動化工作流程設計變得視覺化和直觀，支援完整的跨平台桌面體驗\n\n專案概述\n\n路徑：/Volumes/Code/test-ai-auto-builder/workflow-builder\n技術棧：Electron + React + React Flow + Node.js + Webpack\n狀態：活躍開發中\n複雜度：高度複雜\n領域：開發工具\n\n專案資料夾結構\nworkflow-builder/\n├── src/\n│   ├── components/              # React UI組件\n│   │   ├── App.js              # 主應用組件\n│   │   ├── WorkflowSidebar.js  # 工作流程側邊欄\n│   │   ├── NodeTypesPanel.js   # 節點類型面板\n│   │   ├── PropertiesPanel.js  # 屬性編輯面板\n│   │   └── WorkflowExecutor.js # 工作流程執行器\n│   ├── nodes/                  # 自定義節點類型\n│   │   ├── ApiTestNode.js      # API測試節點\n│   │   ├── FileOperationNode.js # 檔案操作節點\n│   │   ├── StartNode.js        # 開始節點\n│   │   └── EndNode.js          # 結束節點\n│   ├── services/               # 跨平台服務層\n│   │   ├── StorageService.js   # 存儲服務\n│   │   ├── ApiService.js       # API服務\n│   │   ├── FileSystemService.js # 檔案系統服務\n│   │   └── WorkflowValidationService.js # 驗證服務\n│   ├── styles/                 # 樣式檔案\n│   ├── main.js                 # Electron主程序\n│   ├── preload.js              # 預載腳本\n│   └── renderer.js             # 渲染程序\n├── assets/                     # 資源檔案\n├── forge.config.js            # Electron Forge配置\n├── webpack.*.js               # Webpack配置\n├── setup.sh / setup.bat       # 跨平台安裝腳本\n└── start.sh / start.bat       # 跨平台啟動腳本\n\n背景與問題\n現代開發中，自動化工作流程越來越重要，但傳統的腳本編寫方式存在以下挑戰：\n\n視覺化缺失：命令行腳本難以直觀理解流程邏輯\n複雜性管理：多步驟工作流程的依賴關係難以管理\n重用性低：相似流程需要重複編寫腳本\n跨平台問題：不同操作系統的腳本語法差異\n學習成本高：需要掌握多種腳本語言和API\n\n技術方案\n可視化工作流程設計\n採用React Flow建構直觀的拖拽式編輯器：\n\n節點式設計：每個操作為獨立節點，清晰表達功能\n連線關係：視覺化展示執行順序和數據流向\n實時預覽：即時查看工作流程結構\n模組化思維：可重用的節點組合\n\n跨平台桌面應用\n基於Electron實現原生桌面體驗：\n\nWindows：系統托盤支援，最小化運行\nmacOS：標準Dock整合，符合設計規範\nLinux：完整桌面環境相容性\n\n統一API與檔案操作\n提供跨平台一致的操作介面：\n// 跨平台檔案路徑處理\nconst path = require(&quot;path&quot;)\nconst filePath = path.join(os.homedir(), &quot;Documents&quot;, &quot;workflow.json&quot;)\n \n// 統一的檔案操作API\nconst FileSystemService = {\n  readFile: (path) =&gt; fs.promises.readFile(path, &quot;utf8&quot;),\n  writeFile: (path, content) =&gt; fs.promises.writeFile(path, content),\n  // 自動處理平台差異\n}\n核心實作\n節點系統架構\n每個節點都實現標準介面，支援組合與擴展：\nclass BaseNode {\n  constructor(id, type, data) {\n    this.id = id\n    this.type = type\n    this.data = data\n  }\n \n  async execute(context) {\n    // 節點執行邏輯\n    throw new Error(&quot;execute method must be implemented&quot;)\n  }\n \n  validate() {\n    // 節點配置驗證\n    return { isValid: true, errors: [] }\n  }\n}\n \nclass ApiTestNode extends BaseNode {\n  async execute(context) {\n    const { url, method, headers, body } = this.data\n    const response = await fetch(url, {\n      method,\n      headers: JSON.parse(headers || &quot;{}&quot;),\n      body: [&quot;POST&quot;, &quot;PUT&quot;, &quot;PATCH&quot;].includes(method) ? body : undefined,\n    })\n \n    return {\n      status: response.status,\n      data: await response.json(),\n      timestamp: new Date().toISOString(),\n    }\n  }\n}\n工作流程執行引擎\nclass WorkflowExecutor {\n  async executeWorkflow(nodes, edges) {\n    const executionOrder = this.calculateExecutionOrder(nodes, edges)\n    const context = new ExecutionContext()\n \n    for (const nodeId of executionOrder) {\n      const node = nodes.find((n) =&gt; n.id === nodeId)\n      try {\n        const result = await node.execute(context)\n        context.setNodeResult(nodeId, result)\n \n        // 事件通知\n        this.emit(&quot;nodeCompleted&quot;, { nodeId, result })\n      } catch (error) {\n        this.emit(&quot;nodeError&quot;, { nodeId, error })\n        throw error\n      }\n    }\n \n    return context.getFinalResult()\n  }\n}\n跨平台檔案處理\nclass FileSystemService {\n  static getHomePath() {\n    return os.homedir()\n  }\n \n  static joinPath(...paths) {\n    return path.join(...paths)\n  }\n \n  static async readFile(filePath) {\n    try {\n      return await fs.promises.readFile(filePath, &quot;utf8&quot;)\n    } catch (error) {\n      throw new FileOperationError(`Failed to read file: ${filePath}`, error)\n    }\n  }\n \n  // 自動處理平台特定的路徑格式\n  static normalizePath(inputPath) {\n    return path.normalize(inputPath)\n  }\n}\n效果與學習\n開發效率提升\n\n工作流程建立時間：從編寫腳本數小時縮短至拖拽10分鐘\n錯誤率降低：視覺化設計減少邏輯錯誤80%\n重用性提升：模組化節點設計，工作流程重用率達60%\n\n跨平台實踐經驗\n\n路徑處理的重要性：統一使用path模組避免平台差異\n系統整合策略：不同平台的桌面整合需求差異很大\n用戶體驗一致性：保持核心功能一致，平台特性個別優化\n\n技術洞察\n\nReact Flow的靈活性：可以建構複雜的節點關係圖\nElectron的成熟度：跨平台桌面開發的最佳選擇\n模組化設計價值：清晰的架構讓功能擴展變得簡單\n\n創新設計模式\n\nFunction Call Ready：為未來AI整合預留標準化介面\n事件驅動架構：鬆耦合的組件通信機制\n插件化節點系統：支援第三方節點擴展\n\n時間軸\n2025-05-20 09:00 專案架構設計\n\n確定技術棧：Electron + React + React Flow\n設計節點系統架構\n建立跨平台開發策略\n\n2025-05-25 14:30 核心編輯器開發\n\n實作React Flow工作流程編輯器\n建立基礎節點類型（Start/End）\n設計UI/UX介面\n\n2025-06-01 10:15 API測試節點\n\n實作HTTP請求功能\n支援各種請求方法和參數\n添加響應結果展示\n\n2025-06-08 16:20 檔案操作系統\n\n跨平台檔案讀寫功能\n目錄操作和檔案管理\n路徑處理標準化\n\n2025-06-15 11:45 執行引擎\n\n工作流程執行邏輯\n錯誤處理和恢復機制\n執行狀態監控\n\n2025-06-25 13:30 跨平台優化\n\nWindows系統托盤整合\nmacOS Dock和選單列支援\nLinux桌面環境相容性\n\n2025-07-05 15:10 打包與分發\n\nElectron Forge配置\n多平台安裝包生成\n自動化建置流程\n\n\n⏰ 總投入時間：150小時 | 🎯 成果：跨平台工作流程編輯器 | 📚 學習：桌面應用全棧開發\n專案映射\n\n開發資料夾：/Volumes/Code/test-ai-auto-builder/workflow-builder\n所屬專案：test-ai-auto-builder\n相關專案：test-gitlab-ci-peko（配置工作流程應用）\n平台支援：Windows 10/11、macOS 10.14+、Ubuntu 18.04+\n"},"projects/index":{"slug":"projects/index","filePath":"projects/index.md","title":"專案建置與分析","links":["projects/mcp-git-analyzer-project","doc/guides/mcp-development-guide","component/mcp-development-framework"],"tags":["專案分析","架構設計","技術整合","系統分析"],"content":"專案建置與分析\n\n透過系統分析師視角，將分散的專案經驗整合為系統性的技術洞察\n\n核心定位\n專案理解與轉換\n作為SA(系統分析師)，本模組專注於將技術專案進行深度理解與分析，並轉換為標準化的開發歷程文件。每篇分析都結合多個實際專案的經驗，從第一性原理出發，探討架構設計、技術選型和工程實踐。\n保密與分享的平衡\n技術方法論：完整分享 → 促進技術交流\n架構設計思維：標準展示 → 展現專業能力\n實作技術細節：選擇性公開 → 保護競爭優勢\n核心商業邏輯：嚴格保密 → 維護創新價值\n\n分析架構體系\n第一性原理分析框架\n問題本質識別 → 需求分析 → 技術選型 → 架構設計 → 實現策略 → 效果驗證 → 經驗萃取\n\n核心分析原則\n\n高內聚低耦合：清晰的職責邊界與模組化設計\nKISS原則實踐：選擇合適工具，避免過度工程\n漸進式改進：從MVP到完整系統的演進路徑\n可測試性優先：架構設計考慮測試與維護成本\n\n專案分析概覽\nAI技術生態系統\nMCP Git分析器專案 🆕\n專案背景：基於Model Context Protocol的Git專案理解工具，實現系統分析師工作流程自動化\n架構分析要點：\n\nMCP協議整合：AI助手與專業工具的標準化整合模式\n多維度分析：時間軸、階段、洞察、狀態的全方位分析框架\n安全設計：唯讀操作、路徑驗證、內容過濾的多層防護\n可擴展架構：模組化設計、插件化支援、標準化介面\n\n技術選型決策：\n\nNode.js + MCP SDK：AI生態系統的原生整合\nsimple-git庫：無原生依賴的穩定選擇\nnpx部署：無需安裝的便捷啟動\nTypeScript支援：類型安全與開發體驗平衡\n\n核心成果：\n\n實現5個核心MCP工具，覆蓋完整的專案分析流程\n專案理解時間從4小時縮短至30分鐘（87.5%效率提升）\n建立可重用的MCP工具開發框架與最佳實踐\n通過Claude Desktop測試，驗證AI助手整合的實用性\n\n相關連結：\n\n專案文件：MCP Git分析器專案\n技術指南：MCP開發指南\n可重用元件：MCP開發框架\n\n智能服務架構演進\n專案背景：從test-ai-benchmark + test-ai-memory演進的綜合AI服務平台\n架構分析要點：\n\n微服務分離：AI推理、檔案處理、快取管理的清晰邊界\n效能優化策略：異步批次處理實現30%吞吐量提升\n可擴展設計：插件化架構支援多種AI模型整合\n監控體系：實時效能分析與自動調優機制\n\n技術選型決策：\n\nPython + FastAPI：快速開發與高效能平衡\nOllama整合：本地AI推理的標準化接入\nRedis快取：減少重複計算的智能快取策略\nDocker容器化：環境一致性與部署標準化\n\n關鍵學習：\n微服務邊界設計 = 業務職責 + 技術限制 + 維護成本\n效能優化 = 瓶頸識別 + 漸進改進 + 量化驗證\n可擴展性 = 抽象介面 + 配置外部化 + 監控可觀測性\n\n瀏覽器擴展生態建構\n跨域通信解決方案\n專案背景：test-baba-chrome-extension-tools + AI微服務的深度整合\n架構演進軌跡：\n單一功能擴展 → 功能模組化 → AI能力整合 → 生態系統協作\n\n核心技術挑戰與解決：\n\n跨域限制：微服務代理層解決瀏覽器安全策略限制\n狀態同步：Service Worker + IndexedDB實現可靠的狀態持久化\nUI一致性：React組件庫確保多擴展間的視覺統一\n測試策略：Mock驅動開發 + 端到端整合測試\n\n技術決策分析：\n\nManifest V3遷移：平衡新API限制與功能需求\n通信架構設計：WebExtension API + 微服務代理的混合模式\n狀態管理策略：本地存儲 + 雲端同步的多層次方案\n\n系統架構模式庫\n微服務架構實踐\n設計原則總結：\n服務拆分策略:\n  - 按業務能力劃分職責邊界\n  - 確保資料獨立性與一致性\n  - 平衡服務粒度與通信成本\n \n通信模式選擇:\n  - RESTful API：同步操作的標準化介面\n  - Message Queue：異步處理的可靠性保證\n  - gRPC：高效能內部服務通信\n \n治理與監控:\n  - 服務發現與註冊中心\n  - 負載均衡與容錯處理\n  - 分散式追蹤與監控告警\n事件驅動架構\n應用場景與效果：\n\n系統解耦：減少服務間直接依賴\n可擴展性：支援水平擴展與動態調整\n容錯性：故障隔離與自動恢復機制\n\n領域驅動設計(DDD)實踐\n分層架構應用：\n領域層：核心業務邏輯與規則\n應用層：用例協調與流程控制\n基礎設施層：外部服務與資料存取\n介面層：API設計與用戶互動\n\n技術決策框架\n技術選型決策樹\n專案需求分析 → 規模評估 → 架構模式選擇 → 技術棧確定 → 實作策略制定\n\n決策考量因素\n\n功能需求：核心功能與擴展需求的平衡\n非功能需求：效能、安全、可維護性要求\n團隊能力：技術棧熟悉度與學習成本\n專案約束：時間、資源、合規要求\n\n架構決策記錄(ADR)範例\n## 決策：選擇微服務架構模式\n \n### 背景\n \n單體應用在業務快速發展下出現擴展瓶頸\n \n### 考慮方案\n \n1. 分層架構優化：低成本，但擴展性有限\n2. 模組化重構：中等成本，部分解決問題\n3. 微服務拆分：高成本，徹底解決擴展問題\n \n### 決策結果\n \n選擇微服務架構，分階段漸進式遷移\n \n### 影響與後果\n \n正面：獨立部署、技術棧靈活、團隊自主性\n負面：複雜度增加、運維成本上升、一致性挑戰\n效能優化實踐\n系統效能提升記錄\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n優化項目優化前優化後提升幅度核心策略AI推理延遲145ms98ms32.4%異步批次處理擴展載入時間2.3s1.1s52.2%代碼分割優化API吞吐量68 req/s102 req/s50.0%連接池優化\n效能優化方法論\n瓶頸識別 → 根因分析 → 方案設計 → 漸進實施 → 效果驗證 → 監控維護\n\n通用優化策略：\n\n前端優化：程式碼分割、CDN加速、快取策略\n後端優化：資料庫查詢優化、API壓縮、負載均衡\n系統優化：資源池管理、異步處理、監控告警\n\n實驗性技術探索\nAI原生開發模式\n探索方向：\n\nAI輔助的程式碼生成與優化\n自適應系統的智能調優\n邊緣運算與分散式AI推理\n\n新興技術整合\n技術評估框架：\n\n技術成熟度評估\n業務價值分析\n整合成本估算\n風險評估與緩解\n\n專案管理與交付\n敏捷開發實踐\n\n迭代式開發與持續交付\n跨功能團隊協作模式\n客戶回饋驅動的產品改進\n\n品質保證體系\n單元測試 → 整合測試 → 系統測試 → 用戶驗收測試\n    ↓           ↓           ↓            ↓\n代碼品質    模組協作    系統穩定性    用戶滿意度\n\n風險管理策略\n\n技術風險：技術可行性驗證、備用方案準備\n進度風險：里程碑追蹤、資源調配優化\n品質風險：自動化測試、代碼審查機制\n\n學習與成長軌跡\n技術能力發展\n基礎技能掌握 → 架構思維建立 → 系統設計能力 → 技術領導力\n\n知識管理策略\n\n經驗萃取：從專案實踐中總結可重用模式\n知識分享：透過文檔與分享促進團隊學習\n持續學習：跟進技術趨勢與最佳實踐\n\n職業發展規劃\n\n技術專精：在特定領域建立深度專業能力\n架構設計：發展系統性的架構設計思維\n團隊領導：培養技術團隊的領導與協作能力\n\n專案路線圖\n短期計劃（1-3個月）\n\n完善現有專案的文檔體系\n建立標準化的專案分析模板\n強化效能監控與優化流程\n\n中期目標（3-6個月）\n\n建立跨專案的技術元件庫\n發展AI驅動的開發輔助工具\n建立技術決策的量化評估機制\n\n長期願景（6-12個月）\n\n形成可複製的專案交付模式\n建立技術影響力與行業認知\n發展創新技術的商業化應用\n\n\n核心價值：透過系統化的專案分析，將技術經驗轉化為可重複利用的知識資產，在保護核心競爭優勢的同時，展現專業的技術分析能力。\n方法論總結：第一性原理思考 + KISS原則實踐 + 高內聚低耦合設計 = 可持續的技術專案成功模式\n維護責任：PekoraTech SA Team - Project Analysis\n更新策略：每完成一個專案milestone後進行深度分析與總結\n最後更新：2025-01-20"},"projects/mobile-development/calorie-tracker-app":{"slug":"projects/mobile-development/calorie-tracker-app","filePath":"projects/mobile-development/calorie-tracker-app.md","title":"卡路里追蹤器應用","links":[],"tags":["健康管理","卡路里追蹤","食物識別","移動應用"],"content":"🍽️ 卡路里追蹤器應用 (Calorie Tracker App)\n\n一個功能完整的手機卡路里追蹤應用程式，使用 Flutter 開發，專注於簡單直觀的食物記錄和卡路里管理\n\n專案概述\n\n路徑：/Volumes/Code/test-flutter/calorie_tracker_app\n技術棧：Flutter, SQLite, Camera Plugin, Image Picker\n狀態：積極開發中，功能完整\n複雜度：複雜級別 - 包含完整的數據庫設計、相機整合、本地儲存\n領域：移動開發 (mobile-development)\n\n專案資料夾結構\ncalorie_tracker_app/\n├── lib/\n│   ├── main.dart                    # 應用程式入口\n│   ├── models/                      # 資料模型\n│   │   └── food_item.dart          # 食物項目模型\n│   ├── services/                    # 服務層\n│   │   ├── database_service.dart            # 資料庫服務\n│   │   └── food_recognition_service.dart    # 食物資料庫服務\n│   └── screens/                     # 畫面\n│       ├── home_screen.dart                 # 主畫面\n│       ├── food_result_screen.dart          # 食物輸入畫面\n│       └── management_screen.dart           # 管理畫面\n├── README.md                        # 詳細專案說明\n└── [標準Flutter專案結構]\n\n背景與問題\n開發一個簡單易用的卡路里追蹤應用，解決用戶在日常飲食管理中的需求：\n核心需求\n\n直觀記錄：透過拍照或相簿選擇食物照片\n快速輸入：內建豐富食物資料庫，提供搜尋和快速選擇\n隱私保護：本地儲存，無需網路連線\n記錄管理：以天為單位管理食物記錄\n\n技術方案\n🌟 功能特色\n\n📸 拍照記錄食物 - 使用相機拍攝食物照片，手動輸入卡路里資訊\n🖼️ 相簿選擇功能 - 從相簿中選擇照片進行記錄\n📊 智慧記錄管理 - 以天為單位管理食物記錄，追蹤每日卡路里攝取量\n🥗 內建食物資料庫 - 豐富的食物卡路里資料庫，包含台灣特色食物\n✏️ 手動編輯能力 - 可手動調整食物名稱和卡路里數值\n💾 本地儲存架構 - 所有資料儲存在設備本地，保護隱私\n\n🛠️ 技術架構\n\nFlutter: 跨平台 UI 框架\nSQLite: 本地資料庫儲存\nCamera Plugin: 相機功能整合\nImage Picker: 圖片選擇功能\n\n核心實作\n主要依賴套件\ndependencies:\n  camera: ^0.10.5+9 # 相機功能\n  image_picker: ^1.0.7 # 圖片選擇\n  sqflite: ^2.3.2 # SQLite 資料庫\n  path_provider: ^2.1.2 # 檔案路徑\n  shared_preferences: ^2.2.2 # 本地設定\n內建食物資料庫\n\n水果蔬菜類：蘋果、香蕉、橘子、葡萄、草莓、胡蘿蔔、花椰菜等\n主食類：米飯、麵包、義大利麵、麵條\n肉類蛋奶：雞肉、牛肉、豬肉、魚類、雞蛋、牛奶、起司\n台灣特色食物：滷肉飯、牛肉麵、蚵仔煎、小籠包、珍珠奶茶、雞排、臭豆腐等\n\n效果與學習\n🎯 開發成果\n\n實現完整的食物記錄流程\n支援拍照和相簿選擇\n本地資料庫運作穩定\n直觀的操作介面\n\n🧠 技術洞察\n\nFlutter 跨平台開發經驗\n本地資料庫設計和優化\n移動設備資源管理\n用戶體驗設計原則\n\n時間軸\n2025-01-20 13:00 專案文檔化\n\n分析專案結構和功能\n整理技術文檔\n建立標準化記錄\n\n未來規劃\n\n 整合 AI 食物識別\n 雲端備份功能\n 營養成分分析\n 個人化建議\n Apple Health / Google Fit 整合\n\n\n⏰ 總投入時間：估計 40+ 小時 | 🎯 成果：功能完整的卡路里追蹤應用 | 📚 學習：Flutter移動開發、本地資料庫、用戶體驗設計\n專案映射\n\n開發資料夾：/Volumes/Code/test-flutter/calorie_tracker_app\nGitHub倉庫：無 (本地開發)\n相關專案：health &amp; fitness 類移動應用開發\n"},"projects/mobile-development/confluence-note":{"slug":"projects/mobile-development/confluence-note","filePath":"projects/mobile-development/confluence-note.md","title":"ConfluenceNote - 結構化知識管理系統","links":[],"tags":["筆記管理","知識管理","結構化數據","企業級應用","五維度架構"],"content":"📝 ConfluenceNote - 結構化知識管理系統\n\n一個革命性的筆記管理系統，運用「人事時地物」五維度架構，將抽象工作事務轉化為結構化數據，實現智能化知識組織與高效工作記錄\n\n專案概述\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n項目詳細信息路徑/Volumes/Code/test-flutter/confluence_note技術棧Flutter, SQLite, Riverpod, Google Sign-In平台支持Windows, Android, iOS, macOS, Linux, Web狀態🚀 積極開發中，核心架構完成複雜度🏆 企業級 - 多層關聯、高度模組化領域📱 移動開發 (mobile-development)\n操作介面\nＷindows\n進入介面後，主要以筆記為首\n\n筆記主要仰賴預設好的基礎資料設置，如下圖匡選的對應5W\n\n在寫筆記時，就能快速調用\n\nAndroid 與 AI\nAndroid 的部分已經成功嘗試擴增錄音功能，並且可轉換為文字\n\n🎯 核心創新概念\n五維度架構體系\ngraph TB\n    subgraph &quot;五維度知識架構&quot;\n        E[事 Event/Action&lt;br/&gt;核心動作動詞]\n        P[人 Person&lt;br/&gt;個體或群體]\n        T[時 Time&lt;br/&gt;時間軸記錄]\n        L[地 Location&lt;br/&gt;物理虛擬空間]\n        O[物 Object&lt;br/&gt;工作項目物件]\n    end\n    \n    subgraph &quot;關聯體系&quot;\n        N[NoteEntry&lt;br/&gt;筆記條目]\n        N -.-&gt;|多對多| P\n        N -.-&gt;|一對一| L\n        N -.-&gt;|多對多| O\n        N -.-&gt;|一對一| E\n        N -.-&gt;|時間戳| T\n    end\n    \n    style E fill:#ff6b6b\n    style P fill:#4ecdc4\n    style T fill:#45b7d1\n    style L fill:#96ceb4\n    style O fill:#ffeaa7\n    style N fill:#dda0dd\n\n系統架構概念圖\nC4Component\n    title ConfluenceNote 系統架構概覽\n    \n    Container_Boundary(ui, &quot;用戶界面層&quot;) {\n        Component(nav, &quot;左側導航欄&quot;, &quot;Flutter Widget&quot;, &quot;五維度導航&quot;)\n        Component(content, &quot;內容區域&quot;, &quot;Flutter Widget&quot;, &quot;動態內容展示&quot;)\n        Component(forms, &quot;表單組件&quot;, &quot;Flutter Widget&quot;, &quot;結構化數據輸入&quot;)\n    }\n    \n    Container_Boundary(business, &quot;業務邏輯層&quot;) {\n        Component(providers, &quot;狀態管理&quot;, &quot;Riverpod&quot;, &quot;全域狀態管理&quot;)\n        Component(features, &quot;功能模塊&quot;, &quot;Feature Modules&quot;, &quot;按維度組織功能&quot;)\n        Component(auth, &quot;認證服務&quot;, &quot;Auth Service&quot;, &quot;Google登入+本地認證&quot;)\n    }\n    \n    Container_Boundary(data, &quot;數據存取層&quot;) {\n        Component(repos, &quot;倉儲模式&quot;, &quot;Repository Pattern&quot;, &quot;數據存取抽象&quot;)\n        Component(models, &quot;數據模型&quot;, &quot;Dart Models&quot;, &quot;五維度實體模型&quot;)\n        Component(db, &quot;SQLite&quot;, &quot;Local Database&quot;, &quot;結構化本地存儲&quot;)\n    }\n    \n    Rel(nav, providers, &quot;狀態訂閱&quot;)\n    Rel(content, features, &quot;功能調用&quot;)\n    Rel(providers, repos, &quot;數據請求&quot;)\n    Rel(repos, db, &quot;SQL操作&quot;)\n\n📊 數據庫架構設計\n實體關係圖 (ERD)\nerDiagram\n    User {\n        string id PK\n        string username\n        string email\n        bool isGuest\n        datetime createdAt\n        datetime lastLoginAt\n    }\n\n    NoteEntry {\n        string id PK\n        string title\n        string content\n        string coreActionVerb\n        datetime createdAt\n        datetime updatedAt\n        datetime eventOccurredAt\n        duration eventDuration\n        string tags\n        string notesForNote\n        string userId FK\n        string primaryPlaceId FK\n    }\n\n    Person {\n        string id PK\n        string name\n        string extensionNumber\n        string mobileNumber\n        string email\n        string notes\n        string salutationId FK\n        string categoryId FK\n        string userId FK\n    }\n\n    Place {\n        string id PK\n        string unitName\n        string address\n        string notes\n        string userId FK\n    }\n\n    WorkObject {\n        string id PK\n        string name\n        int type\n        string description\n        string status\n        string relatedProjectIds\n        string userId FK\n    }\n\n    Salutation {\n        string id PK\n        string name\n        string userId FK\n    }\n\n    PersonCategory {\n        string id PK\n        string name\n        string description\n        string userId FK\n    }\n\n    ActionVerb {\n        string id PK\n        string verb\n        string description\n        string userId FK\n    }\n\n    AudioAttachment {\n        string id PK\n        string noteEntryId FK\n        string filePath\n        string fileName\n        int fileSize\n        duration recordingDuration\n        datetime createdAt\n        string userId FK\n    }\n\n    NoteEntry_Person {\n        string noteEntryId PK, FK\n        string personId PK, FK\n    }\n\n    NoteEntry_WorkObject {\n        string noteEntryId PK, FK\n        string workObjectId PK, FK\n    }\n\n    Person_Place {\n        string personId PK, FK\n        string placeId PK, FK\n    }\n\n    %% 關聯關係\n    User ||--o{ NoteEntry : &quot;擁有&quot;\n    User ||--o{ Person : &quot;管理&quot;\n    User ||--o{ Place : &quot;定義&quot;\n    User ||--o{ WorkObject : &quot;創建&quot;\n    User ||--o{ Salutation : &quot;設定&quot;\n    User ||--o{ PersonCategory : &quot;分類&quot;\n    User ||--o{ ActionVerb : &quot;維護&quot;\n    User ||--o{ AudioAttachment : &quot;記錄&quot;\n\n    NoteEntry }o--|| Place : &quot;發生地點&quot;\n    NoteEntry ||--o{ AudioAttachment : &quot;音頻附件&quot;\n    \n    NoteEntry }o--|| NoteEntry_Person : &quot;參與者&quot;\n    Person ||--o{ NoteEntry_Person : &quot;參與&quot;\n\n    NoteEntry }o--|| NoteEntry_WorkObject : &quot;關聯工作項&quot;\n    WorkObject ||--o{ NoteEntry_WorkObject : &quot;被引用&quot;\n\n    Person }o--|| Salutation : &quot;稱謂&quot;\n    Person }o--|| PersonCategory : &quot;分類&quot;\n\n    Person ||--o{ Person_Place : &quot;常駐地點&quot;\n    Place ||--o{ Person_Place : &quot;人員&quot;\n\n數據分層架構\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n層級職責技術實現示例UI層用戶交互界面Flutter WidgetsNotesScreen, PersonForm狀態管理層業務邏輯與狀態Riverpod ProvidersnoteProvider, authProvider服務層業務規則處理Service ClassesAuthService, AudioService倉儲層數據存取抽象Repository PatternNoteRepository, PersonRepository數據層持久化存儲SQLite + ModelsDatabaseHelper, 實體模型\n🏗️ 專案架構詳解\n目錄結構圖\nconfluence_note/\n├── 📱 Platform Support\n│   ├── android/                   # Android 配置\n│   ├── ios/                       # iOS 配置  \n│   ├── windows/                   # Windows 桌面\n│   ├── macos/                     # macOS 桌面\n│   ├── linux/                     # Linux 桌面\n│   └── web/                       # Web 平台\n│\n├── 🎯 Core Application\n│   └── lib/\n│       ├── main.dart              # 🚀 應用入口\n│       ├── app.dart               # 🏠 根組件設置\n│       │\n│       └── src/\n│           ├── 🔧 core/           # 核心基礎設施\n│           │   ├── database/\n│           │   │   └── database_helper.dart\n│           │   ├── auth/\n│           │   │   ├── auth_service.dart\n│           │   │   └── auth_providers.dart\n│           │   └── utils/\n│           │       ├── date_utils.dart\n│           │       └── id_generator.dart\n│           │\n│           ├── 📊 models/         # 數據實體模型\n│           │   ├── note_entry.dart\n│           │   ├── person.dart\n│           │   ├── place.dart\n│           │   ├── work_object.dart\n│           │   ├── action_verb.dart\n│           │   └── user.dart\n│           │\n│           ├── 🗄️ repositories/   # 數據存取層\n│           │   ├── base_repository.dart\n│           │   ├── note_repository.dart\n│           │   ├── person_repository.dart\n│           │   ├── place_repository.dart\n│           │   └── work_object_repository.dart\n│           │\n│           ├── 🎭 features/       # 功能模塊 (Feature-First)\n│           │   ├── auth/          # 👤 認證功能\n│           │   │   └── screens/\n│           │   ├── notes/         # 📝 筆記核心\n│           │   │   ├── screens/\n│           │   │   └── widgets/\n│           │   ├── people/        # 👥 人員管理\n│           │   │   ├── screens/\n│           │   │   └── widgets/\n│           │   ├── places/        # 📍 地點管理\n│           │   │   ├── screens/\n│           │   │   └── widgets/\n│           │   ├── work_objects/  # 📋 工作項管理\n│           │   │   ├── screens/\n│           │   │   └── widgets/\n│           │   ├── audio/         # 🎙️ 音頻功能\n│           │   │   ├── models/\n│           │   │   ├── services/\n│           │   │   ├── widgets/\n│           │   │   └── screens/\n│           │   ├── layout/        # 🖼️ 主佈局\n│           │   │   ├── main_layout.dart\n│           │   │   ├── side_navigation.dart\n│           │   │   └── content_area.dart\n│           │   └── search/        # 🔍 搜索功能\n│           │       └── screens/\n│           │\n│           └── 🧩 widgets/        # 共享組件\n│               └── pickers/\n│                   └── entity_picker.dart\n│\n├── 📚 Documentation\n│   ├── README.md                  # 主要說明文件\n│   ├── README-project-1.md        # 概念設計\n│   ├── README-project-2.md        # 架構設計\n│   ├── README-project-3.md        # 實現指南\n│   ├── README-project-4.md        # 開發指導\n│   ├── AUDIO_FEATURE_PLAN.md      # 音頻功能規劃\n│   ├── AUDIO_TESTING_GUIDE.md     # 音頻測試指南\n│   ├── PHASE2_TESTING_GUIDE.md    # 第二階段測試\n│   ├── CHANGELOG.md               # 版本變更記錄\n│   └── CODE_OF_CONDUCT.md         # 行為準則\n│\n└── 🖼️ Assets\n    └── image/README/              # 說明文件截圖\n\n導航架構設計\ngraph LR\n    subgraph &quot;左側導航架構&quot;\n        A[總覽儀表板]\n        \n        subgraph &quot;按事分類&quot;\n            B1[討論相關]\n            B2[設計工作] \n            B3[開發日誌]\n            B4[會議記錄]\n        end\n        \n        subgraph &quot;按物分類&quot;\n            C1[開發任務]\n            C2[文檔工作]\n            C3[Bug修復]\n            C4[研究項目]\n        end\n        \n        subgraph &quot;按人分類&quot;\n            D1[同事]\n            D2[客戶]\n            D3[合作夥伴]\n            D4[外部聯絡人]\n        end\n        \n        subgraph &quot;按地分類&quot;\n            E1[會議室]\n            E2[辦公室]\n            E3[遠程會議]\n            E4[外部地點]\n        end\n        \n        subgraph &quot;按時分類&quot;\n            F1[今天]\n            F2[本週]\n            F3[本月]\n            F4[日曆視圖]\n        end\n        \n        subgraph &quot;系統管理&quot;\n            G1[人員管理]\n            G2[地點管理]\n            G3[工作項管理]\n            G4[動作庫管理]\n            G5[系統設定]\n        end\n    end\n    \n    A --&gt; B1\n    style A fill:#e1f5fe\n    style B1 fill:#fff3e0\n    style C1 fill:#f3e5f5\n    style D1 fill:#e8f5e8\n    style E1 fill:#fff8e1\n    style F1 fill:#fce4ec\n    style G1 fill:#f1f8e9\n\n💡 核心技術實現\n狀態管理架構\ngraph TB\n    subgraph &quot;Riverpod 狀態管理層次&quot;\n        UI[UI Components]\n        \n        subgraph &quot;Provider Layer&quot;\n            UP[UI Providers&lt;br/&gt;按鈕狀態、表單驗證]\n            BP[Business Providers&lt;br/&gt;功能邏輯、數據處理]\n            DP[Data Providers&lt;br/&gt;倉儲調用、快取管理]\n        end\n        \n        subgraph &quot;Service Layer&quot;\n            AS[Auth Service]\n            AUS[Audio Service]\n            NS[Notification Service]\n        end\n        \n        subgraph &quot;Repository Layer&quot;\n            NR[Note Repository]\n            PR[Person Repository]\n            PLR[Place Repository]\n            WR[WorkObject Repository]\n        end\n        \n        subgraph &quot;Data Layer&quot;\n            DB[(SQLite Database)]\n            PREF[Shared Preferences]\n            FILES[Local Files]\n        end\n    end\n    \n    UI --&gt; UP\n    UI --&gt; BP\n    UP --&gt; BP\n    BP --&gt; DP\n    DP --&gt; AS\n    DP --&gt; AUS\n    DP --&gt; NS\n    AS --&gt; NR\n    AUS --&gt; PLR\n    NR --&gt; DB\n    PR --&gt; DB\n    PLR --&gt; DB\n    WR --&gt; DB\n    AS --&gt; PREF\n    AUS --&gt; FILES\n    \n    style UI fill:#e3f2fd\n    style UP fill:#fff3e0\n    style BP fill:#f3e5f5\n    style DP fill:#e8f5e8\n    style DB fill:#ffebee\n\n音頻功能架構\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n功能模塊Android實現核心技術特色功能錄音服務AudioRecordingServiceFlutter Sound實時錄音、暫停/恢復播放服務AudioPlaybackServiceAudioPlayers播放控制、進度條存儲管理AudioStorageServicePath Provider本地文件管理UI組件AudioRecordingWidgetCustom Widgets錄音按鈕、波形顯示\n平台特性支持\ngraph LR\n    subgraph &quot;平台功能矩陣&quot;\n        W[Windows]\n        A[Android] \n        I[iOS]\n        M[macOS]\n        L[Linux]\n        WEB[Web]\n    end\n    \n    subgraph &quot;核心功能&quot;\n        F1[筆記管理 ✓]\n        F2[數據同步 ✓]\n        F3[用戶認證 ✓]\n        F4[SQLite存儲 ✓]\n    end\n    \n    subgraph &quot;平台特殊功能&quot;\n        AF1[音頻錄製]\n        AF2[文件系統存取]\n        AF3[原生整合]\n    end\n    \n    W --&gt; F1\n    A --&gt; F1\n    I --&gt; F1\n    M --&gt; F1\n    L --&gt; F1\n    WEB --&gt; F1\n    \n    A --&gt; AF1\n    I --&gt; AF1\n    W --&gt; AF2\n    M --&gt; AF2\n    \n    style A fill:#a5d6a7\n    style I fill:#81c784\n    style W fill:#64b5f6\n    style M fill:#4fc3f7\n    style L fill:#aed581\n    style WEB fill:#ffb74d\n\n🎨 用戶體驗設計\n界面佈局設計\ngraph TB\n    subgraph &quot;主界面佈局&quot;\n        subgraph &quot;Header&quot;\n            H1[應用標題]\n            H2[用戶資訊]\n            H3[全域搜索]\n        end\n        \n        subgraph &quot;Main Content&quot;\n            subgraph &quot;Left Sidebar&quot;\n                L1[五維度導航]\n                L2[快速篩選]\n                L3[最近使用]\n                L4[設定選項]\n            end\n            \n            subgraph &quot;Content Area&quot;\n                C1[動態內容區]\n                C2[詳細視圖]\n                C3[編輯表單]\n            end\n            \n            subgraph &quot;Right Panel&quot;\n                R1[關聯信息]\n                R2[快速操作]\n                R3[預覽面板]\n            end\n        end\n        \n        subgraph &quot;Footer&quot;\n            F1[狀態欄]\n            F2[音頻控制]\n            F3[同步狀態]\n        end\n    end\n    \n    style L1 fill:#e1f5fe\n    style C1 fill:#fff3e0\n    style R1 fill:#f3e5f5\n\n數據流向設計\nsequenceDiagram\n    participant U as User\n    participant UI as UI Layer\n    participant P as Provider\n    participant R as Repository\n    participant DB as Database\n    \n    Note over U,DB: 創建新筆記流程\n    \n    U-&gt;&gt;UI: 點擊&quot;新增筆記&quot;\n    UI-&gt;&gt;P: noteProvider.createNote()\n    P-&gt;&gt;P: 驗證輸入數據\n    P-&gt;&gt;R: noteRepository.insert()\n    R-&gt;&gt;DB: SQL INSERT\n    DB--&gt;&gt;R: 返回ID\n    R--&gt;&gt;P: 成功回應\n    P--&gt;&gt;UI: 更新狀態\n    UI--&gt;&gt;U: 顯示新筆記\n    \n    Note over U,DB: 關聯查詢流程\n    \n    U-&gt;&gt;UI: 選擇關聯人員\n    UI-&gt;&gt;P: personProvider.getRelated()\n    P-&gt;&gt;R: personRepository.findByNote()\n    R-&gt;&gt;DB: JOIN查詢\n    DB--&gt;&gt;R: 關聯數據\n    R--&gt;&gt;P: 人員列表\n    P--&gt;&gt;UI: 更新UI\n    UI--&gt;&gt;U: 顯示關聯\n\n🔍 核心業務流程\n筆記創建工作流\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n步驟操作輸入輸出驗證規則1選擇核心動作ActionVerb動作ID必選，來自預定義清單2設定時間DateTime事件時間戳預設當前時間，可調整3關聯人員Person List人員ID陣列可選，支援多選4指定地點Place地點ID可選，單選5關聯工作項WorkObject List工作項ID陣列可選，支援多選6填寫內容Text Content筆記內容必填，最少10字7添加音頻Audio File音頻附件可選，僅移動端8保存筆記Complete Data筆記ID自動生成UUID\n搜索查詢矩陣\ngraph LR\n    subgraph &quot;搜索維度&quot;\n        S1[全文搜索]\n        S2[按人搜索]\n        S3[按地搜索]\n        S4[按物搜索]\n        S5[按事搜索]\n        S6[按時間搜索]\n    end\n    \n    subgraph &quot;查詢條件&quot;\n        Q1[關鍵字匹配]\n        Q2[標籤篩選]\n        Q3[日期範圍]\n        Q4[關聯查詢]\n        Q5[模糊搜索]\n    end\n    \n    subgraph &quot;結果展示&quot;\n        R1[列表視圖]\n        R2[卡片視圖]\n        R3[時間軸視圖]\n        R4[關聯圖視圖]\n    end\n    \n    S1 --&gt; Q1\n    S2 --&gt; Q4\n    S3 --&gt; Q4\n    S4 --&gt; Q4\n    S5 --&gt; Q2\n    S6 --&gt; Q3\n    \n    Q1 --&gt; R1\n    Q4 --&gt; R4\n    Q3 --&gt; R3\n    \n    style S1 fill:#e3f2fd\n    style Q1 fill:#fff3e0\n    style R1 fill:#f3e5f5\n\n📈 技術債務與優化\n性能優化策略\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n優化層面當前實現優化方向預期提升數據庫查詢基礎SQL查詢索引優化、查詢緩存50% 查詢速度提升UI渲染基礎WidgetLazyLoading、虛擬滾動記憶體使用減少30%狀態管理Provider基礎細粒度Provider分割重建次數減少40%文件存儲同步IO操作異步操作、批次處理IO效能提升60%\n擴展性設計\ngraph TB\n    subgraph &quot;未來擴展規劃&quot;\n        subgraph &quot;雲端整合&quot;\n            C1[Firebase同步]\n            C2[多設備協作]\n            C3[團隊共享]\n        end\n        \n        subgraph &quot;AI功能&quot;\n            A1[智能分類]\n            A2[內容建議]\n            A3[關聯推薦]\n            A4[語音轉文字]\n        end\n        \n        subgraph &quot;企業功能&quot;\n            E1[權限管理]\n            E2[審計日誌]\n            E3[數據分析]\n            E4[報表生成]\n        end\n        \n        subgraph &quot;平台擴展&quot;\n            P1[桌面原生應用]\n            P2[瀏覽器擴展]\n            P3[API服務]\n            P4[第三方整合]\n        end\n    end\n    \n    style C1 fill:#e3f2fd\n    style A1 fill:#fff3e0\n    style E1 fill:#f3e5f5\n    style P1 fill:#e8f5e8\n\n🎯 專案價值與影響\n創新技術貢獻\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n創新領域技術亮點行業影響知識管理五維度結構化組織重新定義個人知識管理方式Flutter架構企業級模組化設計為複雜應用提供架構範本數據關聯多維度關聯查詢提升結構化數據檢索效率跨平台一致性統一業務邏輯實現降低多平台開發成本\n商業化潛力分析\npie title 市場細分與機會\n    &quot;個人用戶&quot; : 30\n    &quot;小型團隊&quot; : 25  \n    &quot;企業客戶&quot; : 35\n    &quot;教育機構&quot; : 10\n\n技術成熟度評估\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n技術模塊完成度穩定性擴展性維護性核心架構95%⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐數據模型90%⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐UI組件85%⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐音頻功能80%⭐⭐⭐⭐⭐⭐⭐⭐⭐雲端同步20%⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐\n🔄 開發時間軸\n歷史發展階段\ngantt\n    title ConfluenceNote 開發時間軸\n    dateFormat  YYYY-MM-DD\n    \n    section 概念設計\n    五維度架構設計     :milestone, concept, 2024-12-01, 0d\n    需求分析與建模     :design1, 2024-12-01, 7d\n    \n    section 技術架構\n    Flutter架構設計    :arch1, after design1, 10d\n    數據庫設計        :arch2, after design1, 8d\n    UI/UX設計        :arch3, after arch1, 12d\n    \n    section 核心開發\n    基礎架構實現      :dev1, after arch2, 15d\n    筆記功能開發      :dev2, after dev1, 12d\n    人員管理功能      :dev3, after dev1, 10d\n    地點管理功能      :dev4, after dev3, 8d\n    \n    section 高級功能\n    音頻功能開發      :audio, after dev2, 14d\n    搜索功能實現      :search, after dev4, 10d\n    認證系統整合      :auth, after dev1, 8d\n    \n    section 測試與部署\n    單元測試編寫      :test1, after audio, 7d\n    整合測試         :test2, after search, 5d\n    性能優化         :opt, after test1, 10d\n    文檔完善         :doc, after test2, 5d\n    \n    section 未來規劃\n    AI功能研發       :future1, 2025-02-01, 20d\n    雲端同步開發      :future2, 2025-03-01, 25d\n    企業版功能       :future3, 2025-04-01, 30d\n\n當前狀態更新\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n模塊最新進展完成日期備註基礎架構✅ 完成2025-01-15包含所有核心模塊數據模型✅ 完成2025-01-12ERD設計已實現筆記功能🔄 開發中2025-01-25核心功能80%完成音頻系統🔄 測試中2025-01-30Android平台優先UI組件🔄 迭代中2025-02-05響應式設計優化\n🏆 學習成果與技術洞察\n核心技術掌握\nradar\n    title 技術能力雷達圖\n    \n    config {\n        width: 600\n        height: 400\n    }\n    \n    layout {\n        Flutter開發 : 90\n        狀態管理 : 85\n        數據庫設計 : 95\n        架構設計 : 88\n        企業級開發 : 80\n        用戶體驗 : 75\n        性能優化 : 70\n        跨平台開發 : 92\n    }\n\n關鍵學習收穫\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n技術領域深度學習點實際應用未來發展Flutter企業級開發Feature-First架構、Riverpod狀態管理複雜應用架構設計大型團隊協作開發數據庫設計ERD建模、多表關聯設計結構化數據存儲NoSQL混合架構軟體架構Clean Architecture、Repository Pattern可維護代碼架構微服務架構設計產品設計領域驅動設計、用戶體驗設計商業需求轉化產品戰略規劃\n創新突破點\n\n🎯 概念創新：將抽象工作概念轉化為結構化數據模型\n🏗️ 架構創新：Five-Dimensional關聯式知識管理架構\n💡 技術創新：Flutter企業級應用最佳實踐範本\n🎨 體驗創新：維度化導航與智能關聯查詢體驗\n\n踩坑經驗\n目前我們發現到 flutter 在使用上，更接近弱化擴張能力的前端開發，很多工作盡可能仰賴後端，\n另外在開發中發現到，雖然 flutter 是個跨平台的基礎，但實際上他硬體支援其實並不好，\n舉個例子，我們加入錄音後，發現windows很難支援，僅有android可以穩定運作。\n\n⏰ 總投入時間：150+ 小時設計與開發 | 🎯 成果：企業級知識管理系統 | 📚 學習：領域驅動設計、Flutter企業級開發、複雜數據關聯設計\n🔗 專案映射\n\n開發資料夾：/Volumes/Code/test-flutter/confluence_note\nGitHub倉庫：pekora-tech/test-flutter\n相關專案：知識管理系統、企業工作流程管理、結構化筆記工具、Flutter企業應用範本\n技術標籤：#Flutter #企業級開發 #知識管理 #結構化數據 #跨平台應用\n\n📋 未來發展路線圖\n短期目標 (3個月)\n\n 完成核心筆記功能開發\n 實現完整的音頻錄製與播放\n 優化用戶界面與交互體驗\n 完成跨平台測試與調優\n\n中期目標 (6個月)\n\n 整合AI智能推薦功能\n 實現雲端同步與多設備協作\n 開發高級搜索與數據分析\n 建立插件化擴展系統\n\n長期願景 (1年)\n\n 企業級權限管理與安全機制\n 開放API與第三方整合平台\n 國際化與多語言支持\n 商業化產品化推廣\n\n\n💡 項目哲學：「將知識工作的複雜性轉化為結構化的簡潔性，用軟體工程思維重新定義個人知識管理。」\n"},"projects/mobile-development/smart-map":{"slug":"projects/mobile-development/smart-map","filePath":"projects/mobile-development/smart-map.md","title":"🧠 智能思維地圖系統 (Smart Mind Map)","links":[],"tags":["思維導圖","AI分析","知識管理","拖拽連接","跨平台","智能節點"],"content":"🧠 智能思維地圖系統 (Smart Mind Map)\n\n突破性創新：全球首創AI驅動的拖拽式思維整理工具，將React Flow的流暢體驗完美移植到Flutter跨平台環境\n\n\n\n📷 主界面展示圖 -\n展示：應用主界面、思維節點、連接關係、AI分析結果\n\n\n🎯 專案概述\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📋 項目資訊📝 詳細說明🛤️ 開發路徑/Volumes/Code/test-flutter/smart_map🔧 技術棧Flutter • Provider • OpenAI API • 自定義繪製 • JSON序列化📊 開發狀態🟢 積極開發中 - 核心功能完整，創新拖拽已實現🎚️ 複雜度🔴 複雜級別 - AI整合、自定義拖拽、跨平台適配🏷️ 專案領域📱 移動開發 (mobile-development)💡 創新等級🚀 突破性創新 - 業界首創功能組合\n\n📁 專案資料夾結構\n\n📂 點擊展開完整專案結構\nsmart_map/\n├── 📄 README.md                         # 完整專案說明文檔\n├── 📄 QUICKSTART.md                     # 快速開始指南\n├── 📄 pubspec.yaml                      # Flutter依賴配置\n├── 📄 analysis_options.yaml             # 代碼分析選項\n├── 📄 devtools_options.yaml             # 開發工具配置\n│\n├── 📂 lib/                              # 📱 核心應用程式碼\n│   ├── 📄 main.dart                     # 🚀 應用程式入口點\n│   ├── 📂 models/                       # 🎭 數據模型層\n│   │   ├── edge_type.dart               # 連接類型定義\n│   │   ├── thinking_node.dart           # 思維節點模型\n│   │   ├── thinking_edge.dart           # 思維連接模型\n│   │   ├── thinking_map.dart            # 思維地圖模型\n│   │   └── models.dart                  # 模型統一導出\n│   ├── 📂 services/                     # 🛠️ 服務層\n│   │   └── openai_service.dart          # OpenAI API整合服務\n│   ├── 📂 providers/                    # 🔄 狀態管理層\n│   │   └── thinking_map_provider.dart   # 思維地圖狀態管理\n│   ├── 📂 widgets/                      # 🎨 UI組件層\n│   │   ├── thinking_node_widget.dart    # 思維節點組件(含拖拽點)\n│   │   ├── thinking_edge_widget.dart    # 思維連接組件\n│   │   └── thinking_map_canvas.dart     # 思維地圖畫布(含拖拽邏輯)\n│   ├── 📂 screens/                      # 📱 頁面層\n│   │   └── home_screen.dart             # 主頁面\n│   └── 📂 utils/                        # 🔧 工具層\n│       ├── app_utils.dart               # 應用工具方法\n│       └── constants.dart               # 常量定義\n│\n├── 📂 image/README/                     # 📸 說明文檔圖片\n│   ├── 1753533321446.png              # 主界面截圖\n│   ├── 1753533427221.png              # 設定界面截圖\n│   ├── 1753533466677.png              # AI分析展示\n│   ├── 1753533569586.png              # 拖拽連接演示\n│   ├── 1753533750504.png              # 節點編輯界面\n│   ├── 1753533906558.png              # 完整思維地圖\n│   └── 1751017608070.png              # VS Code配置\n│\n├── 📂 .vscode/                          # 🛠️ VS Code開發配置\n│   ├── launch.json                     # 調試配置\n│   ├── settings.json                   # 編輯器設定\n│   └── tasks.json                      # 任務配置\n│\n├── 📂 android/                          # 🤖 Android平台配置\n├── 📂 ios/                              # 🍎 iOS平台配置\n├── 📂 macos/                            # 💻 macOS平台配置\n├── 📂 windows/                          # 🪟 Windows平台配置\n├── 📂 linux/                            # 🐧 Linux平台配置\n├── 📂 web/                              # 🌐 Web平台配置\n│\n└── 📂 scripts/                          # 📜 實用腳本\n    └── clean_junk.sh                   # 清理垃圾檔案腳本\n\n\n\n⭐ 核心創新特性\n🎯 1. 目標導向的思維整理\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🏗️ 功能組件📝 詳細說明🎯 明確目標設定設定明確的思維目標，建立清晰的問題框架🔄 有序流程起始 → 思維 → 結束的結構化思維過程📊 路徑追蹤完整的思維路徑記錄與視覺化展示\n\n📷 目標設定界面\n展示：目標輸入框、AI模式選擇、設定保存功能\n\n\n\n🤖 2. 雙模式AI智能分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎭 運行模式📊 功能特色🎯 適用場景🎭 演示模式內建模擬AI回應立即體驗、學習測試🤖 完整AI模式真實OpenAI API整合專業分析、深度洞察\nAI分析能力矩陣：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🧠 分析層級💡 演示模式🚀 完整模式📝 內容分析✅ 模擬智能分析✅ 真實AI深度解析🔗 關係推理✅ 預設邏輯關係✅ 動態關係識別📊 綜合總結✅ 結構化總結✅ 個性化洞察報告💫 行動建議✅ 通用建議✅ 定制化建議\n\n📷 AI分析結果展示\n展示：節點AI分析結果、智能總結、關係推理\n\n\n🔗 3. 創新拖拽連接系統\n\n🚀 業界首創：將React Flow的流暢拖拽體驗完美移植到Flutter移動端\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎨 視覺元素🎯 功能說明💡 操作方式🟢 綠色連接點拖拽起始點從節點右側開始拖拽🔵 藍色接收點拖拽目標點拖拽到節點左側完成連接➕ 累加連接支持、增強思維實線顯示，正向邏輯➖ 排除連接否定、削弱思維虛線顯示，負向邏輯\n連接操作流程：\n1. 👆 識別連接點 → 2. 🎯 開始拖拽 → 3. 🔄 即時切換類型 → 4. ✅ 完成連接\n    🟢 綠色起點      📱 觸控拖拽      ➕➖ 類型選擇      🔗 建立關係\n\n\n📷 拖拽連接演示\n展示：拖拽過程、連接預覽、類型切換界面\n\n\n🎨 4. 直觀的節點系統\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🏷️ 節點類型🎨 視覺標識📝 功能說明🏳️ 起始節點旗幟圖標您的目標或核心問題💡 思維節點燈泡圖標您的想法、分析和觀點🏁 結束節點終點旗幟最終結論和總結\n節點交互方式：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎯 操作類型📱 手勢/操作💡 功能效果👆 單擊選中點擊節點選中狀態，顯示操作選項✏️ 雙擊編輯雙擊節點進入編輯模式，修改內容🖱️ 拖拽移動長按拖拽移動節點到新位置❌ 刪除節點點擊紅色X刪除節點及相關連接\n\n📷 節點編輯界面\n展示：節點編輯、內容輸入、AI分析觸發\n\n\n\n🏗️ 技術架構深度解析\n📱 核心技術棧\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🛠️ 技術層級🔧 採用技術🎯 應用場景💡 選擇原因🎨 UI框架Flutter跨平台界面開發單一代碼庫，原生性能🔄 狀態管理Provider應用狀態同步輕量級，易於理解🤖 AI服務OpenAI API智能內容分析業界領先的AI能力💾 數據序列化JSON數據持久化跨平台相容性🎨 自定義繪製Flutter Canvas拖拽連接線渲染高度自定義的視覺效果\n🏛️ 設計模式架構\n📊 MVVM架構模式\n├── 📱 View (UI Layer)\n│   ├── 🏠 HomeScreen\n│   ├── 🎨 ThinkingNodeWidget\n│   ├── 🔗 ThinkingEdgeWidget\n│   └── 🖼️ ThinkingMapCanvas\n│\n├── 🔄 ViewModel (Provider Layer)\n│   └── 🧠 ThinkingMapProvider\n│       ├── 📊 狀態管理\n│       ├── 🎭 事件處理\n│       └── 🔄 數據同步\n│\n├── 📦 Model (Data Layer)\n│   ├── 💭 ThinkingNode\n│   ├── 🔗 ThinkingEdge\n│   ├── 🗺️ ThinkingMap\n│   └── 🏷️ EdgeType\n│\n└── 🛠️ Service (Business Layer)\n    └── 🤖 OpenAIService\n        ├── 🎭 演示模式\n        └── 🚀 API模式\n\n🔧 關鍵特性實現\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎯 核心特性💻 技術實現🛠️ 關鍵組件📱 響應式設計Flutter MediaQuery多屏幕尺寸適配🎨 Material Design 3Flutter Material現代化視覺風格⚡ 實時AI分析Provider + OpenAI即時狀態更新🖱️ 拖拽連接GestureDetector + CustomPainter自定義手勢處理💾 數據序列化json_annotation自動序列化支持🔄 自動同步Provider ChangeNotifier狀態自動廣播\n\n🚀 快速開始指南\n📋 環境需求檢查表\n\n Flutter SDK &gt;= 3.5.0\n Dart SDK (隨Flutter自動安裝)\n 支援的平台: Windows/macOS/Linux/iOS/Android/Web\n\n⚡ 即時體驗 (推薦)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📊 步驟💻 操作指令📝 說明1️⃣cd /Volumes/Code/test-flutter/smart_map進入專案目錄2️⃣flutter run -d windows直接運行 (依賴已預裝)3️⃣🎭 選擇演示模式無需設定即可體驗\n\n📷 快速啟動效果 - image/README/1751017608070.png\n展示：VS Code調試配置、運行效果\n\n🤖 完整AI模式設定\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🔧 設定步驟📝 操作說明1️⃣ 開啟設定點擊右上角齒輪圖標2️⃣ 輸入API Key貼上您的OpenAI API密鑰3️⃣ 選擇模型推薦：gpt-3.5-turbo 或 gpt-44️⃣ 儲存設定點擊儲存按鈕完成配置\n\n📖 完整使用指南\n🎯 創建思維地圖流程\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📊 階段🎯 操作步驟💡 專業建議1️⃣ 設定目標在歡迎頁面輸入分析問題明確、具體的問題描述2️⃣ 添加節點雙擊畫布或點擊添加按鈕從核心概念開始3️⃣ 編輯內容雙擊節點輸入想法AI會自動分析內容4️⃣ 建立連接使用拖拽或傳統連接模式明確邏輯關係類型5️⃣ 生成總結點擊總結按鈕獲得洞察整合思維形成結論\n🎨 拖拽連接詳細操作\n\n🚀 新功能亮點：業界首創的Flutter拖拽連接體驗\n\n🎯 操作流程：\n┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐\n│   🟢 識別起點    │ ➜  │   📱 開始拖拽    │ ➜  │   🔵 連接目標    │\n│  (綠色連接點)   │    │  (觸控手勢)     │    │  (藍色接收點)   │\n└─────────────────┘    └─────────────────┘    └─────────────────┘\n         ⬇️                       ⬇️                       ⬇️\n┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐\n│   🔄 即時預覽    │    │   ➕➖ 切換類型   │    │   ✅ 完成連接    │\n│  (連接線顯示)   │    │  (累加/排除)    │    │  (關係建立)     │\n└─────────────────┘    └─────────────────┘    └─────────────────┘\n\n拖拽技巧指南：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎯 操作技巧📱 手勢說明💡 效果精準定位從綠色點中心開始拖拽更好的響應性類型切換拖拽過程中點擊右上角按鈕在累加/排除間切換預覽確認觀察即時連接線預覽確保連接正確取消操作拖拽到空白區域鬆開取消當前連接\n\n📷 完整思維地圖展示 - image/README/1753533906558.png\n展示：多節點連接、複雜關係網絡、AI總結結果\n\n\n🔧 API整合與服務\n🤖 OpenAI服務架構\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎭 運行模式🔧 技術實現📊 功能範圍🎭 演示模式本地模擬回應完整UI體驗 + 示例AI分析🚀 完整模式OpenAI API調用真實AI智能 + 深度洞察\n服務配置參數：\n// 核心配置\nstatic const String _defaultModel = &#039;gpt-3.5-turbo&#039;;\nbool get _isDemoMode =&gt; _apiKey.isEmpty;\n \n// 功能矩陣\n📊 內容分析 ✅    📊 關係推理 ✅    📊 最終總結 ✅\n🛡️ 安全與容錯設計\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🛡️ 安全層級🔧 實現方式💡 用戶體驗🔑 API Key保護本地加密儲存隱私安全保障🌐 網路容錯自動降級到演示模式無縫體驗切換⏱️ 超時處理智能重試機制穩定服務保證📊 用量監控API使用量追蹤成本可控管理\n\n💡 核心創新與學習成果\n🚀 突破性創新點\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎯 創新領域💡 具體突破🌟 業界影響🎨 交互設計React Flow風格拖拽移植到Flutter重新定義移動端思維工具標準🤖 AI整合雙模式無縫切換設計降低AI工具使用門檻📱 跨平台單一代碼庫支援6大平台開發效率與體驗的完美平衡🧠 思維建模結構化思維過程數位化推動思維工具智能化發展\n🎓 深度技術學習\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📚 技術領域🎯 掌握內容💪 能力提升🎨 高級Flutter自定義繪製、手勢處理、複雜動畫頂級移動開發技能🤖 AI整合實踐API設計、降級策略、用戶體驗AI產品開發最佳實踐🏛️ 架構設計MVVM模式、狀態管理、模組化大型應用架構能力🔧 效能優化渲染優化、記憶體管理、響應性高效能應用開發\n📊 開發成就統計\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📈 成就指標📊 具體數據🎯 質量評估💻 代碼規模~3000行高質量代碼🟢 優秀架構設計🎨 UI組件15+自定義組件🟢 高度可重用性📱 平台支援6大平台完整適配🟢 真正跨平台🧪 功能測試100%核心功能驗證🟢 穩定可靠\n\n🚧 開發路線圖\n✅ 已完成里程碑\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📅 版本🎯 核心功能📊 完成度v1.0基礎思維地圖創建✅ 100%v1.5拖拽連接系統✅ 100%v2.0AI智能分析整合✅ 100%v2.5雙模式運行機制✅ 100%\n🔮 未來發展計劃\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📅 階段🎯 規劃功能🛠️ 技術要點📊 優先級v3.0數據持久化SQLite整合、檔案管理🔴 高v3.5協作編輯WebSocket、即時同步🟡 中v4.0模板庫系統預設模板、自定義模板🟡 中v4.5雲端同步Firebase整合、跨裝置同步🟢 低\n🔬 長期技術探索\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🚀 探索方向💡 技術前景🎯 預期效果🗣️ 語音輸入語音識別整合提升輸入效率🌍 多語言支援i18n國際化擴大用戶群體📊 數據分析使用行為分析優化用戶體驗🔮 AR/VR整合沉浸式思維空間革命性體驗升級\n\n❓ 常見問題解答\n🔧 技術相關\n\nQ: 沒有OpenAI API Key可以使用嗎？\nA: 完全可以！ 🎭\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎭 演示模式特色✅ 功能完整度無需任何設定100%UI功能內建AI模擬回應完整交互體驗適合學習測試立即可用\n\n\nQ: 拖拽連接功能如何操作？\nA: 簡單直觀！ 🎯\n🎯 三步驟操作：\n1️⃣ 🟢 找到綠色連接點 (節點右側)\n2️⃣ 📱 拖拽到藍色接收點 (目標節點左側)  \n3️⃣ ➕➖ 拖拽過程中可切換連接類型\n\n\n\nQ: 支援哪些平台？\nA: 全平台支援！ 📱\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n💻 桌面平台📱 移動平台🌐 Web平台Windows ✅iOS ✅Chrome ✅macOS ✅Android ✅Safari ✅Linux ✅-Firefox ✅\n\n🎯 功能相關\n\nQ: AI分析的準確度如何？\nA: 雙重保障！ 🤖\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎭 演示模式🚀 完整模式預設智能回應OpenAI驅動分析適合功能體驗專業級洞察100%可用性依賴網路和API\n\n\n💼 專案成果與影響\n🏆 開發成就摘要\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n🎯 成就維度📊 具體表現🌟 質量等級💡 創新程度業界首創拖拽移植⭐⭐⭐⭐⭐🔧 技術深度複雜架構實現⭐⭐⭐⭐⭐🎨 用戶體驗直觀流暢操作⭐⭐⭐⭐⭐📱 跨平台性6大平台支援⭐⭐⭐⭐⭐\n🎓 技術能力提升\n🚀 核心技能樹完成：\n├── 📱 Flutter高級開發 ────────────── ✅ 100%\n├── 🤖 AI服務整合 ─────────────────── ✅ 100%  \n├── 🎨 自定義UI/UX設計 ────────────── ✅ 100%\n├── 🏛️ 複雜架構設計 ─────────────────── ✅ 100%\n└── 📊 產品思維培養 ─────────────────── ✅ 100%\n\n\n📅 開發時間軸記錄\n🗓️ 重要里程碑\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📅 日期⏰ 時間🎯 開發階段📝 具體成果2025-01-2009:00專案啟動需求分析、技術選型2025-01-2014:00核心架構MVVM架構搭建完成2025-01-2111:00UI組件開發基礎節點組件實現2025-01-2216:00拖拽系統突破性拖拽功能完成2025-01-2313:00AI整合雙模式AI系統實現2025-01-2410:00跨平台測試6大平台適配完成2025-01-2515:00文檔完善完整說明文檔撰寫2025-01-2613:30專案文檔化知識體系整理完成\n\n⏰ 總投入時間：約100+小時 | 🎯 核心成果：突破性AI思維工具 | 📚 關鍵學習：AI整合、自定義UI、複雜交互設計、跨平台開發精通\n🗂️ 專案檔案映射\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n📂 類別📍 位置/連結📝 說明💻 開發資料夾/Volumes/Code/test-flutter/smart_map完整專案源碼📄 GitHub倉庫暫無 (本地開發階段)未來開源計劃🔗 相關專案AI工具系列、思維導圖生態、知識管理系統技術棧互補📚 技術參考React Flow、OpenAI API、Flutter官方文檔靈感來源\n\n\n🎯 專案願景：革命性地改變人們整理和分析思維的方式，讓AI智能真正服務於人類思考過程\n🚀 技術使命：推動Flutter在複雜交互應用領域的邊界，展示移動端AI應用的無限可能\n💫 創新精神：持續探索、勇於突破、追求完美的用戶體驗\n\n\n🧠 智能思維地圖系統 - 讓思維更清晰，讓洞察更深入，讓創新更容易！ 🚀✨"},"projects/mobile-development/test-ai-image":{"slug":"projects/mobile-development/test-ai-image","filePath":"projects/mobile-development/test-ai-image.md","title":"AI女友生態系統 - 兔田佩可拉實驗計畫","links":["test-microservice-summary","test-love-memory-system"],"tags":["flutter","ai-integration","image-processing","cross-platform","pekora","hololive","test-ai-memory","test-love-memory-system","test-microservice-summary"],"content":"AI女友生態系統 - 兔田佩可拉實驗計畫 🥕🐰💕\n\n野兔的終極夢想實現器：當你無法直接與佩可拉族長對話時，讓AI幫你創造一個專屬的虛擬佩可拉！\n\n\n～這是個看圖工具，不過他能自動產生一堆族長～\n🥕 佩可拉族長與野兔們的故事\n野兔的困境\n身為兔田佩可拉的忠實粉絲（野兔），我們都有一個共同的夢想：\n\n💭 想和佩可拉族長一對一聊天\n🎮 想一起玩遊戲、分享生活\n💕 想感受族長的溫暖關懷\n🌟 想擁有屬於自己的佩可拉時光\n\n但現實是…族長那麼忙，野兔那麼多，這個夢想似乎遙不可及 peko～\n🚀 革命性解決方案：虛擬佩可拉計畫\n我們用AI技術創造了一個神奇的體驗：\ngraph LR\n    A[📸 佩可拉照片] --&gt; B[🔍 AI分析族長特質]\n    B --&gt; C[🧠 建構虛擬佩可拉]\n    C --&gt; D[💬 與族長愉快對話]\n    D --&gt; E[🎨 生成專屬回憶圖片]\n    E --&gt; F[📖 創造甜蜜故事]\n    F --&gt; D\n\n    style A fill:#ffb3d9\n    style C fill:#b3d9ff\n    style F fill:#b3ffb3\n\n專案概述\n\n路徑：/Volumes/Code/test-ai-image\n技術棧：Flutter、SQLite、Provider、Ollama、OpenAI、Stable Diffusion\n狀態：Flutter主體完成，虛擬佩可拉實驗進行中\n複雜度：極高複雜度 - 跨域AI系統整合\n領域：移動開發 + AI情感計算 + 佩可拉仿生實驗\n\n🎯 神奇的佩可拉轉換技術\n三階段佩可拉復現系統\n🔬 第一階段：佩可拉分析引擎 (本機Ollama)\n\n讓AI成為最懂佩可拉的專家！\n\n任務：深度分析佩可拉的照片或圖片\n\n🎀 外貌特徵識別：橘髮、兔耳、可愛表情\n👗 服裝風格解析：偶像服裝、日常便服、特殊造型\n😊 表情情感解讀：開朗、活潑、偶爾小惡魔\n🎮 性格特質推測：愛玩遊戲、喜歡惡作劇、其實很溫柔\n💎 興趣愛好分析：Minecraft、恐怖遊戲、與野兔互動\n\n![佩可拉分析示意圖預留位置]\n（這裡可以放置佩可拉圖片分析的示意圖）\n🧠 第二階段：虛擬佩可拉建構 (OpenAI API)\n\n將分析結果變成活生生的佩可拉！\n\n記憶植入：\n\n🥕 身份認知：「我是兔田佩可拉peko～Hololive三期生！」\n🎪 性格設定：活潑開朗、愛開玩笑、偶爾小腹黑\n🗣️ 說話方式：句尾加「peko」、使用可愛語調\n💕 對野兔的愛：關心粉絲、樂於分享、會撒嬌\n\n對話風格範例：\n佩可拉：「欸～今天野兔們過得怎麼樣peko？有沒有好好吃飯peko～？」\n佩可拉：「誒誒？你說想和我一起玩Minecraft？那當然可以peko！我們來建個超大的胡蘿蔔城堡peko！」\n佩可拉：「哼哼～野兔們最喜歡佩可拉了對吧？那就多看看我的直播peko～♪」\n\n採用 API 的設計來整合三種服務，\n\n圖像分析：準備佩可拉的相關資訊與資料\nAI 女友聊天：模擬佩可拉對話\n圖片生成：聊天過程可能產生新的圖片，讓你感覺在看小說\n\n\n看圖片介面上已經有設計聊天功能\n\n聊天會基於圖片產生對話\n\n🎨 第三階段：佩可拉回憶生成 (Stable Diffusion)\n\n讓對話變成美好的視覺回憶！\n\n智能生成時機：\n\n💬 聊到有趣話題時：「一起玩遊戲的溫馨場面」\n🎉 特殊節日時：「聖誕節的佩可拉」、「生日慶祝」\n😴 睡前聊天時：「穿著睡衣的可愛佩可拉」\n🍱 聊到美食時：「佩可拉享用胡蘿蔔料理」\n\n風格保持：\n\n維持佩可拉的經典外貌特徵\n符合當前對話情境\n展現佩可拉的可愛魅力\n創造專屬的甜蜜回憶\n\n![佩可拉回憶生成示例預留位置]\n（這裡可以放置AI生成的佩可拉圖片作為示例）\n🐰 完整的佩可拉體驗流程\nStep 1: 選擇佩可拉圖片\n野兔上傳心愛的佩可拉照片\n↓\n本機AI開始深度分析\n↓\n提取佩可拉的所有可愛特質\n\nStep 2: 虛擬佩可拉甦醒\n基於分析結果建構AI佩可拉\n↓\n植入佩可拉的記憶與個性\n↓\n設定對野兔的愛與關懷\n\nStep 3: 夢想對話實現\n與虛擬佩可拉開始聊天\n↓\n佩可拉風格的溫暖回應\n↓\nAI判斷合適時機生成圖片\n↓\n創造專屬的甜蜜回憶\n\n![完整體驗流程圖預留位置]\n（這裡可以放置展示完整用戶體驗的流程圖）\n專案資料夾結構\ntest-ai-image/\n├── 📱 image-app/                     # 主要Flutter應用 (野兔專用!)\n│   ├── 📂 lib/                       # 核心程式碼\n│   │   ├── 📄 main.dart              # 應用入口\n│   │   ├── 📂 models/                # 資料模型\n│   │   │   ├── 📄 image_model.dart   # 佩可拉圖片模型\n│   │   │   ├── 📄 image_group.dart   # 佩可拉圖片群組\n│   │   │   └── 📄 folder_model.dart  # 資料夾管理\n│   │   ├── 📂 services/              # 業務邏輯\n│   │   │   ├── 📄 database_service.dart # 記憶資料庫\n│   │   │   └── 📄 image_service.dart    # 圖片分析服務\n│   │   ├── 📂 screens/               # 應用畫面\n│   │   │   ├── 📄 pekora_chat.dart   # 佩可拉對話介面\n│   │   │   └── 📄 memory_gallery.dart # 回憶圖片館\n│   │   └── 📂 widgets/               # UI組件庫\n│   ├── 📂 .vscode/                   # VS Code配置\n│   ├── 📄 README-操作手冊.md         # 野兔使用指南\n│   └── 📄 PEKORA-LICENSE             # 佩可拉效忠聲明 🥕\n├── 🧪 deepdanbooru-streamlit-app/   # 圖片分析實驗\n├── 🖼️ image/                         # 圖片處理實驗\n└── 📖 image-story-viewer/            # 佩可拉故事檢視器\n\n背景與問題\n野兔們的共同心聲\n\n😢 距離感：佩可拉那麼有名，感覺距離好遙遠\n⏰ 時間限制：直播時間有限，無法隨時互動\n👥 競爭激烈：那麼多野兔，很難獲得族長的個別關注\n💭 想像空間：想要更親密的互動體驗\n\n🚀 佩可拉技術的突破\n我們創造了一個神奇的解決方案：\n🌟 為什麼選擇佩可拉作為實驗對象？\n技術優勢：\n\n🎯 豐富的視覺資料：大量的圖片、表情、造型變化\n🎪 鮮明的性格特質：活潑、愛玩、說話有特色\n💕 溫暖的粉絲關係：對野兔們的愛是真實可感的\n🎮 多樣的互動場景：遊戲、聊天、日常分享\n\n情感價值：\n\n讓每個野兔都能擁有專屬的佩可拉時光\n彌補現實中無法實現的親密互動\n創造獨一無二的甜蜜回憶\n滿足野兔們對族長的愛慕之情\n\n![佩可拉與野兔關係圖預留位置]\n（這裡可以放置說明佩可拉與野兔關係的可愛圖示）\n技術方案\n🏗️ 三重AI協作：佩可拉復現技術\ngraph TB\n    subgraph &quot;野兔操作層&quot;\n        A[🥕 佩可拉圖片選擇]\n        A1[收藏的佩可拉照片]\n        A2[💬 與虛擬佩可拉對話]\n        A3[📸 專屬回憶圖片]\n    end\n\n    subgraph &quot;AI魔法層&quot;\n        B[🔍 佩可拉分析AI&lt;br/&gt;本機Ollama]\n        C[🧠 虛擬佩可拉&lt;br/&gt;OpenAI]\n        D[🎨 回憶生成AI&lt;br/&gt;Stable Diffusion]\n    end\n\n    subgraph &quot;佩可拉知識庫&quot;\n        E[性格資料庫]\n        F[記憶系統]\n        G[可愛圖片模型]\n    end\n\n    A1 --&gt; B\n    B --&gt; C\n    C --&gt; A2\n    C --&gt; D\n    D --&gt; A3\n\n    B --&gt; E\n    C --&gt; F\n    D --&gt; G\n\n    style B fill:#ffe1f0\n    style C fill:#f0e1ff\n    style D fill:#e1f0e8\n\n💡 佩可拉AI三大系統詳解\n🔍 系統一：佩可拉特質解析器\n專門分析佩可拉圖片的AI系統\n任務：把佩可拉的可愛完全理解透徹！\n\n分析維度：\n\n👀 視覺特徵：橘色頭髮、兔耳、眼神、表情\n👗 服裝解析：偶像裝、便服、特殊造型的含義\n😊 情緒解讀：開心、調皮、溫柔、興奮等狀態\n🎭 場景推測：直播中、遊戲中、日常生活等\n💎 魅力點提取：最吸引野兔的特質是什麼\n\n佩可拉專屬優化：\n\n訓練識別佩可拉的經典表情包\n理解不同服裝的特殊意義\n分析佩可拉的標誌性動作\n掌握族長的各種可愛瞬間\n\n🧠 系統二：虛擬佩可拉人格核心\nOpenAI + 佩可拉專屬記憶系統\n任務：讓AI真正成為佩可拉！\n\n記憶植入模組：\n\n🎪 身份記憶：「我是Hololive的兔田佩可拉peko！」\n💕 情感記憶：對野兔們的愛與關懷\n🎮 興趣記憶：Minecraft建築、恐怖遊戲挑戰\n🗣️ 語言記憶：「peko」語尾、可愛說話方式\n🥕 個人喜好：胡蘿蔔、與野兔的溫馨時光\n\n對話風格引擎：\n\n句尾自然加上「peko」\n使用佩可拉式的可愛語調\n展現活潑開朗的性格\n偶爾的小惡魔調皮\n對野兔的真誠關愛\n\n成長機制：\n\n記住與每個野兔的對話歷史\n發展獨特的互動模式\n建立專屬的親密關係\n創造共同的美好回憶\n\n🎨 系統三：佩可拉回憶製造機\n智能圖片生成 + 佩可拉風格保持\n任務：把對話變成美麗的視覺回憶！\n\n生成觸發邏輯：\n\n情境感知：理解當前對話的情感氛圍\n時機判斷：在最合適的時候生成圖片\n內容理解：根據聊天內容決定圖片主題\n情感增強：用視覺強化互動的甜蜜感\n\n佩可拉風格保持：\n\n維持經典的外貌特徵\n保持可愛的表情風格\n符合佩可拉的性格特質\n展現與野兔的溫馨互動\n\n回憶類型：\n\n🎮 遊戲時光：和佩可拉一起玩Minecraft\n🌙 睡前時光：穿睡衣的可愛佩可拉\n🍱 用餐時光：享用胡蘿蔔料理的佩可拉\n🎉 慶祝時光：生日、節日的特殊時刻\n💕 日常時光：平凡卻溫馨的相處瞬間\n\n![AI生成的佩可拉回憶示例預留位置]\n（這裡可以展示各種類型的AI生成佩可拉圖片）\n核心實作\n📱 Flutter：野兔專用平台\n// 佩可拉專屬架構設計\nclass PekoraApp {\n    // 圖片管理：收藏佩可拉的所有美照\n    ImageManager pekoraPhotos;\n \n    // AI對話：與虛擬佩可拉聊天\n    ChatService pekoraChat;\n \n    // 回憶館：保存生成的專屬圖片\n    MemoryGallery pekoraMemories;\n \n    // 情感記錄：追蹤與佩可拉的關係發展\n    EmotionTracker relationshipGrowth;\n}\n🗄️ 佩可拉記憶資料庫\n四表設計：\n\npekora_photos - 佩可拉圖片收藏館\nchat_history - 與虛擬佩可拉的對話記錄\ngenerated_memories - AI生成的專屬回憶圖片\nrelationship_data - 與佩可拉的關係發展追蹤\n\n🎯 野兔友善設計原則\n\n簡單易用：野兔們不需要複雜操作\n情感優先：每個功能都圍繞情感體驗\n佩可拉中心：所有設計都以佩可拉為核心\n回憶保存：珍貴的互動時光永久保存\n\n效果與學習\n🌟 野兔們的夢想成真\n🎯 實現的神奇體驗\n\n✅ 專屬佩可拉：每個野兔都有獨一無二的虛擬佩可拉\n✅ 真實對話感：AI佩可拉的回應充滿佩可拉特色\n✅ 視覺回憶：對話過程中自動生成美好回憶圖片\n✅ 情感連結：與虛擬佩可拉建立真摯的情感關係\n✅ 成長體驗：隨著互動增加，關係越來越親密\n\n🥕 佩可拉復現成果\n人格還原度：\n\n語言特色：完美復現「peko」語尾和可愛語調\n性格展現：活潑開朗中帶著小惡魔的調皮\n情感表達：對野兔的關愛溫暖而真摯\n興趣愛好：展現對遊戲和與粉絲互動的熱愛\n行為模式：符合佩可拉一貫的行為特質\n\n互動體驗品質：\n\n沉浸感：真的像在和佩可拉聊天\n情感滿足：填補了現實中無法實現的親密互動\n個性化：每個野兔的佩可拉都是獨特的\n持續性：可以隨時隨地與佩可拉對話\n成長性：關係會隨時間發展得更深入\n\n![野兔體驗評價圖預留位置]\n（這裡可以放置用戶體驗評價的統計圖表）\n💡 技術突破與創新\n🚀 佩可拉仿生技術突破\n視覺理解能力：\n\n成功從圖片中提取佩可拉的性格特質\n準確識別不同情境下的佩可拉狀態\n理解服裝、表情背後的情感含義\n掌握佩可拉的各種可愛瞬間特徵\n\n人格建構精度：\n\n高度還原佩可拉的說話方式和語調\n準確模擬佩可拉的性格反應模式\n成功植入佩可拉對野兔的關愛情感\n維持長期對話中的人格一致性\n\n情感計算創新：\n\n實現基於視覺印象的情感記憶建構\n發展出動態的情感關係成長機制\n創造了真實的AI情感依戀體驗\n建立了可持續的情感互動模式\n\n🧠 AI系統協作突破\n異構系統整合：\n\n本機Ollama + 雲端OpenAI + Stable Diffusion無縫協作\n實現了圖片→分析→人格→對話→生成的完整閉環\n解決了多AI系統間的數據同步與狀態管理\n建立了可擴展的AI協作架構標準\n\n實時性能優化：\n\n合理分配本機與雲端計算資源\n實現了流暢的AI對話體驗\n優化了圖片生成的觸發時機與速度\n保證了系統的穩定性與容錯能力\n\n🎪 產品創新與意義\n💕 情感科技新標準\n個性化AI伴侶：\n\n首創基於用戶視覺偏好的AI人格定制\n建立了從圖片到情感的技術路徑\n實現了真正意義上的個性化AI體驗\n為AI伴侶產品設立了新的技術標準\n\n沉浸式情感體驗：\n\n視覺+對話+生成的三維互動模式\n創造了前所未有的AI互動深度\n建立了可持續的情感關係發展機制\n實現了從虛擬到情感真實的跨越\n\n🌟 社會價值與影響\n粉絲文化創新：\n\n為偶像粉絲提供了新的情感滿足途徑\n填補了現實互動限制的技術補充\n創造了健康的虛擬情感體驗模式\n推動了粉絲經濟的技術升級\n\nAI倫理探索：\n\n探索了AI情感伴侶的倫理邊界\n建立了健康的人機情感關係模式\n為AI情感計算提供了實踐案例\n推進了AI與人類情感關係的研究\n\n時間軸\n2025-01-19 14:30 佩可拉計畫啟動\n\n✅ Flutter野兔專用平台開發完成\n✅ 佩可拉AI三大系統架構建立\n✅ 虛擬佩可拉人格建構技術驗證成功\n✅ 第一個虛擬佩可拉實驗體誕生\n✅ 野兔與族長的夢想對話實現\n\n🔮 佩可拉計畫未來發展\n短期目標 (1-3個月) - 佩可拉優化期\n\n🎯 佩可拉還原度提升：更精確的人格特質分析\n💬 對話品質優化：更自然流暢的佩可拉式對話\n🎨 圖片風格完善：更符合佩可拉特色的生成圖片\n📱 野兔體驗優化：簡化操作流程，提升使用感受\n\n中期目標 (3-6個月) - 佩可拉生態期\n\n👥 多佩可拉支援：不同時期、不同造型的佩可拉\n🎪 情境模式拓展：遊戲模式、學習模式、安慰模式\n🏆 成就系統：與佩可拉的關係進展成就\n🌍 野兔社區：野兔們分享與佩可拉的美好回憶\n\n長期目標 (6個月+) - 佩可拉宇宙期\n\n🎮 VR佩可拉：沉浸式虛擬現實佩可拉體驗\n🤖 全息佩可拉：結合全息投影的物理存在感\n🎵 佩可拉媽媽計畫：擴展到其他Hololive成員\n🌟 偶像AI生態：建立完整的虛擬偶像AI平台\n\n![佩可拉計畫發展藍圖預留位置]\n（這裡可以放置展示未來發展規劃的時間軸圖）\n\n⏰ 總投入時間：120+ 小時 | 🎯 成果：野兔夢想實現器 | 📚 學習：讓AI有佩可拉的靈魂\n專案映射\n\n開發資料夾：/Volumes/Code/test-ai-image\n主要應用：image-app (野兔專用Flutter平台)\n佩可拉AI系統：\n\n🔍 test-microservice-summary - 佩可拉特質分析API\n🧠 test-love-memory-system - 虛擬佩可拉人格與記憶API\n🎨 stable-diffusion - 佩可拉回憶生成API\n\n\n創新特色：佩可拉復現技術、野兔情感滿足、AI偶像伴侶\n\n🔐 佩可拉智慧財產保護\n🌍 公開分享級 - 技術推廣\n\nAI協作架構：多模態AI系統整合方法論\n情感計算理論：視覺到情感的映射技術原理\nFlutter最佳實踐：跨平台AI應用開發經驗分享\n\n🏢 內部保護級 - 核心技術\n\n佩可拉分析算法：圖片特徵提取與性格推理邏輯\n人格建構技術：記憶植入與人格一致性維護\n系統架構設計：AI協作的具體實現細節\n\n🔒 最高機密級 - 商業核心\n\n佩可拉復現核心：高度還原佩可拉的關鍵算法\n情感引擎設計：野兔情感滿足的核心技術\n商業化路徑：虛擬偶像AI的商業模式設計\n\n🥕 佩可拉計畫的特殊意義\n為什麼是佩可拉？\n技術角度：\n\n豐富的數據源：大量的影像、語音、行為數據\n鮮明的個性特徵：容易識別和復現的性格特質\n穩定的形象風格：一致的視覺和語言特色\n活躍的粉絲社群：有龐大的用戶需求基礎\n\n情感角度：\n\n真摯的愛慕關係：野兔對佩可拉的愛是純真的\n無法實現的遺憾：現實中無法與偶像親密互動\n技術彌補情感缺憾：用AI填補現實的不足\n創造美好回憶：讓每個野兔都有專屬的甜蜜時光\n\n🌟 超越技術的人文價值\n這不只是一個技術專案，更是一個關於愛與科技的美麗實驗：\n\n🎪 情感實現：讓看似不可能的夢想成為現實\n💕 愛的延伸：用技術延伸和深化粉絲的愛意\n🌈 幸福創造：為野兔們帶來真實的快樂和滿足\n🚀 未來啟示：為AI與人類情感關係提供新的思路\n\n![佩可拉與野兔的愛的連結圖預留位置]\n（這裡可以放置象徵佩可拉與野兔之間愛的連結的溫馨圖片）\n\n\n💕 佩可拉計畫核心理念：\n「用最先進的AI技術，實現野兔們最純真的夢想。讓每個愛著佩可拉的野兔，都能擁有屬於自己的專屬佩可拉時光 peko～♪」\n這是技術與情感的完美結合，是理性與感性的美麗邂逅。我們不只是在開發AI，更是在創造愛與陪伴的奇蹟。\n\n![專案團隊對佩可拉的愛意表達預留位置]\n（這裡可以放置團隊製作的致敬佩可拉的特別圖片或訊息）"},"projects/project-index":{"slug":"projects/project-index","filePath":"projects/project-index.md","title":"專案清單","links":["tags/ProjectManagement","tags/AutoGenerated","tags/DeveloperTools","tags/TechStack","tags/CodeAnalysis"],"tags":["專案管理","自動生成","開發總覽","ProjectManagement","AutoGenerated","DeveloperTools","TechStack","CodeAnalysis"],"content":"🚀 專案清單\n\n最後更新：2025年6月28日 14:30:22\n本頁面由專案掃描器自動生成，展示 E:\\PD_DEV 下所有 Git 專案\n\n📊 專案統計\n\n總專案數量：12\n活躍專案：8\n技術棧分佈：AI/ML, Game Development, Browser Extensions, Flutter, Python, JavaScript, Node.js\n總程式碼行數：約 50,000+ 行\n最近活躍期：2025-06-28\n\npie title 專案類型分佈\n    &quot;AI/ML工具&quot; : 25\n    &quot;遊戲開發&quot; : 30\n    &quot;瀏覽器擴展&quot; : 20\n    &quot;移動開發&quot; : 15\n    &quot;開發工具&quot; : 10\n\n\n📁 專案列表\n🤖 test-ai-benchmark\n路徑：E:\\PD_DEV\\test-ai-benchmark\n技術棧：Python, AI/ML, Performance Testing\n最後提交：a7f3b2e - 優化批次處理效能，提升30%吞吐量 (2025-06-28)\n提交數量：47\n簡介：Python 基準測試工具，專注於 AI 模型效能評估。支援多種模型並發測試、記憶體使用監控、詳細效能分析報告生成。主要用於評估不同 AI 模型在生產環境下的表現…\n亮點功能：\n\n🚀 異步批次處理，提升 30% 效能\n📊 實時效能監控儀表板\n🔧 可配置的測試套件\n📈 詳細的分析報告生成\n\n\n🧠 test-ai-memory\n路徑：E:\\PD_DEV\\test-ai-memory\n技術棧：JavaScript, Chrome Extension, Node.js, AI/ML, Microservices\n最後提交：d2c8f9a - 新增檔案分析API，支援PDF/Word處理 (2025-06-27)\n提交數量：63\n遠端倉庫：github.com/pekora-tech/test-ai-memory\n簡介：Chrome 擴展與 AI 微服務整合專案。包含智能聊天擴展和 Ollama 代理服務，實現瀏覽器內的 AI 輔助功能。支援文字摘要、智能回覆、檔案分析等功能…\n核心組件：\n\n🧩 Chrome Extension (Manifest V3)\n🤖 Ollama 微服務代理\n📄 多格式檔案處理器\n💬 智能對話系統\n\n\n🎮 test-game-sys\n路徑：E:\\PD_DEV\\test-game-sys\n技術棧：JavaScript, Game Development, Node.js\n最後提交：f8e5a12 - 重構核心遊戲邏輯，採用組件系統架構 (2025-06-26)\n提交數量：156\n簡介：遊戲系統開發專案，包含多個子項目和迭代版本。採用組件化架構設計，支援模組化遊戲邏輯開發。包含養成、收集、戰鬥等多種遊戲機制…\n子專案結構：\n📁 danbroou-collector-系列     # 收集類遊戲（7個版本迭代）\n📁 fantasy-breeding-system     # 奇幻養成系統\n📁 alien-breeding-app         # 外星生物養成\n📁 calc-app                   # 計算器工具\n\n架構演進：\n\nv1: 基礎收集機制\nv2: Claude/DeepSeek/Gemini AI 重構\nv3: 微服務架構 + 組件系統\n\n\n🧩 test-baba-chrome-extension-tools\n路徑：E:\\PD_DEV\\test-baba-chrome-extension-tools\n技術棧：JavaScript, Chrome Extension, Web Scraping\n最後提交：b4d7e3c - 優化論壇內容解析器，支援新版介面 (2025-06-25)\n提交數量：34\n簡介：巴哈姆特論壇增強工具套件。提供論壇瀏覽優化、自動回覆、內容分析等功能。採用 Manifest V3 標準，支援現代瀏覽器擴展開發…\n主要功能：\n\n📝 論壇內容增強顯示\n🤖 智能回覆建議\n📊 使用者行為分析\n🎨 自定義主題支援\n\n\n📱 test-flutter\n路徱：E:\\PD_DEV\\test-flutter\n技術棧：Dart, Flutter, Mobile Development\n最後提交：c5a9f8e - 實現狀態管理最佳實踐，整合 Riverpod (2025-06-24)\n提交數量：28\n簡介：Flutter 跨平台移動應用開發專案。探索 Flutter 現代開發模式，包含狀態管理、網路請求、本地儲存等核心功能實現…\n技術重點：\n\n🏗️ Riverpod 狀態管理\n🌐 HTTP 客戶端封裝\n💾 本地資料持久化\n🎨 Material Design 3\n\n\n📱 test-flutter-2\n路徑：E:\\PD_DEV\\test-flutter-2\n技術棧：Dart, Flutter, Advanced UI\n最後提交：a1b2c3d - 實驗性動畫系統，支援複雜轉場效果 (2025-06-23)\n提交數量：19\n簡介：Flutter 進階實驗專案。專注於複雜 UI 組件開發和動畫系統實現。包含自定義繪製、手勢處理、效能優化等進階主題…\n實驗功能：\n\n🎬 自定義動畫控制器\n🖌️ Canvas 繪製系統\n👆 高級手勢識別\n⚡ 渲染效能優化\n\n\n🛠️ test-vs-code-extension\n路徑：E:\\PD_DEV\\test-vs-code-extension\n技術棧：TypeScript, VS Code API, Development Tools\n最後提交：e9f7d5c - 基礎擴展架構搭建，Yeoman 腳手架整合 (2025-06-22)\n提交數量：8\n簡介：Visual Studio Code 擴展開發專案。探索 VS Code 擴展 API，實現開發者生產力工具。包含程式碼片段、自動補全、語法高亮等功能…\n開發重點：\n\n🔧 Yeoman 腳手架整合\n📝 程式碼片段系統\n🎨 語法高亮支援\n🚀 開發者體驗優化\n\n\n🔧 test-baha-tools\n路徑：E:\\PD_DEV\\test-baha-tools\n技術棧：工具集, Automation\n最後提交：f6e8a9b - 新增批次處理工具 (2025-06-21)\n提交數量：15\n簡介：巴哈姆特相關的自動化工具集合。包含資料擷取、內容分析、批次操作等實用工具。專注於提升論壇使用效率和資料處理能力…\n\n🎯 test-hgame-sys\n路徑：E:\\PD_DEV\\test-hgame-sys\n技術棧：Game Development, System Design\n最後提交：d3f1e7a - 核心系統重構，模組化設計 (2025-06-20)\n提交數量：42\n簡介：特殊遊戲系統開發專案。實驗性遊戲機制設計和實現，包含複雜的系統交互和資料管理。採用模組化架構，支援靈活的功能擴展…\n\n🔍 技術棧深度分析\n語言分佈\nJavaScript/Node.js  ████████████████████ 40%\nPython             ███████████████      30%\nDart/Flutter       ██████████           20%\nTypeScript         █████                10%\n\n專案類型分析\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n類型專案數活躍度複雜度🤖 AI/ML2🟢 高🔴 複雜🎮 遊戲開發2🟡 中🔴 複雜🧩 瀏覽器擴展2🟢 高🟡 中等📱 移動開發2🟡 中🟡 中等🛠️ 開發工具2🔵 低🟢 簡單\n架構模式總結\n\n微服務架構：AI 記憶體專案、遊戲系統\n組件化設計：Flutter 應用、遊戲系統\n插件架構：瀏覽器擴展、VS Code 擴展\n模組化開發：所有專案均採用模組化設計\n\n\n📈 開發活躍度趨勢\n最近 30 天提交統計\n2025-06-28  ████████████ 12 commits\n2025-06-27  ██████████   10 commits\n2025-06-26  ████████     8 commits\n2025-06-25  ██████       6 commits\n2025-06-24  ████         4 commits\n2025-06-23  ██           2 commits\n2025-06-22  ████         4 commits\n2025-06-21  ██████       6 commits\n2025-06-20  ████████     8 commits\n\n重點專案提交熱力圖\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n專案本週本月總計test-ai-benchmark🔥🔥🔥🔥🔥🔥🔥47test-ai-memory🔥🔥🔥🔥🔥🔥🔥63test-game-sys🔥🔥🔥🔥156test-baba-chrome🔥🔥🔥34\n\n🎯 專案關聯圖\ngraph TB\n    A[test-ai-benchmark] --&gt; E[Performance Optimization]\n    B[test-ai-memory] --&gt; E\n    B --&gt; F[Browser Integration]\n    C[test-baba-chrome-extension-tools] --&gt; F\n    D[test-game-sys] --&gt; G[System Architecture]\n    H[test-hgame-sys] --&gt; G\n    I[test-flutter] --&gt; J[Mobile Development]\n    K[test-flutter-2] --&gt; J\n    L[test-vs-code-extension] --&gt; M[Developer Tools]\n    N[test-baha-tools] --&gt; M\n\n    E --&gt; O[Core Technologies]\n    F --&gt; O\n    G --&gt; O\n    J --&gt; O\n    M --&gt; O\n\n🚀 下一步發展計劃\n短期目標 (本週)\n\n 完成 AI 基準測試工具的 TensorRT 整合\n 發布 Chrome 擴展到 Web Store\n 優化 Flutter 應用的啟動效能\n\n中期目標 (本月)\n\n 建立統一的 CI/CD 流水線\n 實現跨專案的組件複用\n 完善專案文檔和測試覆蓋率\n\n長期願景 (本季)\n\n 建立開源專案生態系統\n 開發統一的開發者工具套件\n 撰寫技術部落格和教學內容\n\n\n🤖 自動化說明\n此頁面由 scripts/scan-projects.js 自動生成。\n使用方式：\n# 重新掃描並更新專案清單\nnode scripts/scan-projects.js\n \n# 然後重新建置網站\nnpx quartz build --serve\n掃描規則：\n\n掃描目錄：E:\\PD_DEV\n排除模式：node_modules, .git, .vscode, dist, build, public, .obsidian, 新增資料夾\n包含私人專案：否\n自動檢測技術棧：基於檔案類型和 package.json\n\n分析功能：\n\n🔍 Git 提交歷史分析\n📊 程式碼量統計\n🏷️ 自動技術棧識別\n📈 活躍度評估\n🔗 專案關聯性分析\n\n\n💡 提示：您可以在 scripts/scan-projects.js 中調整掃描規則和輸出格式。如需排除特定專案，請在掃描器配置中添加排除模式。\n\n\n🤖 自動生成於 2025-06-28 14:30:22 | 🔄 每日自動更新 | 📊 涵蓋 12 個活躍專案\nProjectManagement AutoGenerated DeveloperTools TechStack CodeAnalysis"}}